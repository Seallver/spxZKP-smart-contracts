"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@adraffy";
exports.ids = ["vendor-chunks/@adraffy"];
exports.modules = {

/***/ "(ssr)/./node_modules/@adraffy/ens-normalize/dist/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@adraffy/ens-normalize/dist/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ens_beautify: () => (/* binding */ ens_beautify),\n/* harmony export */   ens_emoji: () => (/* binding */ ens_emoji),\n/* harmony export */   ens_normalize: () => (/* binding */ ens_normalize),\n/* harmony export */   ens_normalize_fragment: () => (/* binding */ ens_normalize_fragment),\n/* harmony export */   ens_split: () => (/* binding */ ens_split),\n/* harmony export */   ens_tokenize: () => (/* binding */ ens_tokenize),\n/* harmony export */   is_combining_mark: () => (/* binding */ is_combining_mark),\n/* harmony export */   nfc: () => (/* binding */ nfc),\n/* harmony export */   nfd: () => (/* binding */ nfd),\n/* harmony export */   safe_str_from_cps: () => (/* binding */ safe_str_from_cps),\n/* harmony export */   should_escape: () => (/* binding */ should_escape)\n/* harmony export */ });\n// created 2024-09-13T06:42:45.675Z\n// compressed base64-encoded blob for include-ens data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: 0ca3917bee1eee342d64c631cb1dbaac37b167d848887d59f6d68328dc99ac09\nvar COMPRESSED$1 = \"AEkU4AngDVgB0QKRAQYBOwDqATEAnwDbAIUApABsAOAAbwCRAEYAiQBPAHYAPgA+ACsANwAlAGMAHwAvACsAJQAWAC8AGwAiACIALwAUACsAEQAiAAsAGwARABcAGAA6ACkALAAsADUAFgAsABEAHQAhAA8AGwAdABUAFgAZAA0ADQAXABAAGQAUABIEqgYJAR4UFjfDBdMAsQCuPwFnAKUBA10jAK5/Ly8vLwE/pwUJ6/0HPwbkMQVXBVgAPSs5APa2EQbIwQuUCkEDyJ4zAsUKLwKOoQKG2D+Ob4kCxcsCg/IBH98JAPKtAUECLY0KP48A4wDiChUAF9S5yAwLPZ0EG3cA/QI5GL0P6wkGKekFBIFnDRsHLQCrAGmR76WcfwBbBpMjBukAGwA7DJMAWxVbqfu75wzbIM8IuykDsRQ7APcta6MAoX0YABcEJdcWAR0AuRnNBPoJIEw3CZcJiB4bVllM44NCABMADAAVAA5rVAAhAA4AR+4V2D3zOVjKleYuChAdX01YPewAEwAMABUADmsgXECXAMPrABsAOQzFABsVW6n7Adq4HB0FWwXiAtCfAsSwCkwcpGUUcxptTPUAuw1nAuEACy00iRfJkQKBewETGwC9DWcC4QALLQFIUCWRTAoDLfsFMgnXaRetAddDAEkrEncCMRYhAusnuTdrADnhAfUlAMcOy7UBG2OBALEFAAUAitNJBRvDHwcXAKgn0QGhKy0DmwBnAQoZPu03dAQYFwCqAccCIQDTKxJzOvNQsAWQOncnNUgF+icFWQVYr7gFaTtdQhI6WEGXe5NmX6H4CxMDxQcl8XcjBKNLAlNTAnUbqycBj6OlNVsDRRcEg2EJANEGqz8vIwcpAjldAGsBYR9xAIMdGQCVAUm3ACdpFwGvxQM3LSFDUwFvWQZlAmUA8UkXAykBBQBJQQCrAF0AcwArtQYH8+8ZjX8ACSEAKQCzG0cB0QHbBwsxl3iB6AAKABEANAA9ADgzd3nTwBBfEFwBTQlMbDoVCwKsD6YL5REVDNEqy9PYADSpB+sDUwfrA1MDUwfrB+sDUwfrA1MDUwNTA1McCvAa08AQXw9IBG0FjgWLBNYIgyZJEYEHKAjSVA10HhxHA0UA/CMlSRw7kzMLJUJMDE0DB/w2QmynfTgDRzGrVPWQogPLMk85bAEecRKgACoPcxw1tU5+ekdxoApLT661f0liTmcCvjqoP/gKIQmTb7t3TgY9EBcnoRDzDC8BsQE3DelL1ATtBjcExR95GRUPyZWYCKEt2QzpJt8unYBWI/EqfwXpS/A82QtJUWQPVQthCd86X4FKAx0BCSKHCtkNNQhpEO8KxWcN4RFBBzUD0UmWAKEG/QsNHTEVsSYMYqgLBTlzBvca8guLJqsTJXr4Bc8aHQZJASUa+wDLLuOFrFotXBhPWwX/CyEjwxSkUBwNIUCzeEQaFwcRJaUCjUNsSoNRMh6PIfI8OQ1iLg9ReAfxPAEZSwt9PJpGp0UKEc4+iT1EIkVMKAQxeywrJ4cJyw+BDLV8bgFVCR0JrQxtEy0REzfBCDUHFSmXICcRCB1GkWCWBPObA+8TzQMHBTsJPQcPA7EcKRMqFSUFCYEg0wLvNtEurwKLVnwBEwXHDyEf2xBMR9wO5QiXAmEDfyXnACkVHQATIpcIP18AW4/UUwEuxwjDamgjcANjFONdEW8HjQ5TB6McLxW7HN1wxF4HhgQon6sJVwFxCZUBWwTfCAU1V4ycID1nT4tUGJcgXUE7XfgCLQxhFZtEuYd0AocPZxIXATEBbwc1DP0CcxHpEWcQkQjnhgA1sTP0OiEESyF/IA0KIwNLbMoLIyb1DPRlAZ8SXgMINDl36menYLIgF/kHFTLBQVwh7QuOT8kMmBq9GD5UKhngB7sD7xrvJ+ZBUwX7A58POkkz6gS5C2UIhwk7AEUOnxMH0xhmCm2MzAEthwGzlQNTjX8Ca4sGMwcHAGMHgwV14QAZAqMInwABAMsDUwA1AqkHmQAVAIE9ATkDIysBHeECiwOPCC3HAZErAe8lBBe/DBEA8zNuRgLDrQKAZmaeBdlUAooCRTEBSSEEAUpDTQOrbd0A1wBHBg/bQwERp0bHFt8/AdtrJwDDAPcAATEHAT0ByQHvaQCzAVsLLQmer7EBSeUlAH8AEWcB0wKFANkAMQB77QFPAEkFVfUFzwJLRQENLRQnU10BtwMbAS8BCQB1BseJocUDGwRpB88CEBcV3QLvKgexAyLbE8lCwQK92lEAMhIKNAq1CrQfX/NcLwItbj1MAAofpD7DP0oFTTtPO1Q7TztUO087VDtPO1Q7TztUA5O73rveCmhfQWHnDKIN0ETEOkUT12BNYC4TxC2zFL0VyiVSGTkauCcBJeBVBQ8ALc9mLAgoNHEXuAA7KWSDPWOCHiwKRxzjU41U9C0XAK1LnjOrDagbEUQ8BUN16WImFgoKHgJkfQJiPldJq1c3HAKh8wJolAJmBQKfgDgXBwJmNwJmIgRqBHsDfw8Dfo45AjlzEzl+Oh8fAmwZAjIyOAYCbcMCbarrhi9jQScBYwDaAN0ARgEHlAyJAPoHvgAJsQJ3KwJ2njsCeUc/Ani2GVjXRapG0wJ8OwJ6xAJ9BQJ87AVVBRxH/Eh5XyAAJxFJVEpXERNKyALQ/QLQyEsjA4hLA4fiRMGRLgLynVz/AwOqS8pMKSHLTUhNqwKLOwKK1L0XAxk/YwGzAo4zAo5YPJN9Ao7VAo5YdFGwUzEGUtBUgQKT9wKTCADlABhVGlWrVcwCLBcpkYIy3XhiRTc1ApebAu+uWB2kAFUhApaLApZ4mAClWahaBX1JADcClrEClkpcQFzNApnHAplgXMZdAxUCnJc5vjqZApwSAp+XAp60hgAZCy0mCwKd7QKejgCxOWEwYesCns8CoGoBpQKemxsCnkqhY8RkIyEnAierAiZ6AqD3AqBIAqLZAqHAAqYrAqXKAqf7AHkCp+5oeGit/0VqGGrNAqzfAqyqAq1jAqz+AlcZAlXYArHd0wMfSmyTArK5CQKy5BNs3G1fbURbAyXJArZYNztujAMpQQK4WgK5QxECuSZzcDJw3QK9FQK71nCSAzINAr6Ecf4DM20CvhZzHnNLAsPHAsMAc350RzFBdNwDPKMDPJYDPbsCxXgCxkMCxgyFAshlTQLIQALJSwLJKgJkmQLdznh1XXiqeSFLzAMYn2b+AmHwGe+VIHsHXo5etw0Cz2cCz2grR0/O7w+bAMKpAs9vASXmA04OfkcBAtwjAtuGAtJLA1JYA1NbAP0DVYiAhTvHEulcQYIYgs+CyoOJAtrDAtnahAyERac4A4ahACsDZAqGbVX1AFEC32EC3rRvcwLiK+0QAfMsIwH0lwHyzoMC6+8C6Wx1Aur1AurgAPVDAbUC7oUC65iWppb/Au47A4XcmHVw3HGdAvL/AGUDjhKZjwL3DwORagOSgwL3lAL51QL4YpoYmqe3M5saA51/Av72ARcANZ8Yn68DBYkDpmYDptUAzcEDBmahhKIBBQMMRQELARsHaQZdtWMBALcEZ7sNhx6vCQATcTUAHwMvEkkDhXsBXyMdAIzrAB0A5p8Dm40IswYbn8EApwURu+kdPT4WeAVoNz5AK0IhQrRfcRFfvACWxQUyAJBMGZu5OyZgMhG6zw4vGMYYicn2BVcFWAVXBVgFYwVYBVcFWAVXBVgFVwVYBVcFWEYVCNeFZwICAgpkXukrBMkDsQYvu7sAuwSnuwDnQCkWsgVGPmk+cEI/QrZfdTdf6ABYETOrAIz+zGvL/KbnRno9JiMEKxYnNjV+bd9qwfEZwixpAWvXbjAXBV8FasnBybgIz0lbAAAACnxefYu+ADM/gQADFtEG5a0jBQCMwwsDAQ0A5WUdPSQfSkKxQrxBOCNfJ2A2JzgjCcE9CkQ/Qz54PoE+cD5xAolCvElCO1/LTk9qTQosa1QvagtuH1/gMzobCWebCmIjKzwdJkKrQrwrzAHL/F/JDh8uCQgJIn6d32o6LUoXyavJrAllwcvMCmBBXw/lEKMRAJONHUVCJRupbTnOOAozP0M+cEI/HAcKHUxHbFssLVrhvBIKfe0dK0I/HF0ISgkOM1RDQjcEO0OcLAqBGy1CPxv1CFMiIxgwMQAFj2HwXgpxZMlgC2AtI25DYBk5AhseYLMGAmsQZU5gTREBZOdgFWCVYH1gs2BLYJFoFhcGtQ7cVam8WgtDFqsBuyvNwQIfFQAcAx4BeQJsLzCVUoABigq4RxoA5CN0jgrKDaZN6gGbAoecTwVAXwD39wkANBZXDAulDCQfuq9HAE8MNAAVE58rggh6AtILS2URGwDYTgZ1BAoeWgAxALa4AZonCxZvqyQ4nxkBWwGGCfwD2e0PBqoGSga5AB3LValaCbthE4kLLT8OuwG7ASICR1ooKCggHh8hLBImBiEMjQBUAm5XkEmVAW4fD3FHAdN1D85RIBmpsE3qBxEFTF8A9/cKAHoGJGwKKwulODAtx69WDQsAX7wLAGNAlQh6AOpN7yIbvwAxALa4AZonLTsOzgKQGHtQu1jIdHKO16WbDvWZFT0b7AEpEFwSBg8bAccJOhCTBRArDDYLABEAs84BAgCkAOEAmIIABWtXLwAUAFsbxi5sdioNwRACOyQz0+EcHgsbfQJ7Ls6hHATBCqrxbAA3OS0Opge7CQAQOi7OERkAfavaHA+7GkcczaF3HgE9Kl8cAuugCAHCAULz5B9lAb4Jtwz6CDwKPgAFwAs9AksNuwi8DTwKvC7OoSoJPA67BZgBG2sKD4sa4QHDARELuxY7AKALOxC7BBige9wAO2sMPAACpgm8BRvQ9QUBvgH6bsoGewAHuwG7D00RErwBAQDqAQAAdBVbBhbLFPxvF7sYOwAuuwLrDlaouwAeuwJVICp/AAG7AALjAAg7FTwVuwAbuwG9KOClWw6/xAD0AGj7L7ZtvgNIo7vIqDsDAbuVJ0sAAlsACrsEAOfdGbsIGnsIoQUK/3AA37unuxjbGruji3lyBvupm4MAErsGGwsBvAAAhgBtuwYAC7unOwEaO7oIoZzKAbsL7QfAqTsA4XsBvwAA5QAVuwAG+wAJuwBpiwAauwAOuwIYu45pFfsAAVsADmsALkseAAa7ABe7CCEADUoBwgC3ryYBwAAAtAAOmwG+J+QAsloAHBsBv/7hCqEABcYLFRXbAAebAEK7AQIAabsAC3sAHbsACLsJoQAFygBunxnVAJEIIQAFygABOwAH2wAdmwghAAaaAAl7ABsrAG0bAOa7gAAIWwAUuwkhAAbKAOOLAAk7C6EOxPtfAAc7AG6cQEgARwADOwAJrQM3AAcbABl7Abv/Aab7AAobAAo7AAn7p+sGuwAJGwADCwAQOwAAFDsAEWsAD4sADesADbsAGQsGFhsAFTsAbpsWswG7ALoAEzsDAGkrCgDhSwACOwAEUgAXewUbAAbQABi7AAv7AF+7AGv7AOSLAbsAF3YBvAABcguhAAVKHgF7KFIAOUUA/gcNDHIAKCpwAaQFCF4BvF4jDAkHb0tsXyqJHzwUYi02A6EKtAHYABYC0QNuAXZyR1IUIQNPAhU+ASwGA3NGvHtSekAAKQAxAfsAUwrbAHuQLAErAHblDREyRgFKAFcFAAFQAQeKzAB4OwQgpQBaANYVAJVoNx+LAM1rsQDP1BYIwnVzGxhWHQnRAYiQqyJTU01IEjzCifkAfxw3QCkr4BGXTwByASksMClCGQ8DMFUE98XuAEtl3ABqAnECPxF6Osd4LjXVBgUAEBsdCggMKgQfHSlOU04IuboAChLNACYAARoAhgCJAI41AO4AtADgAJ08ALsAqwCmAKEA8gCfANMAnADrAQwBBwDAAHkAWgDLAM0BBwDXAOsAiACiATUA4wDYANUDAQcqM9TU1NS2wNzN0M5DMhcBTQFXL0cBVQFkAWMBVgFHS0NFaA0BThUHCAMyNgwHACINJCYpLDg6Oj09PT4/DkAeUVFRUVNTUlMpVFVXVlYcXWFhYGJhI2ZocG9ycnJycnJ0dHR0dHR0dHR0dHZ2d3Z1WwBA7ABFAJYAdAAuAGLyAIoAUwBTADMCc+kAh//y8gBgAI/sAJsASwBeAGD5+aoAgQCBAGUAUgCtAB4AsgB/AjwCPwD4AOMA+gD6AOQA+wDlAOUA5ADiACkCdwFNATwBOgFQAToBOgE6ATUBNAE0ATQBGAFUDwArCAAATRcKFgMVFg4AigCSAKIASwBkGAItAHAAaQCRAxIDJCoDHkE+RykAiwJLAMMCUwKgALoCkgKSApICkgKSApIChwKSApICkgKSApICkgKRApEClAKcApMCkgKSApACkAKQApACjgKRAnEB0AKTApsCkgKSApEWeQsA+gUDpwJdAjYXAVAQNQLeEQorEwFKNxNNkQF3pDwBZVkA/wM9RwEAAJMpHhiPagApYABpAC4AiQOUzIvwroRaBborDsIRAZ3VdCoLBCMxbAEzWmwBsgDdfoB/foB+gYKCfoOGhH6FiIaAh4KIgol+in6LfoyKjX6Ofo+CkH6RfpJ+k36Ug5WIloKXftoC2WzhAtdsAIJsJGygAINsbARCBD8EQQREBEIESARFBEAERgRIBEcEQwRFBEgAlmZsAKMDh2wAtGYBBWwAyVFsbADPbAIMbAD2WmwA9gEZAPYA9AD0APUA9AN8XmzUhCNlvwD2APQA9AD1APQcbGwAiVpsAPYAiQEZAPYAiQLsAPYAiQN8XmzUhCNlvxxsAPdabAEZAPYA9gD0APQA9QD0APcA9AD0APUA9AN8XmzUhCNlvxxsbACJWmwBGQD2AIkA9gCJAuwA9gCJA3xebNSEI2W/HGwCQwE2bAJKATlsAkvBbGwCV2xsA54C7AOeA54DnwOfA58DnwN8XmzUhCNlvxxsbACJWmwBGQOeAIkDngCJAuwDngCJA3xebNSEI2W/HGwEN2wAiQQ4AIkGjTFtIC9s1m4DJmwA/QDGWgJsbABVWv4UMgJsbACJAmwAVAEAuV5sAmxebGwAiV5sAmxebD3YAEls1gJsbEZFNiJ9FGVAe8xvEZKvxVfKZszAVTBzYBH2d1iyUXEHH7twNw7eZF5JJRHI5EgaRr5D20/3dfONrFLSq5qSrrgd2CEUq722WBQ/LzpA+bx1oREI5xy4BDSZNun0ZWORUJqInZSyMaioyvfSI0l5uFDzbWaQ28/zdB0hwR4OQZ0/jn9ALSLNikjFYGfqR389qtFlhD3a6KdIh97rhZYpywuLc7o8ql5/X8KCbPU3L/QlmCowhRXhsGDvg6wUNprA9bM/49uxlAj7ZVy3ouEY/BgFXBNyK0TLrSjZWeJm/T4nz6QGLT3cJNtWRZVZTvIdtaxMMJRHgig9+S11LjBh7Inr06ykoch1U097Rw0hvgmOrydQyaWcEQDg0RavuMuT0zYabUZl1e33HNSK1oNUCS03eh+9C2EvF3fq9h+XBaAMFuoWeZf+mfZgL4HzyiKDIUtfNU4oFu0aE9qt3VA3U4D3fOSrAcYVnjG3cSkp1vhXZnp3JQm4JknKdBitO2NVnGCYQwU3YMWHWB87NEd+4AHuOKI8BSIH92reW0pfs+kWCTJxDCbRjFv8Cfc4/DSBYJScJYTeAEgg9wTEvcwd/QuHRHqGzAQ4fXf5FUI1lPrO+fvEcPl4JInM1z9AtBT2bL4QYEREe7KiSnnxTwtmAFjn8lqT3mND8qTktX2F16Ae9cakqJ6/pEQsHURqyqWlRMCzKXRKfCHT7sYHWx9/T/ugYTFY6iVN3Btm58ATJR5alYZybKMWojwOw3HbFn23NFyeLl7+Er82RchyYuBoGQ3j7SAWNxiYvp5U+Fq/DEzB9cG5DlJWsqkosRze92OVlCtQEYo1S1lF72Z8xWc4ld/+fFcfTEDTFb9d8tJGQ75dpJEvcWyGmGBiTbiWDdGOcw93Dmxq5ISUrmasygONfHLvhgo83HQZenbdBtSzBkvYrCEQ/xEDMhMZsN6gqplx5jGG9mSQLhM81UEdEeJ59sdNJDAFy/gPyJoKlwPZgB/MkC/kICLiCB8va+nCdO2ry4aDfkmPFpF/H/SGQ3LJ6aAv9dtJ8DniHtLOckZix0BVb0iR5V3LAp521LBSIi6AtV7r2ZB/hQEvAw54EFNOQcFnl1xGUIc67tqK1INNwD2n/RbwgzO9h45LM6VMuN8V1ZNIQ6t+Xy3lTqyVCD5kqLy/t3/b8MLbgDg8JIWDkSZ+LrGhhr+gYpH+pr1TnCUnZPjpUdw6bSL6MWVXoDDciQDWECwU2e6VEpfrcOBbrSOijqGkEIoJPbpmeJLkcwbvA0yWIixQVjo0HnYh7fji+Dfdq1mtV1lG2Zz9R7eFMHS+FK7nybutu2fwzDpFldO2pZBshsHJWaltn3PWOoGJpCT2jE8EHOuC6FkejNWcfsWCqNqMLP9xTwcWArj2EiiI7D+EaDi7/2cqHL1gPiF6C/J7aUo7RQqogPZ11WqbyP97nsoMxPOC78wZMF7B1Y0g7JNXJV/nN1m4xx8hbqWz07KSaqr5hE4icB326DMR/vUKX9LoNjle/ZWtbUhrTAcsdgrLlG5Ne8aiR0bS/2ZhpNOVVxavWIZsEM/rd68EB4vjbbD13NkMK1qvMk74vGbSkL7ULO0sZ9R6APSCo6KH+Xn98wEdw1bCPAnDTaBsD6sidAGN58uiH4a3ovG1KyZAu2XtyGgF/vgWKGxw9R1lfAVcfuYE71DHuxtTzfGZnHaDpDGWmfEq0N4GawE7yIkaoz8jcmVmzJe1ydM8q0p08YIxFcY1YcqQc1djWBEoNETDFcgk5waRftEJasPREkrV++N/TOKkERF1fCLrXS8DFGYGRBeECMQRNEs0ES3FzUtXCcNxpYEM3Uei6XodZruXUIRnn+UXf2b/r7n1vQutoi6WoIbW7svDNWBbUWcDUc7F9SJK3bvSy9KIqhgyJHoW2Kpvv0J4ob14HFXGWWVsYXJzjwxS+SADShTgCRjhoDgjAYRGxwJ1Vonw+cpnCKhz8NQPrb0SFxHIRbmG95Q2hlC4mDxvPBRbkFa60cvWakd7f0kVBxxktzZ9agPJEWyA63RSHYVqt8cPrs2uFJ3rS3k9ETGKn5+A6F9IOrdZHfT1biEyUJKEvwzuscwshGCBJvd16TrefW03xVnJf4xvs72PdxrMidjJO8EiWyN/VWyB3fv9kc34YIuZTFtXGo9DuG3H1Uka5FgBMwDPEvRcSabi3WakNQkXFecJlFk6buLVk5YHpuKWTw6oF632FPPSVIVl5hgUAeHhj0t/sw/PEEvThLQDDFE34eCg/rLOyXT3r+L98oRKrlTO0MdALYQ3rRQqC7d822dJPGxF1K4J2TtfPSMFaCAg0n0NGk9yiaKKOJD1v2aBX9HUOIawjjfvwCmjHZJTR62R9c9x33JnBjWrN4QYEOmehy0oZMP9XM9Zyi6TYoe07PaLceRXcCWZiY/imRUWW6+mci7+wMxSdwMdbXckXtvhJH8sc4iQcTwm7yp+3f7CaesTTQB2qkgeXh+wFiSMXfMlH7Yil0OoZ2QTtRLTip2O0cLZ4SstqWHZ6H+8A2kZXhpm0kPbL9dUanTOvziqIUh6Ambwa3WrCb2eWbuCN3L1hgWUmjRC3JoL3dBhR3imSQI8xuCMfsszlji7cSShNSYdqCXPxEVwbqO9i5B6hf93YI7aeyI8jxgcVXK0I/klbvhSXjkjOIwZgPdVwmsFW7HGPLUAvDRuKm+itybRg7c8+Yqqjg824Qf+/NxsBSUNAK9KCoJpauFqK0XQULrWYj4FnxeKDuvr54iokpi+D57e6Y1zxRJJdsHnDR3JyraCUufHBRTKODWBVzthjm4k3/Hv+Q990XDVR+KW+TcJX045LW86EKhz/97aqj89A8ZvTk1//tczosU90loIPVaHuWegJU3wP//7XHcO7c0yQM2jM/IhQKrf8hiObHWiWDZManF8Uf/HzbmDfC2wT//aiZ4hGTv/xzgKwdb1sD6cGEkceow0s3b89/zg+3plyRm0HlZi886j5wUwFhdHiDTaBidZRo5cx/tMeLyguOATbzq17ydhzbrpxunuHx6lbFGiO97gsd4dk//7iCIo+Ew+hG2so5kvv+ITG4c1fzHPtu1Xn5QfUnqY3/uByVmB7gmnE/E+5zdm+6nDmoews5fr+NzThdSHzK4bBQOL9c4O8OI0xLSqjJ4lbniLJg1aFpQRLwaSMZmpkC9e/j6FOVrTQ6a/a4alGgfrl2ZL1sbHUQ3DOI7ntq9diHFfm3t1mul3rdJEJCHnlW/hlQntipMrpeMs7fUr6wK370D7VbXH0DUHzdYfRg/6Z11Ult1sffJS+heHbco15Sxy3+rDnPesqH1lajk0yu02hPUvEUqvcUXWXL7Ad0wNGMx5gOle4XJxq/r/YY0xdco2wRSEGwcT7YADlBrHc9ZbvzOL0QwyWCWWChB9Obg800v7tyBWaNvdwz+fL7Ph9i2irEeJkRgOzeEDw+JiD/V93vH9FgMEoFIJMoIuogmicZohf94SBuPn6hXaV9jP4VVVA/bu+Wg8S88GLtmEPSNRLdtlXx2XL/nuM8nKkhnlnjaropiKKLIH94pLIASci0pDBfj9Hi5BfaTSXQg5+PMjQX91Ktk4MOqK1K99l4BRPv5+vNovGZ3IxQv8ICvjV4/diThpoaM8uvd3D9d/DE477w3yAbW3IDm2i73pZ9aEj38JqS6h/s8/xgmUIVcuq2JTgefAyuoafzQxAuRASeg3NtG3ach/JEkyuX+JDt2PnDZTShUhyHHG3ttBg/6lhAchGjLJBtopj4e01MlCp2yqQRTr4sBBXru+lKaoanwYX8y2aWCJiR3KnhCOkYVFSvsO0oDRujUFOEptiNDTYrJoUbvOyvl4AhC9h3wORiTXK1MrpMfnvdnndnR/HRVSusMBgIxwrLdn3vq1VcncPiD0SquTx/kNmxeFyCT4uXVUd9AL+rSGmuq7OOCzDKeVPjiNWVaoP5KOFqYq5Xcuf/xW9S+u9eIq9GAtZWtQlgkRecjRtvG1NR4WXXpn+pwsTBTIy079Ikg8rSef1aVapIFcXCd6C2wHVjLXR+N0tw4Taw6x6H90BFRgNrtlq2up6hHKuV3inM5RJaQWZHd84e6RsKkk9po3dk9by54tpPw7cBkFas/G+GbHwuG+AwP55BZyXILTHCIVrPpXHEaUPYfL6nphJP1Rc10xG4UaCeY4IHCwuur8xmSQDgY4aVwhzWhjbtSHG8JO6P2i2nC9/0Bfx0zk6dYQq3aw7k5vIObD7SEKrxhz0fQ0+YTOfHW23CBNeZci1qNsUDhoeqmfyP6PvjoEjHk8QbrFyQVZPHVWijnb8YCM65iYNoEbvnchStZ/9cKg5Vd45j8KnB6UjzXl/bkyZx7VoD47ocUUi117WwgySSb4rXgLJ52Mv5XJbp3I+uBP81BUvOjy4Cacgi+GWWlC/8dwgqwiojjUBDnEOxyRyowwLQfytFra1OZS4XvRYr4uoamAfG3I/p2bA7G90yqKThH8Ke00Tqd+3l3dmJpaCZelBMYjGqNLVa3SM4+LQeL56gY6Bymy2LQPVOxjWfj5tq4o74swcxhyGJPynkS5xAjOXZP1/FAYcBT3u6qLoIkEfErwo4gozmyI1YCvM0oyI3ghjGPQSsof2sKUhq91WsKy9cYWN+4A2v4pG/Mxpdc6w6kI/HX7Xb0TuihmsiOy2wQIsrZbUmr3OBSUo6oDJNgQp+YqYkgTgYcWZDgawJw3DFfdzT//PhVUidgB2qa8uw/j9ToHBAS33iT8YLhhAfyXG0bQUFp7QmH7oQ3i6Flf4OTZLvJdh8pfuflmWu2ohm5pTiSg1pl3vq9uluTJwqXfh1hqy8e2iHoD+Y35gCIViTo6VOtK5dD8HYClucJucXASzwe2kPj4S4eYQtmkYHagXhAzp/F541xE8YFYqSPszDuz3soWzHy0p3E2jwZNQaIcGU9FNQwQxeDw0ZlK9dxXrj9IUHGUPTOyib8CqXmbZ7Ex54bn1rLx3qqAavu/gh6XjV0GmN1p+yyMK9HN5uYEvxgbAk43tsheREhyI+Q5WLIneKTGPmYiM/lxOp8fvqHy8YgXK0TlMiX0tliLI2JtfmWZP8eVV732sdYm+pcWzDzEmKLJZyeelyaZKkjPnnUO9keDwtgiLnmd5+t+Sr5y8brRnlvxcWEWfCqIALQYHvaXx6jTg4dAlye469uGwwOZVZCILLfGjaMg4LUCNMTtMSp1aC2y/3wR2t1v3w/iNBRQ+bNbtDqL2NAr7K4rUcyqbSpNrXZgAWXvjxBBtfYLK1uRYt3q2pfXJOAL0HtWcEwJLddOSJKV1SwvcvEuzg/4MPnA8MIUJOLqm3qI6wFyN99Ck6zYaV/zGSAzF/PGsaNa4vPLe5QnyuqVUnVQ6xELA6gbe53aGgeke+R/ycb2LJVyc7BhuzI90zA+c6wUDTb7NH//gdDSl2u/aW7lRJm8m1fLtPxcNuEM5JbkOCZKPM88HUsLRoC1pmKKlvWyeAXuxILbu0snpSxf8N+RgtLUSe5n2gdjOjoSTaN7mMZ7bF+cWk/MS8mFD4pcyl5UN7CbpFZH2a+Pm1VAnUTVfbw8qrmz1G9m5aKmRzY1SMhhPrlCn2t4uNUXNA3IFe6NOjSC1DEaAFZAfDlEkQCsbNhsZPj6NQPDSB3tLiTo0ZYoEbIeEIaKtU3Wk60rEszawTFuyHVd365LA/c/uarABN5M5rGq/dqTG3Ilye/5EKiYisisuzqNaZjmWv0z9TORc0CKbaTea214oNM9u2sXUZub/eqM3Pi/PjRSyQiOSwPWif2asTgu6hS6fb5UGosCWxdedMqdViIUUSSdIJx+qQ4KShfTT39VAWZbi+mB+iKICNwpt6cflY57Rcbs6d1kA26Iru73cuxYVlSvuJdcR5VfDYZRk8X0AXePROyw3Le6LaUdmTLzYsoNhhgQpd67xVNiHgk3pakmndeIAtTC4DCXy9oS6eU4CWxDdVmY53pKNbdAKmQsP37lrJZC6iDXMELGKcHjNuuZgcDyY8W/yv6ha3DX7OWm/35fpvhw55oitf4V+GULlcPWYyGGuVBdro19c8u0RDddDun40W7G5cSIzHLh/qZxb59R+EPY+wZ2XerkUim92hhXpKyW6WtAh6zQS97DrPyjCvKi3pCw96LeKynOpyjtsMQc2RmI/20zFOZcSa2AK++PoRcT6zeJyxlBZ7kk5mhqXGkLlM2hFKc+/T544xXP0Ua38Q6xdPTLTeG1PHnLMaOvksUQMrEFTB/lizCirmFQL8zYVU+OTeYQEFaITsBSMMYexS9HkajO2gGIf2micvntCZJsZQEwIH3/4JGJQGflBuH5rNXmnRRYXDQs3ZoEQoMtYDr1kFKUS/siiQSUxcTH9XYeBZiKDDFQoExREO9dddKQLO3BwMHvymCSTFyY+vxn3D27NDx6OlU092D5EDUwilttqVHpjJQDUceJYCLsK2swfXeNUVrBJT/w/sk+7si8rPtiMFis+oxvGdGQxirMBID700T39mULuNHzOyN+xBfcFACZcyngF1aSpv0JPkNUrAZTqfplv509cGXFUiEEm5dZb+OsP/blizqdK45/dSsIrufYTrCPY2lgJD6k6QljTfXVlHfYKSq+MsagyUcaMintyr95bD8kdTAeYNLNsMmo/Wdd8a2nStBP49ARIjqqpUHWY4q4mvO5Cq/CgCP+4/B+5zutGwX5pssgVLr1+fIM7WWLfiUQDk4c6ZdHZOWv5hG3g2dgQ5NXnpIY+BWwJpaouf25bXnjDzbHnQNofH/c6m+dEAS9Gs2h7pFRPKOBDnqswZ8KZjhId1ytHUTs533KwBoSiImoxKQUgZ7z6pA9QB3sZ8Cq0vwutJTTkfbX8AzCpm2cFXx/P22niUMHauU8IGc+78R6TsutoonoqFuoNA3l80t387YHMoL5KGAT1JO4zmx+vJ0LbLHlicHraSVYvJjnO9p++qnWgKw9OwFVVUagvZuf9qfiuum+hIicxP1q4zDnzkHsCNriLxBpxY9N+UOmqzdY1MunLMDgkMyi3uvnN3UBXJeZ8YLs5xr8QrOhimYoKuGBebZHAiBIkViv3DG8k2oNpp5OIgX6ulqaRN8V62QUPjn5tl1kPXhT9bcd8qIm8gi4or/FGbvQ6pgGSHmnayrugmf5E0upGxPRf/3xOtitGMaHLKJVm5zhglmVfI91o0yxhJZVS/5wQ8zfxK8Ylw0WmHXoGfRkoBRx9Hsnl/6sgTjAVwpmNuSeZtBwlX4qB8Bh8lxjqBDIuFGJ4I1wxN0XRlAAslzqMKwQfyA7OkuivCXfv+i+3XmhcBFM2n4jdT+NyUmBnQJPV3F2sZfKvJhUlXzSosFR4VevVVcOkFnnjdiRWc0TeSYxj41sJGYMbZTeLI3GvyZ8/gAAudQ1+4oFX+enX5V49MczGCYVBuoC4kHjp7ZVxj+clBwPr9k+v05SsezQK3enxLs1Nt/N7c7AImVUysjGou4iOohHo83Zs9/MI/OWB+OyXzOBD93NbApGHXrv8CVRHp2bwH+xB55cfNrdqFD35HSMx4iVmtzYAmSCIV8kXsHoq3DIb93riTWbubnjxbBW5zConVtbxLRStXHkIyAByaozME952Gc9aAdAbBpZSVCH88Uwb/4bPTVOVl+WoMYD7JIvK8VcMrJ8zHV4bbG0Dg7Kx17A4ej/ZcZ2Z5pVuVLUH1E/AccUTKm81SE+LQ6STTUDscUk0x2OWIbEORhg69tdoTGNkA1RfkGIRZHr5mCXOpLC55WWzCZoGPFUVtZRHwh0nq039CDdjEPo+JyaxSQAvDgR6Iqvxy0frrtEG1A385N81l05SSzN+IDm9bypF9m92EUqblnauZ5sjc37wRykOdl7w4o8WMgQsjii3EE/aJYDfHs1cH6DNBEujjcCc8qAefYFyIAURDcDnzun5UmkbBQsU4eu/W8I9nBE0qJKTdg2hwjq0+XV7a3TJ7R+alvJZCRia9lJ+grNB9dbrOmWEvUotMjvDhq4wV/kq4fvIBkzUGpDeYH74rne8uU3dgoNZdR9pUL6q9YDNRfOiF6Dyk+SYXQIghTjm9qR4tBHh0gnmF/9q3Qv22EzaLhSvDlDOxMrrCNRmLCl1jApzLrBCPn2mjn5zqK7OYK7VxOfQ5GfBfoPdyQwqFEgCVHkJ9oTnagRM3R0+rsuN5jQv9icCav/p1WqiEXSzCdLd/WEA6z6dDP7tPqPbeDYKAkVcz1lLGbFOC9b7cBd3MV0Ve8dZ89oR7OnxGS7uVpSry8banVZwpJg+nkH1jRBYa2BvBMY2xITH9ERXCjHzdZxs+ipdXP2DY7X+eWiBhtT2L0RRGTLPeazn5tpl4tu8iE2rWig731iuJDRbCHHy+g/Mb9+miAyVqfIpXT/iZeOxOxODO0hEpLM78I1+G2Z45yi3lS1K3m4WMQ559Lp4UML5vZUjYGJuxl+OPpUH5klpyBujkjprhei0TmUik10gjvNUp8mDkWlNKikmYspaVTqewbnOzJrmz8FLIpsT67EJLHIIfeDcWEfiP+DJrZ1jfxpoAb2abeMqLx+9RuZGzQoYtYVGgAWwEM9Kek2vPIeBNAKD6ao7nw6sgvfeLZPoXkbYO/tStHJdKzk+WFSFEU2NcALJAEP6S8pcnqqBBt57dwTrzQNCIdk2SocK4dLRbD/pu/VryKnm65ZYXiJCfHJk3mx9MRSl+nSK6OqEBSoGjz0/LADddwF/HqcfK3K3O+6YUGQcmj8pZL4PhZ6KrGkb8B38FmDvvLd3XQXbvS/FQmrXFTvJNkaN/FGo83KuS43BK1UfVnIqigGkCoP5fBda2MwAGTGNKX9K9t4Bx83pMFc5KSORmWKv+8VoVggWxoaBz3/9IBh6RwLd1tebwy89xvE5z6EEpXpDfrXWfRsMs6+ekUHH6idVosno55+xQ8Zqzelh0bxtJTgCcH3Z3/Cxlx9eNIS4JIFKOAVrDqbrXRszmY55a5+niJGHtkO3b6mnIDxLa1WXc7BAe33mt2KyM4Fbc3R6/WVTQN8QhlqAtave2WsQTqzWeSlKuGUVIJRqtObpv294rS0kDN1RKzdstZTXJebR2HlzsQ4P3NbMHUqFZMZw+/IKXnh4t+lY8qocp/B1oMszR03EFs3bPeND8QkItMvllObeCz3SZAjqZrobmLcrpFyQV7mwBjg3C3C8/bc5goQhv8j/IXMLGnt4mF7tybRDG5G0polxoUScQkPvmnga2/K+aapKeqSL0BTmo1Cm5g+booNOtdyKva2KoefRURaBk7113QKo3y+WTuFKtgETIK8HRluYS9DvlcciCDvnG8UaJRfZE2siZsiTHvRmN80xkUIInHeRZl5Re/+ATL6VhKFi8CZ/n/jbFV6T5pZ+Uoppvsi3qjacVFOJgWWfdlwVHKPW/TJO3na9hRM9bS2yo2rEsC6IBzRReVO6IesJU7PItzOamr+ROFfwGZmZ7ue8HNxAgLJKb7P3p8dMqk6Be5PJaT/5Rdc1deYVihWH9cjVKc9uz5EnfHqxLUkOO8iJUENBNVf5LyNy8zjLu/78k5WNTywiPfYeX3CPk7yc6CI3lum/CEZwfUaNpcI3KsPqfn2lmz3kd/acQjKA1ebkJaiuLD+epQ/Fc1llHXXMzofWzz/Kd29SNmOhcjMWw1jq1g3YfrXZ9rzXDYW4ZttfgfMi6oCUtBs0PkMVuxmq5lxEoCaSXPSqCJJ7MlKdRDidVt0AFlxk5cTdX++sBF2+E35mjwfm8ERVxH0FvuAQtsfA4V2G0TKTUxeyRGVjd/u6F1SvuAiU2/WaQjcNCU4Ep7VunXCYSbZj3U3wzu/LWM5MPlYuyQ3FOOCD/zt7K295hY2JhwF+ODDIZ676vGQFKveEQYkWj7lkK7rVmD7MhU0Y/tF8EcTTpo4/yqOufbd/zWIpMajnbDuWK2vn6OPPtz2rc9MIBNlPd8tt+yf+7SC4wqEPbozKMCwY5Bygx4JmoIEDsixWRDcdHd6S3/dZMHXOJAAv7+NIstl00crgSqHZKAEe4g3G4dzIV51EeZB01r7p8GNlfUnG/GjZgNGsqXZdYMBVtAtFNv3hJWPve4GvqZ2XxuiNkHTz5kxWgr0PjQdJlVywJ9Zf2ZvqeeTbolKtvK54re2Lq5BoyzfsRtvDfyao3kmyFzDQ88nM+qx83w74RDlkngtYiArI05Epre3GgBeSlMig0pE6RGQaFznKkGeb0SozLCyiOtxh7hgwZlbKbClzUUfC8ntMiHUOZE375RhTy9c4DA+oMLkUDkztSybZbdmP1xpaIbjUpPAHBq3cIq+CBFzbMlMMCCkUQ6d9LGV6GYCsYiEWZIy3nBnuxOYXeU4YTGDSin9e4/pCjPtQSHlg5LMEvIlF0ElthqrF129iK2RPBEWd3XWOl3SWV5uz5VUyZYp5kEFmz7QfP/B1W1BBzQ2iTGbSVT79lUHzcGXz3PJceSgz4uknETUwo0xffpr2KUvZF0i/r2sL3IFIClYx8CbIZE6Qt7MDJbOPB3xMScwaOcWG66IJfCnDkb0D2Mb+PHzX+oiCbxeTIogtyN+s2NJirNACk/OACSOTtV6vscwbzW4M168xqaI+RzR47S1nlV/rOoZnid87n/Ima2XYa3un3BuGAisNjb8eLMT9OnMtazQROFCuO1HiZXaOc0oUDbNC4eKLToOx8DzVhMgGA8XIAQ2x3b6I0uEyLssQjJX3QphcUMx4KsMgJ+72km4N2aqkBF2coKmUEt1eqIMGn+5txMT4kYVGd3ALO+y9Z4PP3d3l48JQK8s9ZZ/Qx/+NBKgBEJFlQ32psoJiihGO7FSYM5L81q72kaAYcilEFMG+ZK1BcMqELkflyCV7v8JEXLO4Rf/oZYNZHZVjJhfL6fnpP9Tio3Euue5uS7FMkfGOeRCTrBZ06Caev7tgufeTrX34Ur/Vvc+b8ksiIShNJtuF9WmYxOZ4xg8y6zTdy3KAB2y5kYkcRnXsptWwAFyKZ2I/QGySNeoQLkINUMloC+5L3WuMMx297Q1xUYLKqZ9XHavaobo6QQv4auMm+i84IhxRpPt9nUmcav9NcjCcP+TcMmxsQZ/F3mgeoA0fQgwvTsyXuuTaM3Sqtv2jaaajmaFQpK9W6uIbeqwvSDo34ZrY6elDUHwSCjHRRmlwmyy+eOra64Ssq0XSXYljMHtKY+FShcMkHsEUY/4Bw63dJ6KpwDaxmthlDdbdE+TvYF3v33cGSKqO+1H1pKYhJMvZD5ckQcHyNF8zrtiR5b0ko6NPGoRexUZTYP6VbUdn3zzxGBOi8Z0OqHjGqYxRXwN3mYi0GYEEZYq+Q3QvdKcEHILLLj8S+VFepSfErtmfZCdvxbfIifFSpEzKi+7VJsLMT+zEFeyp1OdwRC1VZrfTLIyR7xTPUcZFYPD9qI7D70uTb4hdpqPXsJIRNYbZtNwch1OI3trh3u2ScoQyM9POnInsUa+OovcwkUP1UfIzPb95n4BaF2ev57NHAej0+BVMF9/Cj9663HN2/JN3SQgslL914bKfiTTDFAz9PlQEL/dSv1H8xl3mtWxh1McFO9EJXlRDaKQDsyKO4vOJW90NFE6yw2tjbc2GeF95sbs0I9enAa6QwQVf/kJQhAD2BzUDKggOyjy1TEhED6sfk+418lQy3c/uj8aw8UEzZ6hIMCd8RohAkumMtIj9m73l2yPWoGHVTPaywkC7Yj9tBM1NxMgcrDwRtk4RO2WHT7Ql5kQCKdJj6kNuOTeyEBYBjLMhGz+O5/YGa84HEiTYEpZ6fFzy26GG2hWtTyteuYrhSyG56BjsT/wQeLRytpTY3D7sIMqZnJ9z1FDrfyjFlGl2TNw9BQysbaxOuwYYZs/7I6BANgkqCknWZC7/BBXvaeKwAmC959I+G39BUE9bExkNlbRoFRyEtNzv+NJ91FuisG3JCS6uYBeRnfv8AkAfKTeg9EYamqnsGfAV7d0f9DghHEQ5IsPGDIUhgoSj7obM4Bu5uhQ3/CYEDTHc92AsFvDK4XGrwUeGBWBHPlS+f4x+CxmmHz2sAGmSFNt65kwZC64mnaoWlu2310laYn8r62AqsR5dfjyK18MEdurdagldzfJtjFXlZs7St4QhdPiye6TPh2/ZAQLU/Fip5s7TDEM16KtRWrK9hmxnQ7bmfa/+7pa10Z8WDPK3NuJ+NN/RAbQ5vHx2uX0Lm7/w7cAEH/hvZA+mt7J7zGw7YtQYwnNN6dpgwkGjjrS3yQoeoYt1EnczmtmJfQZWzUlP3Hlg9Wzlr9IH23q3thGth+QNEANFettxKfskkGOlLk8AqoKJwDqOxAa6UzAx07plSSyNBJSGco9zjnC5gGbDoKvsMDuBR6bGRlGzJ+hFsGa/Izt78aI+WZ6dJlZKp4pGISuv9rV0sAS0MWEwCmfauO7oQZMiakHU35LBxiyJoOMddhUWgcZuC8r4Ksvn75TTcQXLJ7kWtYhGuGqPd9dZuFjBWQHNwosXY5snbHFQq72CvHXhIg+shQxycuLOuWYErwCLZeF24b7F78pO7xw4X6lIAR02hUOf5087Rl0nOaeb6CK4i/KA/EZv76ftOWZtjwxslNr0E/u8rWUmnf3amfg6UZmBAluuoj3Dd7UV+9IAJ6iYcDfSJlgmIImohjfIUMJ27z+opj50Ak9af2LCNrWrBJvMovA1OeNO+MF/MwZvnaCxTgG7Cw4QfSPF6AYCGFt21M8PySZFeV3t2Rqqs5JMzMYzGRgq4o+UaKRgBf9GHi/9X9HXA3wxkCsd/UhnHSh2zUVDiraio/6nP4y3XJqs8ABfALAtCYU7DHPMPRjgcM6Ad/HiSXDAbOdSMkvGZPAkHs8wuQTy6X2Ov/JFvcPuKfV3/r9Q28\";\nconst FENCED = new Map([\n    [\n        8217,\n        \"apostrophe\"\n    ],\n    [\n        8260,\n        \"fraction slash\"\n    ],\n    [\n        12539,\n        \"middle dot\"\n    ]\n]);\nconst NSM_MAX = 4;\nfunction decode_arithmetic(bytes) {\n    let pos = 0;\n    function u16() {\n        return bytes[pos++] << 8 | bytes[pos++];\n    }\n    // decode the frequency table\n    let symbol_count = u16();\n    let total = 1;\n    let acc = [\n        0,\n        1\n    ]; // first symbol has frequency 1\n    for(let i = 1; i < symbol_count; i++){\n        acc.push(total += u16());\n    }\n    // skip the sized-payload that the last 3 symbols index into\n    let skip = u16();\n    let pos_payload = pos;\n    pos += skip;\n    let read_width = 0;\n    let read_buffer = 0;\n    function read_bit() {\n        if (read_width == 0) {\n            // this will read beyond end of buffer\n            // but (undefined|0) => zero pad\n            read_buffer = read_buffer << 8 | bytes[pos++];\n            read_width = 8;\n        }\n        return read_buffer >> --read_width & 1;\n    }\n    const N = 31;\n    const FULL = 2 ** N;\n    const HALF = FULL >>> 1;\n    const QRTR = HALF >> 1;\n    const MASK = FULL - 1;\n    // fill register\n    let register = 0;\n    for(let i = 0; i < N; i++)register = register << 1 | read_bit();\n    let symbols = [];\n    let low = 0;\n    let range = FULL; // treat like a float\n    while(true){\n        let value = Math.floor(((register - low + 1) * total - 1) / range);\n        let start = 0;\n        let end = symbol_count;\n        while(end - start > 1){\n            let mid = start + end >>> 1;\n            if (value < acc[mid]) {\n                end = mid;\n            } else {\n                start = mid;\n            }\n        }\n        if (start == 0) break; // first symbol is end mark\n        symbols.push(start);\n        let a = low + Math.floor(range * acc[start] / total);\n        let b = low + Math.floor(range * acc[start + 1] / total) - 1;\n        while(((a ^ b) & HALF) == 0){\n            register = register << 1 & MASK | read_bit();\n            a = a << 1 & MASK;\n            b = b << 1 & MASK | 1;\n        }\n        while(a & ~b & QRTR){\n            register = register & HALF | register << 1 & MASK >>> 1 | read_bit();\n            a = a << 1 ^ HALF;\n            b = (b ^ HALF) << 1 | HALF | 1;\n        }\n        low = a;\n        range = 1 + b - a;\n    }\n    let offset = symbol_count - 4;\n    return symbols.map((x)=>{\n        switch(x - offset){\n            case 3:\n                return offset + 0x10100 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n            case 2:\n                return offset + 0x100 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n            case 1:\n                return offset + bytes[pos_payload++];\n            default:\n                return x - 1;\n        }\n    });\n}\n// returns an iterator which returns the next symbol\nfunction read_payload(v) {\n    let pos = 0;\n    return ()=>v[pos++];\n}\nfunction read_compressed_payload(s) {\n    return read_payload(decode_arithmetic(unsafe_atob(s)));\n}\n// unsafe in the sense:\n// expected well-formed Base64 w/o padding \n// 20220922: added for https://github.com/adraffy/ens-normalize.js/issues/4\nfunction unsafe_atob(s) {\n    let lookup = [];\n    [\n        ...\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n    ].forEach((c, i)=>lookup[c.charCodeAt(0)] = i);\n    let n = s.length;\n    let ret = new Uint8Array(6 * n >> 3);\n    for(let i = 0, pos = 0, width = 0, carry = 0; i < n; i++){\n        carry = carry << 6 | lookup[s.charCodeAt(i)];\n        width += 6;\n        if (width >= 8) {\n            ret[pos++] = carry >> (width -= 8);\n        }\n    }\n    return ret;\n}\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\nfunction signed(i) {\n    return i & 1 ? ~i >> 1 : i >> 1;\n}\nfunction read_deltas(n, next) {\n    let v = Array(n);\n    for(let i = 0, x = 0; i < n; i++)v[i] = x += signed(next());\n    return v;\n}\n// [123][5] => [0 3] [1 1] [0 0]\nfunction read_sorted(next, prev = 0) {\n    let ret = [];\n    while(true){\n        let x = next();\n        let n = next();\n        if (!n) break;\n        prev += x;\n        for(let i = 0; i < n; i++){\n            ret.push(prev + i);\n        }\n        prev += n + 1;\n    }\n    return ret;\n}\nfunction read_sorted_arrays(next) {\n    return read_array_while(()=>{\n        let v = read_sorted(next);\n        if (v.length) return v;\n    });\n}\n// returns map of x => ys\nfunction read_mapped(next) {\n    let ret = [];\n    while(true){\n        let w = next();\n        if (w == 0) break;\n        ret.push(read_linear_table(w, next));\n    }\n    while(true){\n        let w = next() - 1;\n        if (w < 0) break;\n        ret.push(read_replacement_table(w, next));\n    }\n    return ret.flat();\n}\n// read until next is falsy\n// return array of read values\nfunction read_array_while(next) {\n    let v = [];\n    while(true){\n        let x = next(v.length);\n        if (!x) break;\n        v.push(x);\n    }\n    return v;\n}\n// read w columns of length n\n// return as n rows of length w\nfunction read_transposed(n, w, next) {\n    let m = Array(n).fill().map(()=>[]);\n    for(let i = 0; i < w; i++){\n        read_deltas(n, next).forEach((x, j)=>m[j].push(x));\n    }\n    return m;\n}\n// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]\n// where dx/dy = steps, n = run size, w = length of y\nfunction read_linear_table(w, next) {\n    let dx = 1 + next();\n    let dy = next();\n    let vN = read_array_while(next);\n    let m = read_transposed(vN.length, 1 + w, next);\n    return m.flatMap((v, i)=>{\n        let [x, ...ys] = v;\n        return Array(vN[i]).fill().map((_, j)=>{\n            let j_dy = j * dy;\n            return [\n                x + j * dx,\n                ys.map((y)=>y + j_dy)\n            ];\n        });\n    });\n}\n// return [[x, ys...], ...]\n// where w = length of y\nfunction read_replacement_table(w, next) {\n    let n = 1 + next();\n    let m = read_transposed(n, 1 + w, next);\n    return m.map((v)=>[\n            v[0],\n            v.slice(1)\n        ]);\n}\nfunction read_trie(next) {\n    let ret = [];\n    let sorted = read_sorted(next);\n    expand(decode([]), []);\n    return ret; // not sorted\n    function decode(Q) {\n        let S = next(); // state: valid, save, check\n        let B = read_array_while(()=>{\n            let cps = read_sorted(next).map((i)=>sorted[i]);\n            if (cps.length) return decode(cps);\n        });\n        return {\n            S,\n            B,\n            Q\n        };\n    }\n    function expand({ S, B }, cps, saved) {\n        if (S & 4 && saved === cps[cps.length - 1]) return;\n        if (S & 2) saved = cps[cps.length - 1];\n        if (S & 1) ret.push(cps);\n        for (let br of B){\n            for (let cp of br.Q){\n                expand(br, [\n                    ...cps,\n                    cp\n                ], saved);\n            }\n        }\n    }\n}\nfunction hex_cp(cp) {\n    return cp.toString(16).toUpperCase().padStart(2, \"0\");\n}\nfunction quote_cp(cp) {\n    return `{${hex_cp(cp)}}`; // raffy convention: like \"\\u{X}\" w/o the \"\\u\"\n}\n/*\r\nexport function explode_cp(s) {\r\n\treturn [...s].map(c => c.codePointAt(0));\r\n}\r\n*/ function explode_cp(s) {\n    let cps = [];\n    for(let pos = 0, len = s.length; pos < len;){\n        let cp = s.codePointAt(pos);\n        pos += cp < 0x10000 ? 1 : 2;\n        cps.push(cp);\n    }\n    return cps;\n}\nfunction str_from_cps(cps) {\n    const chunk = 4096;\n    let len = cps.length;\n    if (len < chunk) return String.fromCodePoint(...cps);\n    let buf = [];\n    for(let i = 0; i < len;){\n        buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));\n    }\n    return buf.join(\"\");\n}\nfunction compare_arrays(a, b) {\n    let n = a.length;\n    let c = n - b.length;\n    for(let i = 0; c == 0 && i < n; i++)c = a[i] - b[i];\n    return c;\n}\nfunction array_replace(v, a, b) {\n    let prev = 0;\n    while(true){\n        let next = v.indexOf(a, prev);\n        if (next < 0) break;\n        v[next] = b;\n        prev = next + 1;\n    }\n}\n// created 2024-09-13T06:42:45.675Z\n// compressed base64-encoded blob for include-nf data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: a79d5f9b1879a7b416aa659f4a3d788f80a8cf5f0ab955a456592c02f556a28c\nvar COMPRESSED = \"AEUDVgHLCGMATwDUADIAdAAhADQAFAAtABQAIQAPACcADQASAAoAGAAJABIACQARAAUACwAFAAwABQAQAAMABwAEAAoABQAJAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACwANAA0AAwAKAAkABAAdAAYAZwDTAeYDMwCxCl8B8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgPi89uj00MsvBXxEPAGPCDwBnQKoEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiC+AZ4EWRJJFbEu7QDQLARtEbgECxDwAb/RyAk1AV4nD2cEQQKTAzsAGpobWgAahAGPCrysdy0OAKwAfFIcBAQFUmoA/PtZADkBIadVj2UMUgx5Il4ANQC9vAITAdQZWxDzALN9AhsZVwIcGSkCBAgXOhG7AqMZ4M7+1M0UAPDNAWsC+mcJDe8AAQA99zkEXLICyQozAo6lAobcP5JvjQLFzwKD9gU/OD8FEQCtEQL6bW+nAKUEvzjDHsuRyUvOFHcacUz5AqIFRSE2kzsBEQCuaQL5DQTlcgO6twSpTiUgCwIFCAUXBHQEqQV6swAVxUlmTmsCwjqsP/wKJQmXb793UgZBEBsnpRD3DDMBtQE7De1L2ATxBjsEyR99GRkPzZWcCKUt3QztJuMuoYBaI/UqgwXtS/Q83QtNUWgPWQtlCeM6Y4FOAyEBDSKLCt0NOQhtEPMKyWsN5RFFBzkD1UmaAKUHAQsRHTUVtSYQYqwLCTl3Bvsa9guPJq8TKXr8BdMaIQZNASka/wDPLueFsFoxXBxPXwYDCyUjxxSoUCANJUC3eEgaGwcVJakCkUNwSodRNh6TIfY8PQ1mLhNRfAf1PAUZTwuBPJ5Gq0UOEdI+jT1IIklMLAQ1fywvJ4sJzw+FDLl8cgFZCSEJsQxxEzERFzfFCDkHGS2XJCcVCCFGlWCaBPefA/MT0QMLBT8JQQcTA7UcLRMuFSkFDYEk1wLzNtUuswKPVoABFwXLDyUf3xBQR+AO6QibAmUDgyXrAC0VIQAXIpsIQ2MAX4/YUwUuywjHamwjdANnFOdhEXMHkQ5XB6ccMxW/HOFwyF4Lhggoo68JWwF1CZkBXwTjCAk1W4ygIEFnU4tYGJsgYUE/XfwCMQxlFZ9EvYd4AosPaxIbATUBcwc5DQECdxHtEWsQlQjrhgQ1tTP4OiUETyGDIBEKJwNPbM4LJyb5DPhpAaMSYgMMND137merYLYkF/0HGTLFQWAh8QuST80MnBrBGEJULhnkB78D8xrzJ+pBVwX/A6MDEzpNM+4EvQtpCIsJPwBJDqMXB9cYagpxjNABMYsBt5kDV5GDAm+PBjcHCwBnC4cFeeUAHQKnCKMABQDPA1cAOQKtB50AGQCFQQE9AycvASHlAo8DkwgxywGVLwHzKQQbwwwVAPc3bkoCw7ECgGpmogXdWAKOAkk1AU0lBAVOR1EDr3HhANsASwYT30cBFatKyxrjQwHfbysAxwD7AAU1BwVBAc0B820AtwFfCzEJorO1AU3pKQCDABVrAdcCiQDdADUAf/EBUwBNBVn5BdMCT0kBETEYK1dhAbsDHwEzAQ0AeQbLjaXJBx8EbQfTAhAbFeEC7y4HtQEDIt8TzULFAr3eVaFgAmSBAmJCW02vWzcgAqH3AmiYAmYJAp+EOBsLAmY7AmYmBG4EfwN/EwN+kjkGOXcXOYI6IyMCbB0CMjY4CgJtxwJtru+KM2dFKwFnAN4A4QBKBQeYDI0A/gvCAA21AncvAnaiPwJ5S0MCeLodXNtFrkbXAnw/AnrIAn0JAnzwBVkFIEgASH1jJAKBbQKAAAKABQJ/rklYSlsVF0rMAtEBAtDMSycDiE8Dh+ZExZEyAvKhXQMDA65LzkwtJQPPTUxNrwKLPwKK2MEbBx1DZwW3Ao43Ao5cQJeBAo7ZAo5ceFG0UzUKUtRUhQKT+wKTDADpABxVHlWvVdAGLBsplYYy4XhmRTs5ApefAu+yWCGoAFklApaPApZ8nACpWaxaCYFNADsClrUClk5cRFzRApnLAplkXMpdBxkCnJs5wjqdApwWAp+bAp64igAdDzEqDwKd8QKekgC1PWE0Ye8CntMCoG4BqQKenx8Cnk6lY8hkJyUrAievAiZ+AqD7AqBMAqLdAqHEAqYvAqXOAqf/AH0Cp/JofGixAANJahxq0QKs4wKsrgKtZwKtAgJXHQJV3AKx4dcDH05slwKyvQ0CsugXbOBtY21IXwMlzQK2XDs/bpADKUUCuF4CuUcVArkqd3A2cOECvRkCu9pwlgMyEQK+iHICAzNxAr4acyJzTwLDywLDBHOCdEs1RXTgAzynAzyaAz2/AsV8AsZHAsYQiQLIaVECyEQCyU8CyS4CZJ0C3dJ4eWF4rnklS9ADGKNnAgJh9BnzlSR7C16SXrsRAs9rAs9sL0tT0vMTnwDGrQLPcwEp6gNOEn5LBQLcJwLbigLSTwNSXANTXwEBA1WMgIk/AMsW7WBFghyC04LOg40C2scC2d6EEIRJpzwDhqUALwNkDoZxWfkAVQLfZQLeuHN3AuIv7RQB8zAnAfSbAfLShwLr8wLpcHkC6vkC6uQA+UcBuQLuiQLrnJaqlwMC7j8DheCYeXDgcaEC8wMAaQOOFpmTAvcTA5FuA5KHAveYAvnZAvhmmhyaq7s3mx4DnYMC/voBGwA5nxyfswMFjQOmagOm2QDRxQMGaqGIogUJAwxJAtQAPwMA4UEXUwER8wNrB5dnBQCTLSu3r73bAYmZFH8RBDkB+ykFIQ6dCZ8Akv0TtRQrxQL3LScApQC3BbmOkRc/xqdtQS4UJo0uAUMBgPwBtSYAdQMOBG0ALAIWDKEAAAoCPQJqA90DfgSRASBFBSF8CgAFAEQAEwA2EgJ3AQAF1QNr7wrFAgD3Cp8nv7G35QGRIUFCAekUfxE0wIkABAAbAFoCRQKEiwAGOlM6lI1tALg6jzrQAI04wTrcAKUA6ADLATqBOjs5/Dn5O3aJOls7nok6bzkYAVYBMwFsBS81XTWeNa01ZjV1NbY1xTWCNZE10jXhNZ41rTXuNf01sjXBNgI2ETXGNdU2FjYnNd417TYuNj02LjUtITY6Nj02PDbJNwgEkDxXNjg23TcgNw82yiA3iTcwCgSwPGc2JDcZN2w6jTchQtRDB0LgQwscDw8JmyhtKFFVBgDpfwDpsAD+mxQ91wLpNSMArQC9BbeOkRdLxptzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgELgEaJZkC7aMAoQCjBcGOmxdNxrsBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUHqSvAj5Gqwr7YrMUACT9AN3rlr3JG9m8w9lIAXltp/v8kfWaIaaR9OwpAES/I3ZVamDXSgB/UsOgAG6D0tq+5CIqE15FiAhV3yA2VhCQ7tj+m6xXaF53FIfGi/IAZIskMGAi2MU7MDVJNCbMzERyHZi+osdPtnFVbvq653O8rwaCy4IAf9OOok65AqJUtUriUfYsGPPVbe6jm0s9lbKlPCUKjdkHsFsEhvX4kT39ZCtAAbwQdn/h4TpO5hTByWAmr5n+Wuwhdegv6bmvX4LyOes3z2+cuHv2JFYwVMNuq2gzn8YHTjlUQd39osyWei4NKl3LAdfxlO876hh5ENp/cOvpuI9bF55guEthLLPOXjD4dktTH04P5TvZrWTM0e4+BHJxj7MLApXIFOs0sWKhNkG8iwuM5wR83my6V3wW06abhDzTXYfOr/ZpFXgXzmv4d12FFyP00/dPGbIVGV5ao8UufGzUwp/IHx6v/wDWJr9iaoCulhWwlZ7A8q/NMoD12+mBdNRgJYnThRLtMx1Bgwttn8/4Qn2CDfOSup9GVXEvA21ILgp0owHYxNOkpwLWz0G7K+WREIDjIzUzSn8I99CuJSmSpPyH0Ke6/NERYiNx+3dncSebPnOUnnWD61AhJ1n/tSLZmU5wYO5GfgzyAYJm6VL91LxZ8hL1lfximQxIDMRhIecQZBmeE5R0XlrpvwplVrJwpa8BBCdp93GPP9lyBeZ2zkRr920CR3cYbKpKHfogvm0nV7XdDz6EbjzlxADCMjSLXuXpIpyuizy39yY+I+H9rmpoIF3YwEjlH9MgGgWcCNTjHEWMqAbprn2Ox7rOHupaVE3lNyg3nt5XaZID6Y+uml5Ja+aOPu+BI+DZbiJVfaspUadakWUX6TA4dETkIqdJJHYnU4Z4yKpt5y8rVIahoMUf8A8kWtAQNCTbjp71gx3/zVdqNz1Sutkw0gFIMVm2BF4Xdv/0olw+NaDIR9Bb3DPweZA2K/cw+/b+AwyWl9ZOP67A9nexmeTNjfdzPGf9J6E6BMPKa5lJh+qNsdUz3HBUevU71eQFCqOcxiIYhacAhh/8PX0J5DdSViZ6WazDDx7cukJNpMfEkYLJ5Ao4vLoVd3d25Pg4qaVa2p2D2L3WvYPJ5Yf/A/MSxptjlgXL/KJtP2U0cRv2I09ATAiWCJYuRwiapeKFsqmi18yMMulDp3HdcIldq+7jkwsJUOHLHCzzzBw5XFvL0CAmo1ub456z7zb7shk3KPGCLZzr47oT1k/j06XNnJvG3Udv6XrP+wsqTBlZ5MaNPt9FOs/4Bt/ja/vbVhTNpBFl9Gq7MqINvGlWKOAwQzwOZy+EzSdjAqKJVV2YcskTuM94aIK+kc/AZaXiZLPREUDpkXIV947IFfj+85TrqPqLfkGcxgboMQjosf+az+odLNXdyp1mDNGsqSdK/pJ2Ca04mt/4d6s1X+lncOEYaGBBeW4pApGcjf7/XJCFbj3N3mFb+BtlIcw8ZiDKoClFX9Rf0bxCqtLpicObKJzBVVHr/6u4siH2hK75RNv7w9GfTbhJOQBYiFUZAByY4rn37tZBHT//kqKsNi3ryL9AqXJRzqiMIJMhILjoi/i8LVEsbu+Ih9bsyW16sgQqjYLO0qda6KaCPKj3DQcu6CfV5lKtjS3ZCdqLAZkOey9MR+QutJBGiz/r15GVD6rCVwJR4UUKC4GNJkfDf00OMW8aQtLSAGLXV8MIi9mbbl/qQEpxCm2L5hutFX4ekeLH4QgBWUFKs/2VVMKy46WtFE6AbwgmYm/Z0yHk5veDIrcl2HpVqb/rSE0PC9EbDzJEWqeaPhh7vF369Umq2kSiB3s5rBI6c/7N9bkRu4h2n+/h5nSwy+7n+/I+6oXQVANo2Jb5zDwtiBPf1ySCzHdT6yJShMzqSRZfnykX49CaFaxhoVF4PBhEuECJ1PrFYSpmHuyYsl14DTAV9ZxRms1XiR/kBrjhZjidOt0UNe+GSml7XNgpVw8YsUTmZXLTK+6iYnyW/wYR1W4UXwOi14xpFROHb6HcZzksgF5DbL2AFXzKNwHU2adjdAY+KCyM/cwRTBkkq/a227NI0q6DR2MkMCRu620t79bGcYUmACtqN3mk/0uNwd3JSXHqE1kzf6Yyj0W2083JNDRnIXDlgBxJ6uf58NN1f6FQiRCWB4egF8QDx74AixV8oTyw7PluIjr3/rj/WzgwPSq4xPojaF7V0xqG2u5ti2L1h6yYHv73Isrukr0kURDIEjClBsBx7kdcXUxaYMS0syT3ymLzDzslNDWQOT1Tao1YNmJHARUenhCkmV9tqCPGI5GqZaRpkiPxyjoncWjyOHYGqvbvRX+Bn1pn7EhRNXa1lqJPmoeN5VqdqIDPhEVhFsyG0d4iQEIYX0wZUbY2XbZWYlpZ/l66IrDDY0q1C1YzBDpHC4h05YqHQLqS9anyl22JQ6lEvjvdBwMHfE7z0luCXD34/rFeDa2TmSeEAykSpYO5j1G/nsgpR3qn0qaQEmLjnnLfcz+veoYqPnRqmRGwCJ6FJ3Gm/Z1/aVX5PSb03MMnjAf41ww54sD5k8FrkfBP+K0b1MrYpapWjtpZfve2HVf4ickX3LKSOhu7qI1Vd4c1kNrn2ajy1t4y93JhV4fnWCKq7OmFpcr7FjdJCXPTql0Drr14Ho3Z87+GPQ4Z/DcTiGqtvZxlRYi8cNuhXABveZIwNl/BX1huhVLaFax5OqypUrQRyb9OE3SSkPlDdy5uo5XGg2EIGEjLY1MO5cr1ibfiFWV7zspcTgkBKkwo5jPyAin04LqizZXb2tDRgwKJjGx4cVk3ngAQixwcxjYAg2Q7vmUR/hpwInMdw7OhC2qyf41vTPkudQAORS0DdLtOGQxb4fH2VYGsvJCkeWPeUwtf1/tuIhzXEThoCZzzSJqqjUtbaPI3ntHm3T5uf849hGUA0zU8ni5W+EEn3/0Y6oUhQFw9z0aGjkljBbAlFXc0y82G2wkd7VdgWa5KTgJJNjNwZMfmdnUIUn1JU5LiWX5UZEZbVlKSN76mlmjUR2ku+fucTNlO4IAAahnLjBhlvQNR9pe9swGBgq0YR7P3VCyI/seYwQ4QBzy9X+HPePgoF8WfKaJ4MBOhLCGHae6Z8xkNXwni9QAKvTNtVA56x8YJflZ/VvONRSlsSLmiSyNMnTjTaE1ko81zkzGEnVwEhjCzlwIqpxmpDAqwsEmtpdr3xpc7i/ZX3f2TzT3M0FdxIEQvO1jgmmiN+D1YpMduAzEhBtj2OBkMN/rv6p7Th4pSH6f5aH3aTvwFTl7EOSgGASI7ttyMehzpm4AVyK+bFEaFg9gnZsSUPpsbAe/0RFhrH+EXZ12Z7thf4dzN1+Sn+G8QrDA1VKaN4IFxD1rQz9Xq9Coii9S9/hPbTGjyBwFH3H1UdQuz5KsgPDEHua4/kPg2Gp/IIItsaLWBqiT9XH45MiQxSosGJ56H/0F2cjcCFd72l1665RNHURdC3lspI77esfJsl+rXXabkAy7vxDXG/XGGcKpwiKDPFfvMEgjkAHil4Za1F36RnyxxvdIAzvgfH8knukYDck07tc++DP4TdWeI7HXuq5Yl6VVFrUQtf64/dkXewlKZSHQo6YvCSpREB0GDrz+Ys2GfO8nw2SwrYwaf88AifzlPvP17bf1mI3AuccJvAjZIpBmqvharKFAebEjVKfGAwpQjWoXlm9LROsq9bCk1UeQ3CJxJqprzssS/Q04JeS1ReCCubL3J7sx86spkP4eNpp95UF+8K748icIs8vdILFklk9skQqi1So6cx3X906pvy1vz+KipTJ8fiVJxsV5MmT0XwA\";\n// https://unicode.org/reports/tr15/\n// for reference implementation\n// see: /derive/nf.js\n// algorithmic hangul\n// https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)\nconst S0 = 0xAC00;\nconst L0 = 0x1100;\nconst V0 = 0x1161;\nconst T0 = 0x11A7;\nconst L_COUNT = 19;\nconst V_COUNT = 21;\nconst T_COUNT = 28;\nconst N_COUNT = V_COUNT * T_COUNT;\nconst S_COUNT = L_COUNT * N_COUNT;\nconst S1 = S0 + S_COUNT;\nconst L1 = L0 + L_COUNT;\nconst V1 = V0 + V_COUNT;\nconst T1 = T0 + T_COUNT;\nfunction unpack_cc(packed) {\n    return packed >> 24 & 0xFF;\n}\nfunction unpack_cp(packed) {\n    return packed & 0xFFFFFF;\n}\nlet SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;\n// export function nf_deinit() {\n// \tif (!SHIFTED_RANK) return;\n// \tSHIFTED_RANK = EXCLUSIONS = DECOMP = RECOMP = undefined;\n// }\nfunction init$1() {\n    //console.time('nf');\n    let r = read_compressed_payload(COMPRESSED);\n    SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i)=>v.map((x)=>[\n                x,\n                i + 1 << 24\n            ]))); // pre-shifted\n    EXCLUSIONS = new Set(read_sorted(r));\n    DECOMP = new Map();\n    RECOMP = new Map();\n    for (let [cp, cps] of read_mapped(r)){\n        if (!EXCLUSIONS.has(cp) && cps.length == 2) {\n            let [a, b] = cps;\n            let bucket = RECOMP.get(a);\n            if (!bucket) {\n                bucket = new Map();\n                RECOMP.set(a, bucket);\n            }\n            bucket.set(b, cp);\n        }\n        DECOMP.set(cp, cps.reverse()); // stored reversed\n    }\n//console.timeEnd('nf');\n// 20230905: 11ms\n}\nfunction is_hangul(cp) {\n    return cp >= S0 && cp < S1;\n}\nfunction compose_pair(a, b) {\n    if (a >= L0 && a < L1 && b >= V0 && b < V1) {\n        return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;\n    } else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {\n        return a + (b - T0);\n    } else {\n        let recomp = RECOMP.get(a);\n        if (recomp) {\n            recomp = recomp.get(b);\n            if (recomp) {\n                return recomp;\n            }\n        }\n        return -1;\n    }\n}\nfunction decomposed(cps) {\n    if (!SHIFTED_RANK) init$1();\n    let ret = [];\n    let buf = [];\n    let check_order = false;\n    function add(cp) {\n        let cc = SHIFTED_RANK.get(cp);\n        if (cc) {\n            check_order = true;\n            cp |= cc;\n        }\n        ret.push(cp);\n    }\n    for (let cp of cps){\n        while(true){\n            if (cp < 0x80) {\n                ret.push(cp);\n            } else if (is_hangul(cp)) {\n                let s_index = cp - S0;\n                let l_index = s_index / N_COUNT | 0;\n                let v_index = s_index % N_COUNT / T_COUNT | 0;\n                let t_index = s_index % T_COUNT;\n                add(L0 + l_index);\n                add(V0 + v_index);\n                if (t_index > 0) add(T0 + t_index);\n            } else {\n                let mapped = DECOMP.get(cp);\n                if (mapped) {\n                    buf.push(...mapped);\n                } else {\n                    add(cp);\n                }\n            }\n            if (!buf.length) break;\n            cp = buf.pop();\n        }\n    }\n    if (check_order && ret.length > 1) {\n        let prev_cc = unpack_cc(ret[0]);\n        for(let i = 1; i < ret.length; i++){\n            let cc = unpack_cc(ret[i]);\n            if (cc == 0 || prev_cc <= cc) {\n                prev_cc = cc;\n                continue;\n            }\n            let j = i - 1;\n            while(true){\n                let tmp = ret[j + 1];\n                ret[j + 1] = ret[j];\n                ret[j] = tmp;\n                if (!j) break;\n                prev_cc = unpack_cc(ret[--j]);\n                if (prev_cc <= cc) break;\n            }\n            prev_cc = unpack_cc(ret[i]);\n        }\n    }\n    return ret;\n}\nfunction composed_from_decomposed(v) {\n    let ret = [];\n    let stack = [];\n    let prev_cp = -1;\n    let prev_cc = 0;\n    for (let packed of v){\n        let cc = unpack_cc(packed);\n        let cp = unpack_cp(packed);\n        if (prev_cp == -1) {\n            if (cc == 0) {\n                prev_cp = cp;\n            } else {\n                ret.push(cp);\n            }\n        } else if (prev_cc > 0 && prev_cc >= cc) {\n            if (cc == 0) {\n                ret.push(prev_cp, ...stack);\n                stack.length = 0;\n                prev_cp = cp;\n            } else {\n                stack.push(cp);\n            }\n            prev_cc = cc;\n        } else {\n            let composed = compose_pair(prev_cp, cp);\n            if (composed >= 0) {\n                prev_cp = composed;\n            } else if (prev_cc == 0 && cc == 0) {\n                ret.push(prev_cp);\n                prev_cp = cp;\n            } else {\n                stack.push(cp);\n                prev_cc = cc;\n            }\n        }\n    }\n    if (prev_cp >= 0) {\n        ret.push(prev_cp, ...stack);\n    }\n    return ret;\n}\n// note: cps can be iterable\nfunction nfd(cps) {\n    return decomposed(cps).map(unpack_cp);\n}\nfunction nfc(cps) {\n    return composed_from_decomposed(decomposed(cps));\n}\nconst HYPHEN = 0x2D;\nconst STOP = 0x2E;\nconst STOP_CH = \".\";\nconst FE0F = 0xFE0F;\nconst UNIQUE_PH = 1;\n// 20230913: replace [...v] with Array_from(v) to avoid large spreads\nconst Array_from = (x)=>Array.from(x); // Array.from.bind(Array);\nfunction group_has_cp(g, cp) {\n    // 20230913: keep primary and secondary distinct instead of creating valid union\n    return g.P.has(cp) || g.Q.has(cp);\n}\nclass Emoji extends Array {\n    get is_emoji() {\n        return true;\n    }\n}\nlet MAPPED, IGNORED, CM, NSM, ESCAPE, NFC_CHECK, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;\n// export function ens_deinit() {\n// \tnf_deinit();\n// \tif (!MAPPED) return;\n// \tMAPPED = IGNORED = CM = NSM = ESCAPE = NFC_CHECK = GROUPS = WHOLE_VALID = WHOLE_MAP = VALID = EMOJI_LIST = EMOJI_ROOT = undefined;\n// }\nfunction init() {\n    if (MAPPED) return;\n    let r = read_compressed_payload(COMPRESSED$1);\n    const read_sorted_array = ()=>read_sorted(r);\n    const read_sorted_set = ()=>new Set(read_sorted_array());\n    const set_add_many = (set, v)=>v.forEach((x)=>set.add(x));\n    MAPPED = new Map(read_mapped(r));\n    IGNORED = read_sorted_set(); // ignored characters are not valid, so just read raw codepoints\n    /*\r\n\t// direct include from payload is smaller than the decompression code\r\n\tconst FENCED = new Map(read_array_while(() => {\r\n\t\tlet cp = r();\r\n\t\tif (cp) return [cp, read_str(r())];\r\n\t}));\r\n\t*/ // 20230217: we still need all CM for proper error formatting\n    // but norm only needs NSM subset that are potentially-valid\n    CM = read_sorted_array();\n    NSM = new Set(read_sorted_array().map((i)=>CM[i]));\n    CM = new Set(CM);\n    ESCAPE = read_sorted_set(); // characters that should not be printed\n    NFC_CHECK = read_sorted_set(); // only needed to illustrate ens_tokenize() transformations\n    let chunks = read_sorted_arrays(r);\n    let unrestricted = r();\n    //const read_chunked = () => new Set(read_sorted_array().flatMap(i => chunks[i]).concat(read_sorted_array()));\n    const read_chunked = ()=>{\n        // 20230921: build set in parts, 2x faster\n        let set = new Set();\n        read_sorted_array().forEach((i)=>set_add_many(set, chunks[i]));\n        set_add_many(set, read_sorted_array());\n        return set;\n    };\n    GROUPS = read_array_while((i)=>{\n        // minifier property mangling seems unsafe\n        // so these are manually renamed to single chars\n        let N = read_array_while(r).map((x)=>x + 0x60);\n        if (N.length) {\n            let R = i >= unrestricted; // unrestricted then restricted\n            N[0] -= 32; // capitalize\n            N = str_from_cps(N);\n            if (R) N = `Restricted[${N}]`;\n            let P = read_chunked(); // primary\n            let Q = read_chunked(); // secondary\n            let M = !r(); // not-whitelisted, check for NSM\n            // *** this code currently isn't needed ***\n            /*\r\n\t\t\tlet V = [...P, ...Q].sort((a, b) => a-b); // derive: sorted valid\r\n\t\t\tlet M = r()-1; // number of combining mark\r\n\t\t\tif (M < 0) { // whitelisted\r\n\t\t\t\tM = new Map(read_array_while(() => {\r\n\t\t\t\t\tlet i = r();\r\n\t\t\t\t\tif (i) return [V[i-1], read_array_while(() => {\r\n\t\t\t\t\t\tlet v = read_array_while(r);\r\n\t\t\t\t\t\tif (v.length) return v.map(x => x-1);\r\n\t\t\t\t\t})];\r\n\t\t\t\t}));\r\n\t\t\t}*/ return {\n                N,\n                P,\n                Q,\n                M,\n                R\n            };\n        }\n    });\n    // decode compressed wholes\n    WHOLE_VALID = read_sorted_set();\n    WHOLE_MAP = new Map();\n    let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b)=>a - b); // must be sorted\n    wholes.forEach((cp, i)=>{\n        let d = r();\n        let w = wholes[i] = d ? wholes[i - d] : {\n            V: [],\n            M: new Map()\n        };\n        w.V.push(cp); // add to member set\n        if (!WHOLE_VALID.has(cp)) {\n            WHOLE_MAP.set(cp, w); // register with whole map\n        }\n    });\n    // compute confusable-extent complements\n    // usage: WHOLE_MAP.get(cp).M.get(cp) = complement set\n    for (let { V, M } of new Set(WHOLE_MAP.values())){\n        // connect all groups that have each whole character\n        let recs = [];\n        for (let cp of V){\n            let gs = GROUPS.filter((g)=>group_has_cp(g, cp));\n            let rec = recs.find(({ G })=>gs.some((g)=>G.has(g)));\n            if (!rec) {\n                rec = {\n                    G: new Set(),\n                    V: []\n                };\n                recs.push(rec);\n            }\n            rec.V.push(cp);\n            set_add_many(rec.G, gs);\n        }\n        // per character cache groups which are not a member of the extent\n        let union = recs.flatMap((x)=>Array_from(x.G)); // all of the groups used by this whole\n        for (let { G, V } of recs){\n            let complement = new Set(union.filter((g)=>!G.has(g))); // groups not covered by the extent\n            for (let cp of V){\n                M.set(cp, complement); // this is the same reference\n            }\n        }\n    }\n    // compute valid set\n    // 20230924: VALID was union but can be re-used\n    VALID = new Set(); // exists in 1+ groups\n    let multi = new Set(); // exists in 2+ groups\n    const add_to_union = (cp)=>VALID.has(cp) ? multi.add(cp) : VALID.add(cp);\n    for (let g of GROUPS){\n        for (let cp of g.P)add_to_union(cp);\n        for (let cp of g.Q)add_to_union(cp);\n    }\n    // dual purpose WHOLE_MAP: return placeholder if unique non-confusable\n    for (let cp of VALID){\n        if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {\n            WHOLE_MAP.set(cp, UNIQUE_PH);\n        }\n    }\n    // add all decomposed parts\n    // see derive: \"Valid is Closed (via Brute-force)\"\n    set_add_many(VALID, nfd(VALID));\n    // decode emoji\n    // 20230719: emoji are now fully-expanded to avoid quirk logic \n    EMOJI_LIST = read_trie(r).map((v)=>Emoji.from(v)).sort(compare_arrays);\n    EMOJI_ROOT = new Map(); // this has approx 7K nodes (2+ per emoji)\n    for (let cps of EMOJI_LIST){\n        // 20230719: change to *slightly* stricter algorithm which disallows \n        // insertion of misplaced FE0F in emoji sequences (matching ENSIP-15)\n        // example: beautified [A B] (eg. flag emoji) \n        //  before: allow: [A FE0F B], error: [A FE0F FE0F B] \n        //   after: error: both\n        // note: this code now matches ENSNormalize.{cs,java} logic\n        let prev = [\n            EMOJI_ROOT\n        ];\n        for (let cp of cps){\n            let next = prev.map((node)=>{\n                let child = node.get(cp);\n                if (!child) {\n                    // should this be object? \n                    // (most have 1-2 items, few have many)\n                    // 20230719: no, v8 default map is 4?\n                    child = new Map();\n                    node.set(cp, child);\n                }\n                return child;\n            });\n            if (cp === FE0F) {\n                prev.push(...next); // less than 20 elements\n            } else {\n                prev = next;\n            }\n        }\n        for (let x of prev){\n            x.V = cps;\n        }\n    }\n}\n// if escaped: {HEX}\n//       else: \"x\" {HEX}\nfunction quoted_cp(cp) {\n    return (should_escape(cp) ? \"\" : `${bidi_qq(safe_str_from_cps([\n        cp\n    ]))} `) + quote_cp(cp);\n}\n// 20230211: some messages can be mixed-directional and result in spillover\n// use 200E after a quoted string to force the remainder of a string from \n// acquring the direction of the quote\n// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions\nfunction bidi_qq(s) {\n    return `\"${s}\"\\u200E`; // strong LTR\n}\nfunction check_label_extension(cps) {\n    if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\n        throw new Error(`invalid label extension: \"${str_from_cps(cps.slice(0, 4))}\"`); // this can only be ascii so cant be bidi\n    }\n}\nfunction check_leading_underscore(cps) {\n    const UNDERSCORE = 0x5F;\n    for(let i = cps.lastIndexOf(UNDERSCORE); i > 0;){\n        if (cps[--i] !== UNDERSCORE) {\n            throw new Error(\"underscore allowed only at start\");\n        }\n    }\n}\n// check that a fenced cp is not leading, trailing, or touching another fenced cp\nfunction check_fenced(cps) {\n    let cp = cps[0];\n    let prev = FENCED.get(cp);\n    if (prev) throw error_placement(`leading ${prev}`);\n    let n = cps.length;\n    let last = -1; // prevents trailing from throwing\n    for(let i = 1; i < n; i++){\n        cp = cps[i];\n        let match = FENCED.get(cp);\n        if (match) {\n            // since cps[0] isn't fenced, cps[1] cannot throw\n            if (last == i) throw error_placement(`${prev} + ${match}`);\n            last = i + 1;\n            prev = match;\n        }\n    }\n    if (last == n) throw error_placement(`trailing ${prev}`);\n}\n// create a safe to print string \n// invisibles are escaped\n// leading cm uses placeholder\n// if cps exceed max, middle truncate with ellipsis\n// quoter(cp) => string, eg. 3000 => \"{3000}\"\n// note: in html, you'd call this function then replace [<>&] with entities\nfunction safe_str_from_cps(cps, max = Infinity, quoter = quote_cp) {\n    //if (Number.isInteger(cps)) cps = [cps];\n    //if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);\n    let buf = [];\n    if (is_combining_mark(cps[0])) buf.push(\"\");\n    if (cps.length > max) {\n        max >>= 1;\n        cps = [\n            ...cps.slice(0, max),\n            0x2026,\n            ...cps.slice(-max)\n        ];\n    }\n    let prev = 0;\n    let n = cps.length;\n    for(let i = 0; i < n; i++){\n        let cp = cps[i];\n        if (should_escape(cp)) {\n            buf.push(str_from_cps(cps.slice(prev, i)));\n            buf.push(quoter(cp));\n            prev = i + 1;\n        }\n    }\n    buf.push(str_from_cps(cps.slice(prev, n)));\n    return buf.join(\"\");\n}\n// note: set(s) cannot be exposed because they can be modified\n// note: Object.freeze() doesn't work\nfunction is_combining_mark(cp, only_nsm) {\n    init();\n    return only_nsm ? NSM.has(cp) : CM.has(cp);\n}\nfunction should_escape(cp) {\n    init();\n    return ESCAPE.has(cp);\n}\n// return all supported emoji as fully-qualified emoji \n// ordered by length then lexicographic \nfunction ens_emoji() {\n    init();\n    return EMOJI_LIST.map((x)=>x.slice()); // emoji are exposed so copy\n}\nfunction ens_normalize_fragment(frag, decompose) {\n    init();\n    let nf = decompose ? nfd : nfc;\n    return frag.split(STOP_CH).map((label)=>str_from_cps(tokens_from_str(explode_cp(label), nf, filter_fe0f).flat())).join(STOP_CH);\n}\nfunction ens_normalize(name) {\n    return flatten(split(name, nfc, filter_fe0f));\n}\nfunction ens_beautify(name) {\n    let labels = split(name, nfc, (x)=>x); // emoji not exposed\n    for (let { type, output, error } of labels){\n        if (error) break; // flatten will throw\n        // replace leading/trailing hyphen\n        // 20230121: consider beautifing all or leading/trailing hyphen to unicode variant\n        // not exactly the same in every font, but very similar: \"-\" vs \"\"\n        /*\r\n\t\tconst UNICODE_HYPHEN = 0x2010;\r\n\t\t// maybe this should replace all for visual consistancy?\r\n\t\t// `node tools/reg-count.js regex ^-\\{2,\\}` => 592\r\n\t\t//for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;\r\n\t\tif (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;\r\n\t\tlet end = output.length-1;\r\n\t\tif (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;\r\n\t\t*/ // 20230123: WHATWG URL uses \"CheckHyphens\" false\n        // https://url.spec.whatwg.org/#idna\n        // update ethereum symbol\n        //  =>  if not greek\n        if (type !== \"Greek\") array_replace(output, 0x3BE, 0x39E);\n    // 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)\n    // could be fixed with special case for: 2D (.) + 200E (LTR)\n    // https://discuss.ens.domains/t/bidi-label-ordering-spoof/15824\n    //output.splice(0, 0, 0x200E);\n    }\n    return flatten(labels);\n}\nfunction ens_split(name, preserve_emoji) {\n    return split(name, nfc, preserve_emoji ? (x)=>x.slice() : filter_fe0f); // emoji are exposed so copy\n}\nfunction split(name, nf, ef) {\n    if (!name) return []; // 20230719: empty name allowance\n    init();\n    let offset = 0;\n    // https://unicode.org/reports/tr46/#Validity_Criteria\n    // 4.) \"The label must not contain a U+002E ( . ) FULL STOP.\"\n    return name.split(STOP_CH).map((label)=>{\n        let input = explode_cp(label);\n        let info = {\n            input,\n            offset\n        };\n        offset += input.length + 1; // + stop\n        try {\n            // 1.) \"The label must be in Unicode Normalization Form NFC\"\n            let tokens = info.tokens = tokens_from_str(input, nf, ef);\n            let token_count = tokens.length;\n            let type;\n            if (!token_count) {\n                //norm = [];\n                //type = 'None'; // use this instead of next match, \"ASCII\"\n                // 20230120: change to strict\n                // https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59\n                throw new Error(`empty label`);\n            }\n            let norm = info.output = tokens.flat();\n            check_leading_underscore(norm);\n            let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji; // same as: tokens.some(x => x.is_emoji);\n            if (!emoji && norm.every((cp)=>cp < 0x80)) {\n                // 20230123: matches matches WHATWG, see note 3.3\n                check_label_extension(norm); // only needed for ascii\n                // cant have fenced\n                // cant have cm\n                // cant have wholes\n                // see derive: \"Fastpath ASCII\"\n                type = \"ASCII\";\n            } else {\n                let chars = tokens.flatMap((x)=>x.is_emoji ? [] : x); // all of the nfc tokens concat together\n                if (!chars.length) {\n                    type = \"Emoji\";\n                } else {\n                    // 5.) \"The label must not begin with a combining mark, that is: General_Category=Mark.\"\n                    if (CM.has(norm[0])) throw error_placement(\"leading combining mark\");\n                    for(let i = 1; i < token_count; i++){\n                        let cps = tokens[i];\n                        if (!cps.is_emoji && CM.has(cps[0])) {\n                            // bidi_qq() not needed since emoji is LTR and cps is a CM\n                            throw error_placement(`emoji + combining mark: \"${str_from_cps(tokens[i - 1])} + ${safe_str_from_cps([\n                                cps[0]\n                            ])}\"`);\n                        }\n                    }\n                    check_fenced(norm);\n                    let unique = Array_from(new Set(chars));\n                    let [g] = determine_group(unique); // take the first match\n                    // see derive: \"Matching Groups have Same CM Style\"\n                    // alternative: could form a hybrid type: Latin/Japanese/...\t\n                    check_group(g, chars); // need text in order\n                    check_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)\n                    type = g.N;\n                // 20230121: consider exposing restricted flag\n                // it's simpler to just check for 'Restricted'\n                // or even better: type.endsWith(']')\n                //if (g.R) info.restricted = true;\n                }\n            }\n            info.type = type;\n        } catch (err) {\n            info.error = err; // use full error object\n        }\n        return info;\n    });\n}\nfunction check_whole(group, unique) {\n    let maker;\n    let shared = [];\n    for (let cp of unique){\n        let whole = WHOLE_MAP.get(cp);\n        if (whole === UNIQUE_PH) return; // unique, non-confusable\n        if (whole) {\n            let set = whole.M.get(cp); // groups which have a character that look-like this character\n            maker = maker ? maker.filter((g)=>set.has(g)) : Array_from(set);\n            if (!maker.length) return; // confusable intersection is empty\n        } else {\n            shared.push(cp);\n        }\n    }\n    if (maker) {\n        // we have 1+ confusable\n        // check if any of the remaining groups\n        // contain the shared characters too\n        for (let g of maker){\n            if (shared.every((cp)=>group_has_cp(g, cp))) {\n                throw new Error(`whole-script confusable: ${group.N}/${g.N}`);\n            }\n        }\n    }\n}\n// assumption: unique.size > 0\n// returns list of matching groups\nfunction determine_group(unique) {\n    let groups = GROUPS;\n    for (let cp of unique){\n        // note: we need to dodge CM that are whitelisted\n        // but that code isn't currently necessary\n        let gs = groups.filter((g)=>group_has_cp(g, cp));\n        if (!gs.length) {\n            if (!GROUPS.some((g)=>group_has_cp(g, cp))) {\n                // the character was composed of valid parts\n                // but it's NFC form is invalid\n                // 20230716: change to more exact statement, see: ENSNormalize.{cs,java}\n                // note: this doesn't have to be a composition\n                // 20230720: change to full check\n                throw error_disallowed(cp); // this should be rare\n            } else {\n                // there is no group that contains all these characters\n                // throw using the highest priority group that matched\n                // https://www.unicode.org/reports/tr39/#mixed_script_confusables\n                throw error_group_member(groups[0], cp);\n            }\n        }\n        groups = gs;\n        if (gs.length == 1) break; // there is only one group left\n    }\n    // there are at least 1 group(s) with all of these characters\n    return groups;\n}\n// throw on first error\nfunction flatten(split) {\n    return split.map(({ input, error, output })=>{\n        if (error) {\n            // don't print label again if just a single label\n            let msg = error.message;\n            // bidi_qq() only necessary if msg is digits\n            throw new Error(split.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`);\n        }\n        return str_from_cps(output);\n    }).join(STOP_CH);\n}\nfunction error_disallowed(cp) {\n    // TODO: add cp to error?\n    return new Error(`disallowed character: ${quoted_cp(cp)}`);\n}\nfunction error_group_member(g, cp) {\n    let quoted = quoted_cp(cp);\n    let gg = GROUPS.find((g)=>g.P.has(cp)); // only check primary\n    if (gg) {\n        quoted = `${gg.N} ${quoted}`;\n    }\n    return new Error(`illegal mixture: ${g.N} + ${quoted}`);\n}\nfunction error_placement(where) {\n    return new Error(`illegal placement: ${where}`);\n}\n// assumption: cps.length > 0\n// assumption: cps[0] isn't a CM\n// assumption: the previous character isn't an emoji\nfunction check_group(g, cps) {\n    for (let cp of cps){\n        if (!group_has_cp(g, cp)) {\n            // for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. \"e{300}{300}\"\n            // at the moment, it's unnecessary to introduce an extra error type\n            // until there exists a whitelisted multi-character\n            //   eg. if (M < 0 && is_combining_mark(cp)) { ... }\n            // there are 3 cases:\n            //   1. illegal cm for wrong group => mixture error\n            //   2. illegal cm for same group => cm error\n            //       requires set of whitelist cm per group: \n            //        eg. new Set([...g.P, ...g.Q].flatMap(nfc).filter(cp => CM.has(cp)))\n            //   3. wrong group => mixture error\n            throw error_group_member(g, cp);\n        }\n    }\n    //if (M >= 0) { // we have a known fixed cm count\n    if (g.M) {\n        let decomposed = nfd(cps);\n        for(let i = 1, e = decomposed.length; i < e; i++){\n            // 20230210: bugfix: using cps instead of decomposed h/t Carbon225\n            /*\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t\t*/ // 20230217: switch to NSM counting\n            // https://www.unicode.org/reports/tr39/#Optional_Detection\n            if (NSM.has(decomposed[i])) {\n                let j = i + 1;\n                for(let cp; j < e && NSM.has(cp = decomposed[j]); j++){\n                    // a. Forbid sequences of the same nonspacing mark.\n                    for(let k = i; k < j; k++){\n                        if (decomposed[k] == cp) {\n                            throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);\n                        }\n                    }\n                }\n                // parse to end so we have full nsm count\n                // b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).\n                if (j - i > NSM_MAX) {\n                    // note: this slice starts with a base char or spacing-mark cm\n                    throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed.slice(i - 1, j)))} (${j - i}/${NSM_MAX})`);\n                }\n                i = j;\n            }\n        }\n    }\n// *** this code currently isn't needed ***\n/*\r\n\tlet cm_whitelist = M instanceof Map;\r\n\tfor (let i = 0, e = cps.length; i < e; ) {\r\n\t\tlet cp = cps[i++];\r\n\t\tlet seqs = cm_whitelist && M.get(cp);\r\n\t\tif (seqs) { \r\n\t\t\t// list of codepoints that can follow\r\n\t\t\t// if this exists, this will always be 1+\r\n\t\t\tlet j = i;\r\n\t\t\twhile (j < e && CM.has(cps[j])) j++;\r\n\t\t\tlet cms = cps.slice(i, j);\r\n\t\t\tlet match = seqs.find(seq => !compare_arrays(seq, cms));\r\n\t\t\tif (!match) throw new Error(`disallowed combining mark sequence: \"${safe_str_from_cps([cp, ...cms])}\"`);\r\n\t\t\ti = j;\r\n\t\t} else if (!V.has(cp)) {\r\n\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\tlet quoted = quoted_cp(cp);\r\n\t\t\tfor (let cp of cps) {\r\n\t\t\t\tlet u = UNIQUE.get(cp);\r\n\t\t\t\tif (u && u !== g) {\r\n\t\t\t\t\t// if both scripts are restricted this error is confusing\r\n\t\t\t\t\t// because we don't differentiate RestrictedA from RestrictedB \r\n\t\t\t\t\tif (!u.R) quoted = `${quoted} is ${u.N}`;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new Error(`disallowed ${g.N} character: ${quoted}`);\r\n\t\t\t//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);\r\n\t\t\t//throw new Error(`${g.N} does not allow: ${quoted}`);\r\n\t\t}\r\n\t}\r\n\tif (!cm_whitelist) {\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: \"${str_from_cps(decomposed.slice(i-1, j))}\" (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t*/ }\n// given a list of codepoints\n// returns a list of lists, where emoji are a fully-qualified (as Array subclass)\n// eg. explode_cp(\"abcd\") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]\n// 20230818: rename for 'process' name collision h/t Javarome\n// https://github.com/adraffy/ens-normalize.js/issues/23\nfunction tokens_from_str(input, nf, ef) {\n    let ret = [];\n    let chars = [];\n    input = input.slice().reverse(); // flip so we can pop\n    while(input.length){\n        let emoji = consume_emoji_reversed(input);\n        if (emoji) {\n            if (chars.length) {\n                ret.push(nf(chars));\n                chars = [];\n            }\n            ret.push(ef(emoji));\n        } else {\n            let cp = input.pop();\n            if (VALID.has(cp)) {\n                chars.push(cp);\n            } else {\n                let cps = MAPPED.get(cp);\n                if (cps) {\n                    chars.push(...cps); // less than 10 elements\n                } else if (!IGNORED.has(cp)) {\n                    // 20230912: unicode 15.1 changed the order of processing such that\n                    // disallowed parts are only rejected after NFC\n                    // https://unicode.org/reports/tr46/#Validity_Criteria\n                    // this doesn't impact normalization as of today\n                    // technically, this error can be removed as the group logic will apply similar logic\n                    // however the error type might be less clear\n                    throw error_disallowed(cp);\n                }\n            }\n        }\n    }\n    if (chars.length) {\n        ret.push(nf(chars));\n    }\n    return ret;\n}\nfunction filter_fe0f(cps) {\n    return cps.filter((cp)=>cp != FE0F);\n}\n// given array of codepoints\n// returns the longest valid emoji sequence (or undefined if no match)\n// *MUTATES* the supplied array\n// disallows interleaved ignored characters\n// fills (optional) eaten array with matched codepoints\nfunction consume_emoji_reversed(cps, eaten) {\n    let node = EMOJI_ROOT;\n    let emoji;\n    let pos = cps.length;\n    while(pos){\n        node = node.get(cps[--pos]);\n        if (!node) break;\n        let { V } = node;\n        if (V) {\n            emoji = V;\n            if (eaten) eaten.push(...cps.slice(pos).reverse()); // (optional) copy input, used for ens_tokenize()\n            cps.length = pos; // truncate\n        }\n    }\n    return emoji;\n}\n// ************************************************************\n// tokenizer \nconst TY_VALID = \"valid\";\nconst TY_MAPPED = \"mapped\";\nconst TY_IGNORED = \"ignored\";\nconst TY_DISALLOWED = \"disallowed\";\nconst TY_EMOJI = \"emoji\";\nconst TY_NFC = \"nfc\";\nconst TY_STOP = \"stop\";\nfunction ens_tokenize(name, { nf = true } = {}) {\n    init();\n    let input = explode_cp(name).reverse();\n    let eaten = [];\n    let tokens = [];\n    while(input.length){\n        let emoji = consume_emoji_reversed(input, eaten);\n        if (emoji) {\n            tokens.push({\n                type: TY_EMOJI,\n                emoji: emoji.slice(),\n                input: eaten,\n                cps: filter_fe0f(emoji)\n            });\n            eaten = []; // reset buffer\n        } else {\n            let cp = input.pop();\n            if (cp == STOP) {\n                tokens.push({\n                    type: TY_STOP,\n                    cp\n                });\n            } else if (VALID.has(cp)) {\n                tokens.push({\n                    type: TY_VALID,\n                    cps: [\n                        cp\n                    ]\n                });\n            } else if (IGNORED.has(cp)) {\n                tokens.push({\n                    type: TY_IGNORED,\n                    cp\n                });\n            } else {\n                let cps = MAPPED.get(cp);\n                if (cps) {\n                    tokens.push({\n                        type: TY_MAPPED,\n                        cp,\n                        cps: cps.slice()\n                    });\n                } else {\n                    tokens.push({\n                        type: TY_DISALLOWED,\n                        cp\n                    });\n                }\n            }\n        }\n    }\n    if (nf) {\n        for(let i = 0, start = -1; i < tokens.length; i++){\n            let token = tokens[i];\n            if (is_valid_or_mapped(token.type)) {\n                if (requires_check(token.cps)) {\n                    let end = i + 1;\n                    for(let pos = end; pos < tokens.length; pos++){\n                        let { type, cps } = tokens[pos];\n                        if (is_valid_or_mapped(type)) {\n                            if (!requires_check(cps)) break;\n                            end = pos + 1;\n                        } else if (type !== TY_IGNORED) {\n                            break;\n                        }\n                    }\n                    if (start < 0) start = i;\n                    let slice = tokens.slice(start, end);\n                    let cps0 = slice.flatMap((x)=>is_valid_or_mapped(x.type) ? x.cps : []); // strip junk tokens\n                    let cps = nfc(cps0);\n                    if (compare_arrays(cps, cps0)) {\n                        tokens.splice(start, end - start, {\n                            type: TY_NFC,\n                            input: cps0,\n                            cps,\n                            tokens0: collapse_valid_tokens(slice),\n                            tokens: ens_tokenize(str_from_cps(cps), {\n                                nf: false\n                            })\n                        });\n                        i = start;\n                    } else {\n                        i = end - 1; // skip to end of slice\n                    }\n                    start = -1; // reset\n                } else {\n                    start = i; // remember last\n                }\n            } else if (token.type !== TY_IGNORED) {\n                start = -1; // reset\n            }\n        }\n    }\n    return collapse_valid_tokens(tokens);\n}\nfunction is_valid_or_mapped(type) {\n    return type == TY_VALID || type == TY_MAPPED;\n}\nfunction requires_check(cps) {\n    return cps.some((cp)=>NFC_CHECK.has(cp));\n}\nfunction collapse_valid_tokens(tokens) {\n    for(let i = 0; i < tokens.length; i++){\n        if (tokens[i].type == TY_VALID) {\n            let j = i + 1;\n            while(j < tokens.length && tokens[j].type == TY_VALID)j++;\n            tokens.splice(i, j - i, {\n                type: TY_VALID,\n                cps: tokens.slice(i, j).flatMap((x)=>x.cps)\n            });\n        }\n    }\n    return tokens;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFkcmFmZnkvZW5zLW5vcm1hbGl6ZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLG1DQUFtQztBQUNuQyxzREFBc0Q7QUFDdEQsNEVBQTRFO0FBQzVFLDREQUE0RDtBQUM1RCw0RUFBNEU7QUFDNUUsSUFBSUEsZUFBZTtBQUNuQixNQUFNQyxTQUFTLElBQUlDLElBQUk7SUFBQztRQUFDO1FBQUs7S0FBYTtJQUFDO1FBQUM7UUFBSztLQUFpQjtJQUFDO1FBQUM7UUFBTTtLQUFhO0NBQUM7QUFDekYsTUFBTUMsVUFBVTtBQUVoQixTQUFTQyxrQkFBa0JDLEtBQUs7SUFDL0IsSUFBSUMsTUFBTTtJQUNWLFNBQVNDO1FBQVEsT0FBTyxLQUFNLENBQUNELE1BQU0sSUFBSSxJQUFLRCxLQUFLLENBQUNDLE1BQU07SUFBRTtJQUU1RCw2QkFBNkI7SUFDN0IsSUFBSUUsZUFBZUQ7SUFDbkIsSUFBSUUsUUFBUTtJQUNaLElBQUlDLE1BQU07UUFBQztRQUFHO0tBQUUsRUFBRSwrQkFBK0I7SUFDakQsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILGNBQWNHLElBQUs7UUFDdENELElBQUlFLElBQUksQ0FBQ0gsU0FBU0Y7SUFDbkI7SUFFQSw0REFBNEQ7SUFDNUQsSUFBSU0sT0FBT047SUFDWCxJQUFJTyxjQUFjUjtJQUNsQkEsT0FBT087SUFFUCxJQUFJRSxhQUFhO0lBQ2pCLElBQUlDLGNBQWM7SUFDbEIsU0FBU0M7UUFDUixJQUFJRixjQUFjLEdBQUc7WUFDcEIsc0NBQXNDO1lBQ3RDLGdDQUFnQztZQUNoQ0MsY0FBYyxlQUFnQixJQUFLWCxLQUFLLENBQUNDLE1BQU07WUFDL0NTLGFBQWE7UUFDZDtRQUNBLE9BQU8sZUFBZ0IsRUFBRUEsYUFBYztJQUN4QztJQUVBLE1BQU1HLElBQUk7SUFDVixNQUFNQyxPQUFPLEtBQUdEO0lBQ2hCLE1BQU1FLE9BQU9ELFNBQVM7SUFDdEIsTUFBTUUsT0FB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QixJQUFJb0IsTUFBTSxHQUFHLHVCQUF1QjtvQkFDckM7b0JBQ0FELFFBQVEsQ0FBQyxHQUFHLFFBQVE7Z0JBQ3JCLE9BQU87b0JBQ05BLFFBQVFuQixHQUFHLGdCQUFnQjtnQkFDNUI7WUFDRCxPQUFPLElBQUlpUixNQUFNM0MsSUFBSSxLQUFLcUMsWUFBWTtnQkFDckN4UCxRQUFRLENBQUMsR0FBRyxRQUFRO1lBQ3JCO1FBQ0Q7SUFDRDtJQUNBLE9BQU9vUSxzQkFBc0J6QztBQUM5QjtBQUVBLFNBQVNvQyxtQkFBbUI1QyxJQUFJO0lBQy9CLE9BQU9BLFFBQVFtQyxZQUFZbkMsUUFBUW9DO0FBQ3BDO0FBRUEsU0FBU1MsZUFBZXhNLEdBQUc7SUFDMUIsT0FBT0EsSUFBSW9ILElBQUksQ0FBQ2pILENBQUFBLEtBQU1xRixVQUFVM0MsR0FBRyxDQUFDMUM7QUFDckM7QUFFQSxTQUFTeU0sc0JBQXNCekMsTUFBTTtJQUNwQyxJQUFLLElBQUk5TyxJQUFJLEdBQUdBLElBQUk4TyxPQUFPek0sTUFBTSxFQUFFckMsSUFBSztRQUN2QyxJQUFJOE8sTUFBTSxDQUFDOU8sRUFBRSxDQUFDc08sSUFBSSxJQUFJbUMsVUFBVTtZQUMvQixJQUFJL00sSUFBSTFELElBQUk7WUFDWixNQUFPMEQsSUFBSW9MLE9BQU96TSxNQUFNLElBQUl5TSxNQUFNLENBQUNwTCxFQUFFLENBQUM0SyxJQUFJLElBQUltQyxTQUFVL007WUFDeERvTCxPQUFPdUMsTUFBTSxDQUFDclIsR0FBRzBELElBQUkxRCxHQUFHO2dCQUFDc08sTUFBTW1DO2dCQUFVOUwsS0FBS21LLE9BQU8zSyxLQUFLLENBQUNuRSxHQUFHMEQsR0FBR0ksT0FBTyxDQUFDcEMsQ0FBQUEsSUFBS0EsRUFBRWlELEdBQUc7WUFBQztRQUNyRjtJQUNEO0lBQ0EsT0FBT21LO0FBQ1I7QUFFa0siLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aXRoLW5leHQtYXBwLy4vbm9kZV9tb2R1bGVzL0BhZHJhZmZ5L2Vucy1ub3JtYWxpemUvZGlzdC9pbmRleC5tanM/OTU4OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjcmVhdGVkIDIwMjQtMDktMTNUMDY6NDI6NDUuNjc1WlxuLy8gY29tcHJlc3NlZCBiYXNlNjQtZW5jb2RlZCBibG9iIGZvciBpbmNsdWRlLWVucyBkYXRhXG4vLyBzb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMvYmxvYi9tYWluL3NyYy9tYWtlLmpzXG4vLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMjc2VjdXJpdHlcbi8vIFNIQS0yNTY6IDBjYTM5MTdiZWUxZWVlMzQyZDY0YzYzMWNiMWRiYWFjMzdiMTY3ZDg0ODg4N2Q1OWY2ZDY4MzI4ZGM5OWFjMDlcbnZhciBDT01QUkVTU0VEJDEgPSAnQUVrVTRBbmdEVmdCMFFLUkFRWUJPd0RxQVRFQW53RGJBSVVBcEFCc0FPQUFid0NSQUVZQWlRQlBBSFlBUGdBK0FDc0FOd0FsQUdNQUh3QXZBQ3NBSlFBV0FDOEFHd0FpQUNJQUx3QVVBQ3NBRVFBaUFBc0FHd0FSQUJjQUdBQTZBQ2tBTEFBc0FEVUFGZ0FzQUJFQUhRQWhBQThBR3dBZEFCVUFGZ0FaQUEwQURRQVhBQkFBR1FBVUFCSUVxZ1lKQVI0VUZqZkRCZE1Bc1FDdVB3Rm5BS1VCQTEwakFLNS9MeTh2THdFL3B3VUo2LzBIUHdia01RVlhCVmdBUFNzNUFQYTJFUWJJd1F1VUNrRUR5SjR6QXNVS0x3S09vUUtHMkQrT2I0a0N4Y3NDZy9JQkg5OEpBUEt0QVVFQ0xZMEtQNDhBNHdEaUNoVUFGOVM1eUF3TFBaMEVHM2NBL1FJNUdMMFA2d2tHS2VrRkJJRm5EUnNITFFDckFHbVI3NldjZndCYkJwTWpCdWtBR3dBN0RKTUFXeFZicWZ1NzV3emJJTThJdXlrRHNSUTdBUGN0YTZNQW9YMFlBQmNFSmRjV0FSMEF1Um5OQlBvSklFdzNDWmNKaUI0YlZsbE00NE5DQUJNQURBQVZBQTVyVkFBaEFBNEFSKzRWMkQzek9WaktsZVl1Q2hBZFgwMVlQZXdBRXdBTUFCVUFEbXNnWEVDWEFNUHJBQnNBT1F6RkFCc1ZXNm43QWRxNEhCMEZXd1hpQXRDZkFzU3dDa3djcEdVVWN4cHRUUFVBdXcxbkF1RUFDeTAwaVJmSmtRS0Jld0VUR3dDOURXY0M0UUFMTFFGSVVDV1JUQW9ETGZzRk1nblhhUmV0QWRkREFFa3JFbmNDTVJZaEF1c251VGRyQURuaEFmVWxBTWNPeTdVQkcyT0JBTEVGQUFVQWl0TkpCUnZESHdjWEFLZ24wUUdoS3kwRG13Qm5BUW9aUHUwM2RBUVlGd0NxQWNjQ0lRRFRLeEp6T3ZOUXNBV1FPbmNuTlVnRitpY0ZXUVZZcjdnRmFUdGRRaEk2V0VHWGU1Tm1YNkg0Q3hNRHhRY2w4WGNqQktOTEFsTlRBblVicXljQmo2T2xOVnNEUlJjRWcyRUpBTkVHcXo4dkl3Y3BBamxkQUdzQllSOXhBSU1kR1FDVkFVbTNBQ2RwRndHdnhRTTNMU0ZEVXdGdldRWmxBbVVBOFVrWEF5a0JCUUJKUVFDckFGMEFjd0FydFFZSDgrOFpqWDhBQ1NFQUtRQ3pHMGNCMFFIYkJ3c3hsM2lCNkFBS0FCRUFOQUE5QURnemQzblR3QkJmRUZ3QlRRbE1iRG9WQ3dLc0Q2WUw1UkVWRE5FcXk5UFlBRFNwQitzRFV3ZnJBMU1EVXdmckIrc0RVd2ZyQTFNRFV3TlRBMU1jQ3ZBYTA4QVFYdzlJQkcwRmpnV0xCTllJZ3laSkVZRUhLQWpTVkExMEhoeEhBMFVBL0NNbFNSdzdrek1MSlVKTURFMERCL3cyUW15bmZUZ0RSekdyVlBXUW9nUExNazg1YkFFZWNSS2dBQ29QY3h3MXRVNStla2R4b0FwTFQ2NjFmMGxpVG1jQ3ZqcW9QL2dLSVFtVGI3dDNUZ1k5RUJjbm9SRHpEQzhCc1FFM0RlbEwxQVR0QmpjRXhSOTVHUlVQeVpXWUNLRXQyUXpwSnQ4dW5ZQldJL0VxZndYcFMvQTgyUXRKVVdRUFZRdGhDZDg2WDRGS0F4MEJDU0tIQ3RrTk5RaHBFTzhLeFdjTjRSRkJCelVEMFVtV0FLRUcvUXNOSFRFVnNTWU1ZcWdMQlRsekJ2Y2E4Z3VMSnFzVEpYcjRCYzhhSFFaSkFTVWErd0RMTHVPRnJGb3RYQmhQV3dYL0N5RWp3eFNrVUJ3TklVQ3plRVFhRndjUkphVUNqVU5zU29OUk1oNlBJZkk4T1ExaUxnOVJlQWZ4UEFFWlN3dDlQSnBHcDBVS0VjNCtpVDFFSWtWTUtBUXhleXdySjRjSnl3K0JETFY4YmdGVkNSMEpyUXh0RXkwUkV6ZkJDRFVIRlNtWElDY1JDQjFHa1dDV0JQT2JBKzhUelFNSEJUc0pQUWNQQTdFY0tSTXFGU1VGQ1lFZzB3THZOdEV1cndLTFZud0JFd1hIRHlFZjJ4Qk1SOXdPNVFpWEFtRURmeVhuQUNrVkhRQVRJcGNJUDE4QVc0L1VVd0V1eHdqRGFtZ2pjQU5qRk9OZEVXOEhqUTVUQjZNY0x4VzdITjF3eEY0SGhnUW9uNnNKVndGeENaVUJXd1RmQ0FVMVY0eWNJRDFuVDR0VUdKY2dYVUU3WGZnQ0xReGhGWnRFdVlkMEFvY1BaeElYQVRFQmJ3YzFEUDBDY3hIcEVXY1FrUWpuaGdBMXNUUDBPaUVFU3lGL0lBMEtJd05MYk1vTEl5YjFEUFJsQVo4U1hnTUlORGwzNm1lbllMSWdGL2tIRlRMQlFWd2g3UXVPVDhrTW1CcTlHRDVVS2huZ0I3c0Q3eHJ2SitaQlV3WDdBNThQT2trejZnUzVDMlVJaHdrN0FFVU9ueE1IMHhobUNtMk16QUV0aHdHemxRTlRqWDhDYTRzR013Y0hBR01IZ3dWMTRRQVpBcU1JbndBQkFNc0RVd0ExQXFrSG1RQVZBSUU5QVRrREl5c0JIZUVDaXdPUENDM0hBWkVyQWU4bEJCZS9EQkVBOHpOdVJnTERyUUtBWm1hZUJkbFVBb29DUlRFQlNTRUVBVXBEVFFPcmJkMEExd0JIQmcvYlF3RVJwMGJIRnQ4L0FkdHJKd0REQVBjQUFURUhBVDBCeVFIdmFRQ3pBVnNMTFFtZXI3RUJTZVVsQUg4QUVXY0Iwd0tGQU5rQU1RQjc3UUZQQUVrRlZmVUZ6d0pMUlFFTkxSUW5VMTBCdHdNYkFTOEJDUUIxQnNlSm9jVURHd1JwQjg4Q0VCY1YzUUx2S2dleEF5TGJFOGxDd1FLOTJsRUFNaElLTkFxMUNyUWZYL05jTHdJdGJqMU1BQW9mcEQ3RFAwb0ZUVHRQTzFRN1R6dFVPMDg3VkR0UE8xUTdUenRVQTVPNzNydmVDbWhmUVdIbkRLSU4wRVRFT2tVVDEyQk5ZQzRUeEMyekZMMFZ5aVZTR1RrYXVDY0JKZUJWQlE4QUxjOW1MQWdvTkhFWHVBQTdLV1NEUFdPQ0hpd0tSeHpqVTQxVTlDMFhBSzFMbmpPckRhZ2JFVVE4QlVOMTZXSW1GZ29LSGdKa2ZRSmlQbGRKcTFjM0hBS2g4d0pvbEFKbUJRS2ZnRGdYQndKbU53Sm1JZ1JxQkhzRGZ3OERmbzQ1QWpsekV6bCtPaDhmQW13WkFqSXlPQVlDYmNNQ2JhcnJoaTlqUVNjQll3RGFBTjBBUmdFSGxBeUpBUG9IdmdBSnNRSjNLd0oybmpzQ2VVYy9BbmkyR1ZqWFJhcEcwd0o4T3dKNnhBSjlCUUo4N0FWVkJSeEgvRWg1WHlBQUp4RkpWRXBYRVJOS3lBTFEvUUxReUVzakE0aExBNGZpUk1HUkxnTHluVnovQXdPcVM4cE1LU0hMVFVoTnF3S0xPd0tLMUwwWEF4ay9Zd0d6QW80ekFvNVlQSk45QW83VkFvNVlkRkd3VXpFR1V0QlVnUUtUOXdLVENBRGxBQmhWR2xXclZjd0NMQmNwa1lJeTNYaGlSVGMxQXBlYkF1K3VXQjJrQUZVaEFwYUxBcFo0bUFDbFdhaGFCWDFKQURjQ2xyRUNsa3BjUUZ6TkFwbkhBcGxnWE1aZEF4VUNuSmM1dmpxWkFwd1NBcCtYQXA2MGhnQVpDeTBtQ3dLZDdRS2VqZ0N4T1dFd1llc0NuczhDb0dvQnBRS2VteHNDbmtxaFk4UmtJeUVuQWllckFpWjZBcUQzQXFCSUFxTFpBcUhBQXFZckFxWEtBcWY3QUhrQ3ArNW9lR2l0LzBWcUdHck5BcXpmQXF5cUFxMWpBcXorQWxjWkFsWFlBckhkMHdNZlNteVRBcks1Q1FLeTVCTnMzRzFmYlVSYkF5WEpBclpZTnp0dWpBTXBRUUs0V2dLNVF4RUN1U1p6Y0RKdzNRSzlGUUs3MW5DU0F6SU5BcjZFY2Y0RE0yMEN2aFp6SG5OTEFzUEhBc01BYzM1MFJ6RkJkTndEUEtNRFBKWURQYnNDeFhnQ3hrTUN4Z3lGQXNobFRRTElRQUxKU3dMSktnSmttUUxkem5oMVhYaXFlU0ZMekFNWW4yYitBbUh3R2UrVklIc0hYbzVldHcwQ3oyY0N6MmdyUjAvTzd3K2JBTUtwQXM5dkFTWG1BMDRPZmtjQkF0d2pBdHVHQXRKTEExSllBMU5iQVAwRFZZaUFoVHZIRXVsY1FZSVlncytDeW9PSkF0ckRBdG5haEF5RVJhYzRBNGFoQUNzRFpBcUdiVlgxQUZFQzMyRUMzclJ2Y3dMaUsrMFFBZk1zSXdIMGx3SHl6b01DNis4QzZXeDFBdXIxQXVyZ0FQVkRBYlVDN29VQzY1aVdwcGIvQXU0N0E0WGNtSFZ3M0hHZEF2TC9BR1VEamhLWmp3TDNEd09SYWdPU2d3TDNsQUw1MVFMNFlwb1ltcWUzTTVzYUE1MS9BdjcyQVJjQU5aOFluNjhEQllrRHBtWURwdFVBemNFREJtYWhoS0lCQlFNTVJRRUxBUnNIYVFaZHRXTUJBTGNFWjdzTmh4NnZDUUFUY1RVQUh3TXZFa2tEaFhzQlh5TWRBSXpyQUIwQTVwOERtNDBJc3dZYm44RUFwd1VSdStrZFBUNFdlQVZvTno1QUswSWhRclJmY1JGZnZBQ1d4UVV5QUpCTUdadTVPeVpnTWhHNnp3NHZHTVlZaWNuMkJWY0ZXQVZYQlZnRll3VllCVmNGV0FWWEJWZ0ZWd1ZZQlZjRldFWVZDTmVGWndJQ0FncGtYdWtyQk1rRHNRWXZ1N3NBdXdTbnV3RG5RQ2tXc2dWR1BtaytjRUkvUXJaZmRUZGY2QUJZRVRPckFJeit6R3ZML0tiblJubzlKaU1FS3hZbk5qVitiZDlxd2ZFWndpeHBBV3ZYYmpBWEJWOEZhc25CeWJnSXowbGJBQUFBQ254ZWZZdStBRE0vZ1FBREZ0RUc1YTBqQlFDTXd3c0RBUTBBNVdVZFBTUWZTa0t4UXJ4Qk9DTmZKMkEySnpnakNjRTlDa1EvUXo1NFBvRStjRDV4QW9sQ3ZFbENPMS9MVGs5cVRRb3NhMVF2YWd0dUgxL2dNem9iQ1dlYkNtSWpLendkSmtLclFyd3J6QUhML0YvSkRoOHVDUWdKSW42ZDMybzZMVW9YeWF2SnJBbGx3Y3ZNQ21CQlh3L2xFS01SQUpPTkhVVkNKUnVwYlRuT09Bb3pQME0rY0VJL0hBY0tIVXhIYkZzc0xWcmh2QklLZmUwZEswSS9IRjBJU2drT00xUkRRamNFTzBPY0xBcUJHeTFDUHh2MUNGTWlJeGd3TVFBRmoySHdYZ3B4Wk1sZ0MyQXRJMjVEWUJrNUFoc2VZTE1HQW1zUVpVNWdUUkVCWk9kZ0ZXQ1ZZSDFnczJCTFlKRm9GaGNHdFE3Y1ZhbThXZ3RERnFzQnV5dk53UUlmRlFBY0F4NEJlUUpzTHpDVlVvQUJpZ3E0UnhvQTVDTjBqZ3JLRGFaTjZnR2JBb2VjVHdWQVh3RDM5d2tBTkJaWERBdWxEQ1FmdXE5SEFFOE1OQUFWRTU4cmdnaDZBdElMUzJVUkd3RFlUZ1oxQkFvZVdnQXhBTGE0QVpvbkN4WnZxeVE0bnhrQld3R0dDZndEMmUwUEJxb0dTZ2E1QUIzTFZhbGFDYnRoRTRrTExUOE91d0c3QVNJQ1Ixb29LQ2dnSGg4aExCSW1CaUVNalFCVUFtNVhrRW1WQVc0ZkQzRkhBZE4xRDg1UklCbXBzRTNxQnhFRlRGOEE5L2NLQUhvR0pHd0tLd3VsT0RBdHg2OVdEUXNBWDd3TEFHTkFsUWg2QU9wTjd5SWJ2d0F4QUxhNEFab25MVHNPemdLUUdIdFF1MWpJZEhLTzE2V2JEdldaRlQwYjdBRXBFRndTQmc4YkFjY0pPaENUQlJBckREWUxBQkVBczg0QkFnQ2tBT0VBbUlJQUJXdFhMd0FVQUZzYnhpNXNkaW9Od1JBQ095UXowK0VjSGdzYmZRSjdMczZoSEFUQkNxcnhiQUEzT1MwT3BnZTdDUUFRT2k3T0VSa0FmYXZhSEErN0drY2N6YUYzSGdFOUtsOGNBdXVnQ0FIQ0FVTHo1QjlsQWI0SnR3ejZDRHdLUGdBRndBczlBa3NOdXdpOERUd0t2QzdPb1NvSlBBNjdCWmdCRzJzS0Q0c2E0UUhEQVJFTHV4WTdBS0FMT3hDN0JCaWdlOXdBTzJzTVBBQUNwZ204QlJ2UTlRVUJ2Z0g2YnNvR2V3QUh1d0c3RDAwUkVyd0JBUURxQVFBQWRCVmJCaGJMRlB4dkY3c1lPd0F1dXdMckRsYW91d0FldXdKVklDcC9BQUc3QUFMakFBZzdGVHdWdXdBYnV3RzlLT0NsV3c2L3hBRDBBR2o3TDdadHZnTklvN3ZJcURzREFidVZKMHNBQWxzQUNyc0VBT2ZkR2JzSUduc0lvUVVLLzNBQTM3dW51eGpiR3J1amkzbHlCdnVwbTRNQUVyc0dHd3NCdkFBQWhnQnR1d1lBQzd1bk93RWFPN29Jb1p6S0Fic0w3UWZBcVRzQTRYc0J2d0FBNVFBVnV3QUcrd0FKdXdCcGl3QWF1d0FPdXdJWXU0NXBGZnNBQVZzQURtc0FMa3NlQUFhN0FCZTdDQ0VBRFVvQndnQzNyeVlCd0FBQXRBQU9td0crSitRQXNsb0FIQnNCdi83aENxRUFCY1lMRlJYYkFBZWJBRUs3QVFJQWFic0FDM3NBSGJzQUNMc0pvUUFGeWdCdW54blZBSkVJSVFBRnlnQUJPd0FIMndBZG13Z2hBQWFhQUFsN0FCc3JBRzBiQU9hN2dBQUlXd0FVdXdraEFBYktBT09MQUFrN0M2RU94UHRmQUFjN0FHNmNRRWdBUndBRE93QUpyUU0zQUFjYkFCbDdBYnYvQWFiN0FBb2JBQW83QUFuN3Arc0d1d0FKR3dBREN3QVFPd0FBRkRzQUVXc0FENHNBRGVzQURic0FHUXNHRmhzQUZUc0FicHNXc3dHN0FMb0FFenNEQUdrckNnRGhTd0FDT3dBRVVnQVhld1ViQUFiUUFCaTdBQXY3QUYrN0FHdjdBT1NMQWJzQUYzWUJ2QUFCY2d1aEFBVktIZ0Y3S0ZJQU9VVUEvZ2NOREhJQUtDcHdBYVFGQ0Y0QnZGNGpEQWtIYjB0c1h5cUpIendVWWkwMkE2RUt0QUhZQUJZQzBRTnVBWFp5UjFJVUlRTlBBaFUrQVN3R0EzTkd2SHRTZWtBQUtRQXhBZnNBVXdyYkFIdVFMQUVyQUhibERSRXlSZ0ZLQUZjRkFBRlFBUWVLekFCNE93UWdwUUJhQU5ZVkFKVm9OeCtMQU0xcnNRRFAxQllJd25Wekd4aFdIUW5SQVlpUXF5SlRVMDFJRWp6Q2lma0FmeHczUUNrcjRCR1hUd0J5QVNrc01DbENHUThETUZVRTk4WHVBRXRsM0FCcUFuRUNQeEY2T3NkNExqWFZCZ1VBRUJzZENnZ01LZ1FmSFNsT1UwNEl1Ym9BQ2hMTkFDWUFBUm9BaGdDSkFJNDFBTzRBdEFEZ0FKMDhBTHNBcXdDbUFLRUE4Z0NmQU5NQW5BRHJBUXdCQndEQUFIa0FXZ0RMQU0wQkJ3RFhBT3NBaUFDaUFUVUE0d0RZQU5VREFRY3FNOVRVMU5TMndOek4wTTVETWhjQlRRRlhMMGNCVlFGa0FXTUJWZ0ZIUzBORmFBMEJUaFVIQ0FNeU5nd0hBQ0lOSkNZcExEZzZPajA5UFQ0L0RrQWVVVkZSVVZOVFVsTXBWRlZYVmxZY1hXRmhZR0poSTJab2NHOXljbkp5Y25KMGRIUjBkSFIwZEhSMGRIWjJkM1oxV3dCQTdBQkZBSllBZEFBdUFHTHlBSW9BVXdCVEFETUNjK2tBaC8veThnQmdBSS9zQUpzQVN3QmVBR0Q1K2FvQWdRQ0JBR1VBVWdDdEFCNEFzZ0IvQWp3Q1B3RDRBT01BK2dENkFPUUErd0RsQU9VQTVBRGlBQ2tDZHdGTkFUd0JPZ0ZRQVRvQk9nRTZBVFVCTkFFMEFUUUJHQUZVRHdBckNBQUFUUmNLRmdNVkZnNEFpZ0NTQUtJQVN3QmtHQUl0QUhBQWFRQ1JBeElESkNvREhrRStSeWtBaXdKTEFNTUNVd0tnQUxvQ2tnS1NBcElDa2dLU0FwSUNod0tTQXBJQ2tnS1NBcElDa2dLUkFwRUNsQUtjQXBNQ2tnS1NBcEFDa0FLUUFwQUNqZ0tSQW5FQjBBS1RBcHNDa2dLU0FwRVdlUXNBK2dVRHB3SmRBallYQVZBUU5RTGVFUW9yRXdGS054Tk5rUUYzcER3QlpWa0Evd005UndFQUFKTXBIaGlQYWdBcFlBQnBBQzRBaVFPVXpJdndyb1JhQmJvckRzSVJBWjNWZENvTEJDTXhiQUV6V213QnNnRGRmb0IvZm9CK2dZS0Nmb09HaEg2RmlJYUFoNEtJZ29sK2luNkxmb3lLalg2T2ZvK0NrSDZSZnBKK2szNlVnNVdJbG9LWGZ0b0MyV3poQXRkc0FJSnNKR3lnQUlOc2JBUkNCRDhFUVFSRUJFSUVTQVJGQkVBRVJnUklCRWNFUXdSRkJFZ0FsbVpzQUtNRGgyd0F0R1lCQld3QXlWRnNiQURQYkFJTWJBRDJXbXdBOWdFWkFQWUE5QUQwQVBVQTlBTjhYbXpVaENObHZ3RDJBUFFBOUFEMUFQUWNiR3dBaVZwc0FQWUFpUUVaQVBZQWlRTHNBUFlBaVFOOFhtelVoQ05sdnh4c0FQZGFiQUVaQVBZQTlnRDBBUFFBOVFEMEFQY0E5QUQwQVBVQTlBTjhYbXpVaENObHZ4eHNiQUNKV213QkdRRDJBSWtBOWdDSkF1d0E5Z0NKQTN4ZWJOU0VJMlcvSEd3Q1F3RTJiQUpLQVRsc0FrdkJiR3dDVjJ4c0E1NEM3QU9lQTU0RG53T2ZBNThEbndOOFhtelVoQ05sdnh4c2JBQ0pXbXdCR1FPZUFJa0RuZ0NKQXV3RG5nQ0pBM3hlYk5TRUkyVy9IR3dFTjJ3QWlRUTRBSWtHalRGdElDOXMxbTRESm13QS9RREdXZ0pzYkFCVld2NFVNZ0pzYkFDSkFtd0FWQUVBdVY1c0FteGViR3dBaVY1c0FteGViRDNZQUVsczFnSnNiRVpGTmlKOUZHVkFlOHh2RVpLdnhWZktac3pBVlRCellCSDJkMWl5VVhFSEg3dHdOdzdlWkY1SkpSSEk1RWdhUnI1RDIwLzNkZk9OckZMU3E1cVNycmdkMkNFVXE3MjJXQlEvTHpwQStieDFvUkVJNXh5NEJEU1pOdW4wWldPUlVKcUluWlN5TWFpb3l2ZlNJMGw1dUZEemJXYVEyOC96ZEIwaHdSNE9RWjAvam45QUxTTE5pa2pGWUdmcVIzODlxdEZsaEQzYTZLZEloOTdyaFpZcHl3dUxjN284cWw1L1g4S0NiUFUzTC9RbG1Db3doUlhoc0dEdmc2d1VOcHJBOWJNLzQ5dXhsQWo3WlZ5M291RVkvQmdGWEJOeUswVExyU2paV2VKbS9UNG56NlFHTFQzY0pOdFdSWlZaVHZJZHRheE1NSlJIZ2lnOStTMTFMakJoN0lucjA2eWtvY2gxVTA5N1J3MGh2Z21PcnlkUXlhV2NFUURnMFJhdnVNdVQwellhYlVabDFlMzNITlNLMW9OVUNTMDNlaCs5QzJFdkYzZnE5aCtYQmFBTUZ1b1dlWmYrbWZaZ0w0SHp5aUtESVV0Zk5VNG9GdTBhRTlxdDNWQTNVNEQzZk9TckFjWVZuakczY1NrcDF2aFhabnAzSlFtNEprbktkQml0TzJOVm5HQ1lRd1UzWU1XSFdCODdORWQrNEFIdU9LSThCU0lIOTJyZVcwcGZzK2tXQ1RKeERDYlJqRnY4Q2ZjNC9EU0JZSlNjSllUZUFFZ2c5d1RFdmN3ZC9RdUhSSHFHekFRNGZYZjVGVUkxbFByTytmdkVjUGw0SkluTTF6OUF0QlQyYkw0UVlFUkVlN0tpU25ueFR3dG1BRmpuOGxxVDNtTkQ4cVRrdFgyRjE2QWU5Y2FrcUo2L3BFUXNIVVJxeXFXbFJNQ3pLWFJLZkNIVDdzWUhXeDkvVC91Z1lURlk2aVZOM0J0bTU4QVRKUjVhbFlaeWJLTVdvandPdzNIYkZuMjNORnllTGw3K0VyODJSY2h5WXVCb0dRM2o3U0FXTnhpWXZwNVUrRnEvREV6QjljRzVEbEpXc3Frb3NSemU5Mk9WbEN0UUVZbzFTMWxGNzJaOHhXYzRsZC8rZkZjZlRFRFRGYjlkOHRKR1E3NWRwSkV2Y1d5R21HQmlUYmlXRGRHT2N3OTNEbXhxNUlTVXJtYXN5Z09OZkhMdmhnbzgzSFFaZW5iZEJ0U3pCa3ZZckNFUS94RURNaE1ac042Z3FwbHg1akdHOW1TUUxoTTgxVUVkRWVKNTlzZE5KREFGeS9nUHlKb0tsd1BaZ0IvTWtDL2tJQ0xpQ0I4dmErbkNkTzJyeTRhRGZrbVBGcEYvSC9TR1EzTEo2YUF2OWR0SjhEbmlIdExPY2taaXgwQlZiMGlSNVYzTEFwNTIxTEJTSWk2QXRWN3IyWkIvaFFFdkF3NTRFRk5PUWNGbmwxeEdVSWM2N3RxSzFJTk53RDJuL1Jid2d6TzloNDVMTTZWTXVOOFYxWk5JUTZ0K1h5M2xUcXlWQ0Q1a3FMeS90My9iOE1MYmdEZzhKSVdEa1NaK0xyR2hocitnWXBIK3ByMVRuQ1VuWlBqcFVkdzZiU0w2TVdWWG9ERGNpUURXRUN3VTJlNlZFcGZyY09CYnJTT2lqcUdrRUlvSlBicG1lSkxrY3didkEweVdJaXhRVmpvMEhuWWg3ZmppK0RmZHExbXRWMWxHMlp6OVI3ZUZNSFMrRks3bnlidXR1MmZ3ekRwRmxkTzJwWkJzaHNISldhbHRuM1BXT29HSnBDVDJqRThFSE91QzZGa2VqTldjZnNXQ3FOcU1MUDl4VHdjV0FyajJFaWlJN0QrRWFEaTcvMmNxSEwxZ1BpRjZDL0o3YVVvN1JRcW9nUFoxMVdxYnlQOTduc29NeFBPQzc4d1pNRjdCMVkwZzdKTlhKVi9uTjFtNHh4OGhicVd6MDdLU2FxcjVoRTRpY0IzMjZETVIvdlVLWDlMb05qbGUvWld0YlVoclRBY3NkZ3JMbEc1TmU4YWlSMGJTLzJaaHBOT1ZWeGF2V0lac0VNL3JkNjhFQjR2amJiRDEzTmtNSzFxdk1rNzR2R2JTa0w3VUxPMHNaOVI2QVBTQ282S0grWG45OHdFZHcxYkNQQW5EVGFCc0Q2c2lkQUdONTh1aUg0YTNvdkcxS3laQXUyWHR5R2dGL3ZnV0tHeHc5UjFsZkFWY2Z1WUU3MURIdXh0VHpmR1puSGFEcERHV21mRXEwTjRHYXdFN3lJa2FvejhqY21WbXpKZTF5ZE04cTBwMDhZSXhGY1kxWWNxUWMxZGpXQkVvTkVUREZjZ2s1d2FSZnRFSmFzUFJFa3JWKytOL1RPS2tFUkYxZkNMclhTOERGR1lHUkJlRUNNUVJORXMwRVMzRnpVdFhDY054cFlFTTNVZWk2WG9kWnJ1WFVJUm5uK1VYZjJiL3I3bjF2UXV0b2k2V29JYlc3c3ZETldCYlVXY0RVYzdGOVNKSzNidlN5OUtJcWhneUpIb1cyS3B2djBKNG9iMTRIRlhHV1dWc1lYSnpqd3hTK1NBRFNoVGdDUmpob0RnakFZUkd4d0oxVm9udytjcG5DS2h6OE5RUHJiMFNGeEhJUmJtRzk1UTJobEM0bUR4dlBCUmJrRmE2MGN2V2FrZDdmMGtWQnh4a3R6WjlhZ1BKRVd5QTYzUlNIWVZxdDhjUHJzMnVGSjNyUzNrOUVUR0tuNStBNkY5SU9yZFpIZlQxYmlFeVVKS0V2d3p1c2N3c2hHQ0JKdmQxNlRyZWZXMDN4Vm5KZjR4dnM3MlBkeHJNaWRqSk84RWlXeU4vVld5QjNmdjlrYzM0WUl1WlRGdFhHbzlEdUczSDFVa2E1RmdCTXdEUEV2UmNTYWJpM1dha05Ra1hGZWNKbEZrNmJ1TFZrNVlIcHVLV1R3Nm9GNjMyRlBQU1ZJVmw1aGdVQWVIaGowdC9zdy9QRUV2VGhMUURERkUzNGVDZy9yTE95WFQzcitMOThvUktybFRPME1kQUxZUTNyUlFxQzdkODIyZEpQR3hGMUs0SjJUdGZQU01GYUNBZzBuME5Hazl5aWFLS09KRDF2MmFCWDlIVU9JYXdqamZ2d0NtakhaSlRSNjJSOWM5eDMzSm5CaldyTjRRWUVPbWVoeTBvWk1QOVhNOVp5aTZUWW9lMDdQYUxjZVJYY0NXWmlZL2ltUlVXVzYrbWNpNyt3TXhTZHdNZGJYY2tYdHZoSkg4c2M0aVFjVHdtN3lwKzNmN0NhZXNUVFFCMnFrZ2VYaCt3RmlTTVhmTWxIN1lpbDBPb1oyUVR0UkxUaXAyTzBjTFo0U3N0cVdIWjZIKzhBMmtaWGhwbTBrUGJMOWRVYW5UT3Z6aXFJVWg2QW1id2EzV3JDYjJlV2J1Q04zTDFoZ1dVbWpSQzNKb0wzZEJoUjNpbVNRSTh4dUNNZnNzemxqaTdjU1NoTlNZZHFDWFB4RVZ3YnFPOWk1QjZoZjkzWUk3YWV5SThqeGdjVlhLMEkva2xidmhTWGprak9Jd1pnUGRWd21zRlc3SEdQTFVBdkRSdUttK2l0eWJSZzdjOCtZcXFqZzgyNFFmKy9OeHNCU1VOQUs5S0NvSnBhdUZxSzBYUVVMcldZajRGbnhlS0R1dnI1NGlva3BpK0Q1N2U2WTF6eFJKSmRzSG5EUjNKeXJhQ1V1ZkhCUlRLT0RXQlZ6dGhqbTRrMy9IditROTkwWERWUitLVytUY0pYMDQ1TFc4NkVLaHovOTdhcWo4OUE4WnZUazEvL3Rjem9zVTkwbG9JUFZhSHVXZWdKVTN3UC8vN1hIY083YzB5UU0yak0vSWhRS3JmOGhpT2JIV2lXRFpNYW5GOFVmL0h6Ym1EZkMyd1QvL2FpWjRoR1R2L3h6Z0t3ZGIxc0Q2Y0dFa2Nlb3cwczNiODkvemcrM3BseVJtMEhsWmk4ODZqNXdVd0ZoZEhpRFRhQmlkWlJvNWN4L3RNZUx5Z3VPQVRienExN3lkaHpicnB4dW51SHg2bGJGR2lPOTdnc2Q0ZGsvLzdpQ0lvK0V3K2hHMnNvNWt2ditJVEc0YzFmekhQdHUxWG41UWZVbnFZMy91QnlWbUI3Z21uRS9FKzV6ZG0rNm5EbW9ld3M1ZnIrTnpUaGRTSHpLNGJCUU9MOWM0TzhPSTB4TFNxako0bGJuaUxKZzFhRnBRUkx3YVNNWm1wa0M5ZS9qNkZPVnJUUTZhL2E0YWxHZ2ZybDJaTDFzYkhVUTNET0k3bnRxOWRpSEZmbTN0MW11bDNyZEpFSkNIbmxXL2hsUW50aXBNcnBlTXM3ZlVyNndLMzcwRDdWYlhIMERVSHpkWWZSZy82WjExVWx0MXNmZkpTK2hlSGJjbzE1U3h5MytyRG5QZXNxSDFsYWprMHl1MDJoUFV2RVVxdmNVWFdYTDdBZDB3TkdNeDVnT2xlNFhKeHEvci9ZWTB4ZGNvMndSU0VHd2NUN1lBRGxCckhjOVpidnpPTDBRd3lXQ1dXQ2hCOU9iZzgwMHY3dHlCV2FOdmR3eitmTDdQaDlpMmlyRWVKa1JnT3plRUR3K0ppRC9WOTN2SDlGZ01Fb0ZJSk1vSXVvZ21pY1pvaGY5NFNCdVBuNmhYYVY5alA0VlZWQS9idStXZzhTODhHTHRtRVBTTlJMZHRsWHgyWEwvbnVNOG5La2hubG5qYXJvcGlLS0xJSDk0cExJQVNjaTBwREJmajlIaTVCZmFUU1hRZzUrUE1qUVg5MUt0azRNT3FLMUs5OWw0QlJQdjUrdk5vdkdaM0l4UXY4SUN2alY0L2RpVGhwb2FNOHV2ZDNEOWQvREU0Nzd3M3lBYlczSURtMmk3M3BaOWFFajM4SnFTNmgvczgveGdtVUlWY3VxMkpUZ2VmQXl1b2FmelF4QXVSQVNlZzNOdEczYWNoL0pFa3l1WCtKRHQyUG5EWlRTaFVoeUhIRzN0dEJnLzZsaEFjaEdqTEpCdG9wajRlMDFNbENwMnlxUVJUcjRzQkJYcnUrbEthb2Fud1lYOHkyYVdDSmlSM0tuaENPa1lWRlN2c08wb0RSdWpVRk9FcHRpTkRUWXJKb1Vidk95dmw0QWhDOWgzd09SaVRYSzFNcnBNZm52ZG5uZG5SL0hSVlN1c01CZ0l4d3JMZG4zdnExVmNuY1BpRDBTcXVUeC9rTm14ZUZ5Q1Q0dVhWVWQ5QUwrclNHbXVxN09PQ3pES2VWUGppTldWYW9QNUtPRnFZcTVYY3VmL3hXOVMrdTllSXE5R0F0Wld0UWxna1JlY2pSdHZHMU5SNFdYWHBuK3B3c1RCVEl5MDc5SWtnOHJTZWYxYVZhcElGY1hDZDZDMndIVmpMWFIrTjB0dzRUYXc2eDZIOTBCRlJnTnJ0bHEydXA2aEhLdVYzaW5NNVJKYVFXWkhkODRlNlJzS2trOXBvM2RrOWJ5NTR0cFB3N2NCa0Zhcy9HK0diSHd1RytBd1A1NUJaeVhJTFRIQ0lWclBwWEhFYVVQWWZMNm5waEpQMVJjMTB4RzRVYUNlWTRJSEN3dXVyOHhtU1FEZ1k0YVZ3aHpXaGpidFNIRzhKTzZQMmkybkM5LzBCZngwems2ZFlRcTNhdzdrNXZJT2JEN1NFS3J4aHowZlEwK1lUT2ZIVzIzQ0JOZVpjaTFxTnNVRGhvZXFtZnlQNlB2am9FakhrOFFickZ5UVZaUEhWV2lqbmI4WUNNNjVpWU5vRWJ2bmNoU3RaLzljS2c1VmQ0NWo4S25CNlVqelhsL2JreVp4N1ZvRDQ3b2NVVWkxMTdXd2d5U1NiNHJYZ0xKNTJNdjVYSmJwM0krdUJQODFCVXZPank0Q2FjZ2krR1dXbEMvOGR3Z3F3aW9qalVCRG5FT3h5Unlvd3dMUWZ5dEZyYTFPWlM0WHZSWXI0dW9hbUFmRzNJL3AyYkE3RzkweXFLVGhIOEtlMDBUcWQrM2wzZG1KcGFDWmVsQk1ZakdxTkxWYTNTTTQrTFFlTDU2Z1k2QnlteTJMUVBWT3hqV2ZqNXRxNG83NHN3Y3hoeUdKUHlua1M1eEFqT1haUDEvRkFZY0JUM3U2cUxvSWtFZkVyd280Z296bXlJMVlDdk0wb3lJM2doakdQUVNzb2Yyc0tVaHE5MVdzS3k5Y1lXTis0QTJ2NHBHL014cGRjNnc2a0kvSFg3WGIwVHVpaG1zaU95MndRSXNyWmJVbXIzT0JTVW82b0RKTmdRcCtZcVlrZ1RnWWNXWkRnYXdKdzNERmZkelQvL1BoVlVpZGdCMnFhOHV3L2o5VG9IQkFTMzNpVDhZTGhoQWZ5WEcwYlFVRnA3UW1IN29RM2k2RmxmNE9UWkx2SmRoOHBmdWZsbVd1Mm9obTVwVGlTZzFwbDN2cTl1bHVUSndxWGZoMWhxeThlMmlIb0QrWTM1Z0NJVmlUbzZWT3RLNWREOEhZQ2x1Y0p1Y1hBU3p3ZTJrUGo0UzRlWVF0bWtZSGFnWGhBenAvRjU0MXhFOFlGWXFTUHN6RHV6M3NvV3pIeTBwM0UyandaTlFhSWNHVTlGTlF3UXhlRHcwWmxLOWR4WHJqOUlVSEdVUFRPeWliOENxWG1iWjdFeDU0Ym4xckx4M3FxQWF2dS9naDZYalYwR21OMXAreXlNSzlITjV1WUV2eGdiQWs0M3RzaGVSRWh5SStRNVdMSW5lS1RHUG1ZaU0vbHhPcDhmdnFIeThZZ1hLMFRsTWlYMHRsaUxJMkp0Zm1XWlA4ZVZWNzMyc2RZbStwY1d6RHpFbUtMSlp5ZWVseWFaS2tqUG5uVU85a2VEd3RnaUxubWQ1K3QrU3I1eThiclJubHZ4Y1dFV2ZDcUlBTFFZSHZhWHg2alRnNGRBbHllNDY5dUd3d09aVlpDSUxMZkdqYU1nNExVQ05NVHRNU3AxYUMyeS8zd1IydDF2M3cvaU5CUlErYk5idERxTDJOQXI3SzRyVWN5cWJTcE5yWFpnQVdYdmp4QkJ0ZllMSzF1Ull0M3EycGZYSk9BTDBIdFdjRXdKTGRkT1NKS1YxU3d2Y3ZFdXpnLzRNUG5BOE1JVUpPTHFtM3FJNndGeU45OUNrNnpZYVYvekdTQXpGL1BHc2FOYTR2UExlNVFueXVxVlVuVlE2eEVMQTZnYmU1M2FHZ2VrZStSL3ljYjJMSlZ5YzdCaHV6STkwekErYzZ3VURUYjdOSC8vZ2REU2wydS9hVzdsUkptOG0xZkx0UHhjTnVFTTVKYmtPQ1pLUE04OEhVc0xSb0MxcG1LS2x2V3llQVh1eElMYnUwc25wU3hmOE4rUmd0TFVTZTVuMmdkak9qb1NUYU43bU1aN2JGK2NXay9NUzhtRkQ0cGN5bDVVTjdDYnBGWkgyYStQbTFWQW5VVFZmYnc4cXJtejFHOW01YUttUnpZMVNNaGhQcmxDbjJ0NHVOVVhOQTNJRmU2Tk9qU0MxREVhQUZaQWZEbEVrUUNzYk5oc1pQajZOUVBEU0IzdExpVG8wWllvRWJJZUVJYUt0VTNXazYwckVzemF3VEZ1eUhWZDM2NUxBL2MvdWFyQUJONU01ckdxL2RxVEczSWx5ZS81RUtpWWlzaXN1enFOYVpqbVd2MHo5VE9SYzBDS2JhVGVhMjE0b05NOXUyc1hVWnViL2VxTTNQaS9QalJTeVFpT1N3UFdpZjJhc1RndTZoUzZmYjVVR29zQ1d4ZGVkTXFkVmlJVVVTU2RJSngrcVE0S1NoZlRUMzlWQVdaYmkrbUIraUtJQ053cHQ2Y2ZsWTU3UmNiczZkMWtBMjZJcnU3M2N1eFlWbFN2dUpkY1I1VmZEWVpSazhYMEFYZVBST3l3M0xlNkxhVWRtVEx6WXNvTmhoZ1FwZDY3eFZOaUhnazNwYWttbmRlSUF0VEM0RENYeTlvUzZlVTRDV3hEZFZtWTUzcEtOYmRBS21Rc1AzN2xySlpDNmlEWE1FTEdLY0hqTnV1WmdjRHlZOFcveXY2aGEzRFg3T1dtLzM1ZnB2aHc1NW9pdGY0VitHVUxsY1BXWXlHR3VWQmRybzE5Yzh1MFJEZGREdW40MFc3RzVjU0l6SExoL3FaeGI1OVIrRVBZK3daMlhlcmtVaW05MmhoWHBLeVc2V3RBaDZ6UVM5N0RyUHlqQ3ZLaTNwQ3c5NkxlS3luT3B5anRzTVFjMlJtSS8yMHpGT1pjU2EyQUsrK1BvUmNUNnplSnl4bEJaN2trNW1ocVhHa0xsTTJoRktjKy9UNTQ0eFhQMFVhMzhRNnhkUFRMVGVHMVBIbkxNYU92a3NVUU1yRUZUQi9saXpDaXJtRlFMOHpZVlUrT1RlWVFFRmFJVHNCU01NWWV4UzlIa2FqTzJnR0lmMm1pY3ZudENaSnNaUUV3SUgzLzRKR0pRR2ZsQnVINXJOWG1uUlJZWERRczNab0VRb010WURyMWtGS1VTL3NpaVFTVXhjVEg5WFllQlppS0RERlFvRXhSRU85ZGRkS1FMTzNCd01IdnltQ1NURnlZK3Z4bjNEMjdORHg2T2xVMDkyRDVFRFV3aWx0dHFWSHBqSlFEVWNlSllDTHNLMnN3ZlhlTlVWckJKVC93L3NrKzdzaThyUHRpTUZpcytveHZHZEdReGlyTUJJRDcwMFQzOW1VTHVOSHpPeU4reEJmY0ZBQ1pjeW5nRjFhU3B2MEpQa05VckFaVHFmcGx2NTA5Y0dYRlVpRUVtNWRaYitPc1AvYmxpenFkSzQ1L2RTc0lydWZZVHJDUFkybGdKRDZrNlFsalRmWFZsSGZZS1NxK01zYWd5VWNhTWludHlyOTViRDhrZFRBZVlOTE5zTW1vL1dkZDhhMm5TdEJQNDlBUklqcXFwVUhXWTRxNG12TzVDcS9DZ0NQKzQvQis1enV0R3dYNXBzc2dWTHIxK2ZJTTdXV0xmaVVRRGs0YzZaZEhaT1d2NWhHM2cyZGdRNU5YbnBJWStCV3dKcGFvdWYyNWJYbmpEemJIblFOb2ZIL2M2bStkRUFTOUdzMmg3cEZSUEtPQkRucXN3WjhLWmpoSWQxeXRIVVRzNTMzS3dCb1NpSW1veEtRVWdaN3o2cEE5UUIzc1o4Q3Ewdnd1dEpUVGtmYlg4QXpDcG0yY0ZYeC9QMjJuaVVNSGF1VThJR2MrNzhSNlRzdXRvb25vcUZ1b05BM2w4MHQzODdZSE1vTDVLR0FUMUpPNHpteCt2SjBMYkxIbGljSHJhU1ZZdkpqbk85cCsrcW5XZ0t3OU93RlZWVWFndlp1ZjlxZml1dW0raElpY3hQMXE0ekRuemtIc0NOcmlMeEJweFk5TitVT21xemRZMU11bkxNRGdrTXlpM3V2bk4zVUJYSmVaOFlMczV4cjhRck9oaW1Zb0t1R0JlYlpIQWlCSWtWaXYzREc4azJvTnBwNU9JZ1g2dWxxYVJOOFY2MlFVUGpuNXRsMWtQWGhUOWJjZDhxSW04Z2k0b3IvRkdidlE2cGdHU0htbmF5cnVnbWY1RTB1cEd4UFJmLzN4T3RpdEdNYUhMS0pWbTV6aGdsbVZmSTkxbzB5eGhKWlZTLzV3UTh6ZnhLOFlsdzBXbUhYb0dmUmtvQlJ4OUhzbmwvNnNnVGpBVndwbU51U2VadEJ3bFg0cUI4Qmg4bHhqcUJESXVGR0o0STF3eE4wWFJsQUFzbHpxTUt3UWZ5QTdPa3VpdkNYZnYraSszWG1oY0JGTTJuNGpkVCtOeVVtQm5RSlBWM0Yyc1pmS3ZKaFVsWHpTb3NGUjRWZXZWVmNPa0ZubmpkaVJXYzBUZVNZeGo0MXNKR1lNYlpUZUxJM0d2eVo4L2dBQXVkUTErNG9GWCtlblg1VjQ5TWN6R0NZVkJ1b0M0a0hqcDdaVnhqK2NsQndQcjlrK3YwNVNzZXpRSzNlbnhMczFOdC9ON2M3QUltVlV5c2pHb3U0aU9vaEhvODNaczkvTUkvT1dCK095WHpPQkQ5M05iQXBHSFhydjhDVlJIcDJid0greEI1NWNmTnJkcUZEMzVIU014NGlWbXR6WUFtU0NJVjhrWHNIb3EzREliOTNyaVRXYnVibmp4YkJXNXpDb25WdGJ4TFJTdFhIa0l5QUJ5YW96TUU5NTJHYzlhQWRBYkJwWlNWQ0g4OFV3Yi80YlBUVk9WbCtXb01ZRDdKSXZLOFZjTXJKOHpIVjRiYkcwRGc3S3gxN0E0ZWovWmNaMlo1cFZ1VkxVSDFFL0FjY1VUS204MVNFK0xRNlNUVFVEc2NVazB4Mk9XSWJFT1JoZzY5dGRvVEdOa0ExUmZrR0lSWkhyNW1DWE9wTEM1NVdXekNab0dQRlVWdFpSSHdoMG5xMDM5Q0RkakVQbytKeWF4U1FBdkRnUjZJcXZ4eTBmcnJ0RUcxQTM4NU44MWwwNVNTek4rSURtOWJ5cEY5bTkyRVVxYmxuYXVaNXNqYzM3d1J5a09kbDd3NG84V01nUXNqaWkzRUUvYUpZRGZIczFjSDZETkJFdWpqY0NjOHFBZWZZRnlJQVVSRGNEbnp1bjVVbWtiQlFzVTRldS9XOEk5bkJFMHFKS1RkZzJod2pxMCtYVjdhM1RKN1IrYWx2SlpDUmlhOWxKK2dyTkI5ZGJyT21XRXZVb3RNanZEaHE0d1Yva3E0ZnZJQmt6VUdwRGVZSDc0cm5lOHVVM2Rnb05aZFI5cFVMNnE5WUROUmZPaUY2RHlrK1NZWFFJZ2hUam05cVI0dEJIaDBnbm1GLzlxM1F2MjJFemFMaFN2RGxET3hNcnJDTlJtTENsMWpBcHpMckJDUG4ybWpuNXpxSzdPWUs3VnhPZlE1R2ZCZm9QZHlRd3FGRWdDVkhrSjlvVG5hZ1JNM1IwK3JzdU41alF2OWljQ2F2L3AxV3FpRVhTekNkTGQvV0VBNno2ZERQN3RQcVBiZURZS0FrVmN6MWxMR2JGT0M5YjdjQmQzTVYwVmU4ZFo4OW9SN09ueEdTN3VWcFNyeThiYW5WWndwSmcrbmtIMWpSQllhMkJ2Qk1ZMnhJVEg5RVJYQ2pIemRaeHMraXBkWFAyRFk3WCtlV2lCaHRUMkwwUlJHVExQZWF6bjV0cGw0dHU4aUUycldpZzczMWl1SkRSYkNISHkrZy9NYjkrbWlBeVZxZklwWFQvaVplT3hPeE9ETzBoRXBMTTc4STErRzJaNDV5aTNsUzFLM200V01RNTU5THA0VU1MNXZaVWpZR0p1eGwrT1BwVUg1a2xweUJ1amtqcHJoZWkwVG1VaWsxMGdqdk5VcDhtRGtXbE5LaWttWXNwYVZUcWV3Ym5PekpybXo4RkxJcHNUNjdFSkxISUlmZURjV0VmaVArREpyWjFqZnhwb0FiMmFiZU1xTHgrOVJ1Wkd6UW9ZdFlWR2dBV3dFTTlLZWsydlBJZUJOQUtENmFvN253NnNndmZlTFpQb1hrYllPL3RTdEhKZEt6aytXRlNGRVUyTmNBTEpBRVA2UzhwY25xcUJCdDU3ZHdUcnpRTkNJZGsyU29jSzRkTFJiRC9wdS9WcnlLbm02NVpZWGlKQ2ZISmszbXg5TVJTbCtuU0s2T3FFQlNvR2p6MC9MQURkZHdGL0hxY2ZLM0szTys2WVVHUWNtajhwWkw0UGhaNktyR2tiOEIzOEZtRHZ2TGQzWFFYYnZTL0ZRbXJYRlR2Sk5rYU4vRkdvODNLdVM0M0JLMVVmVm5JcWlnR2tDb1A1ZkJkYTJNd0FHVEdOS1g5Szl0NEJ4ODNwTUZjNUtTT1JtV0t2KzhWb1ZnZ1d4b2FCejMvOUlCaDZSd0xkMXRlYnd5ODl4dkU1ejZFRXBYcERmclhXZlJzTXM2K2VrVUhINmlkVm9zbm81NSt4UThacXplbGgwYnh0SlRnQ2NIM1ozL0N4bHg5ZU5JUzRKSUZLT0FWckRxYnJYUnN6bVk1NWE1K25pSkdIdGtPM2I2bW5JRHhMYTFXWGM3QkFlMzNtdDJLeU00RmJjM1I2L1dWVFFOOFFobHFBdGF2ZTJXc1FUcXpXZVNsS3VHVVZJSlJxdE9icHYyOTRyUzBrRE4xUkt6ZHN0WlRYSmViUjJIbHpzUTRQM05iTUhVcUZaTVp3Ky9JS1huaDR0K2xZOHFvY3AvQjFvTXN6UjAzRUZzM2JQZU5EOFFrSXRNdmxsT2JlQ3ozU1pBanFacm9ibUxjcnBGeVFWN213QmpnM0MzQzgvYmM1Z29RaHY4ai9JWE1MR250NG1GN3R5YlJERzVHMHBvbHhvVVNjUWtQdm1uZ2EyL0srYWFwS2VxU0wwQlRtbzFDbTVnK2Jvb05PdGR5S3ZhMktvZWZSVVJhQms3MTEzUUtvM3krV1R1Rkt0Z0VUSUs4SFJsdVlTOUR2bGNjaUNEdm5HOFVhSlJmWkUyc2lac2lUSHZSbU44MHhrVUlJbkhlUlpsNVJlLytBVEw2VmhLRmk4Q1ovbi9qYkZWNlQ1cForVW9wcHZzaTNxamFjVkZPSmdXV2ZkbHdWSEtQVy9USk8zbmE5aFJNOWJTMnlvMnJFc0M2SUJ6UlJlVk82SWVzSlU3UEl0ek9hbXIrUk9GZndHWm1aN3VlOEhOeEFnTEpLYjdQM3A4ZE1xazZCZTVQSmFULzVSZGMxZGVZVmloV0g5Y2pWS2M5dXo1RW5mSHF4TFVrT084aUpVRU5CTlZmNUx5Tnk4empMdS83OGs1V05UeXdpUGZZZVgzQ1BrN3ljNkNJM2x1bS9DRVp3ZlVhTnBjSTNLc1BxZm4ybG16M2tkL2FjUWpLQTFlYmtKYWl1TEQrZXBRL0ZjMWxsSFhYTXpvZld6ei9LZDI5U05tT2hjak1XdzFqcTFnM1lmclhaOXJ6WERZVzRadHRmZ2ZNaTZvQ1V0QnMwUGtNVnV4bXE1bHhFb0NhU1hQU3FDSko3TWxLZFJEaWRWdDBBRmx4azVjVGRYKytzQkYyK0UzNW1qd2ZtOEVSVnhIMEZ2dUFRdHNmQTRWMkcwVEtUVXhleVJHVmpkL3U2RjFTdnVBaVUyL1dhUWpjTkNVNEVwN1Z1blhDWVNiWmozVTN3enUvTFdNNU1QbFl1eVEzRk9PQ0QvenQ3SzI5NWhZMkpod0YrT0RESVo2NzZ2R1FGS3ZlRVFZa1dqN2xrSzdyVm1EN01oVTBZL3RGOEVjVFRwbzQveXFPdWZiZC96V0lwTWFqbmJEdVdLMnZuNk9QUHR6MnJjOU1JQk5sUGQ4dHQreWYrN1NDNHdxRVBib3pLTUN3WTVCeWd4NEptb0lFRHNpeFdSRGNkSGQ2UzMvZFpNSFhPSkFBdjcrTklzdGwwMGNyZ1NxSFpLQUVlNGczRzRkeklWNTFFZVpCMDFyN3A4R05sZlVuRy9HalpnTkdzcVhaZFlNQlZ0QXRGTnYzaEpXUHZlNEd2cVoyWHh1aU5rSFR6NWt4V2dyMFBqUWRKbFZ5d0o5WmYyWnZxZWVUYm9sS3R2SzU0cmUyTHE1Qm95emZzUnR2RGZ5YW8za215RnpEUTg4bk0rcXg4M3c3NFJEbGtuZ3RZaUFySTA1RXByZTNHZ0JlU2xNaWcwcEU2UkdRYUZ6bktrR2ViMFNvekxDeWlPdHhoN2hnd1psYktiQ2x6VVVmQzhudE1pSFVPWkUzNzVSaFR5OWM0REErb01Ma1VEa3p0U3liWmJkbVAxeHBhSWJqVXBQQUhCcTNjSXErQ0JGemJNbE1NQ0NrVVE2ZDlMR1Y2R1lDc1lpRVdaSXkzbkJudXhPWVhlVTRZVEdEU2luOWU0L3BDalB0UVNIbGc1TE1FdklsRjBFbHRocXJGMTI5aUsyUlBCRVdkM1hXT2wzU1dWNXV6NVZVeVpZcDVrRUZtejdRZlAvQjFXMUJCelEyaVRHYlNWVDc5bFVIemNHWHozUEpjZVNnejR1a25FVFV3bzB4ZmZwcjJLVXZaRjBpL3Iyc0wzSUZJQ2xZeDhDYklaRTZRdDdNREpiT1BCM3hNU2N3YU9jV0c2NklKZkNuRGtiMEQyTWIrUEh6WCtvaUNieGVUSW9ndHlOK3MyTkppck5BQ2svT0FDU09UdFY2dnNjd2J6VzRNMTY4eHFhSStSelI0N1MxbmxWL3JPb1puaWQ4N24vSW1hMlhZYTN1bjNCdUdBaXNOamI4ZUxNVDlPbk10YXpRUk9GQ3VPMUhpWlhhT2Mwb1VEYk5DNGVLTFRvT3g4RHpWaE1nR0E4WElBUTJ4M2I2STB1RXlMc3NRakpYM1FwaGNVTXg0S3NNZ0orNzJrbTROMmFxa0JGMmNvS21VRXQxZXFJTUduKzV0eE1UNGtZVkdkM0FMTyt5OVo0UFAzZDNsNDhKUUs4czlaWi9ReC8rTkJLZ0JFSkZsUTMycHNvSmlpaEdPN0ZTWU01TDgxcTcya2FBWWNpbEVGTUcrWksxQmNNcUVMa2ZseUNWN3Y4SkVYTE80UmYvb1pZTlpIWlZqSmhmTDZmbnBQOVRpbzNFdXVlNXVTN0ZNa2ZHT2VSQ1RyQlowNkNhZXY3dGd1ZmVUclgzNFVyL1Z2YytiOGtzaUlTaE5KdHVGOVdtWXhPWjR4Zzh5NnpUZHkzS0FCMnk1a1lrY1JuWHNwdFd3QUZ5S1oySS9RR3lTTmVvUUxrSU5VTWxvQys1TDNXdU1NeDI5N1ExeFVZTEtxWjlYSGF2YW9ibzZRUXY0YXVNbStpODRJaHhScFB0OW5VbWNhdjlOY2pDY1ArVGNNbXhzUVovRjNtZ2VvQTBmUWd3dlRzeVh1dVRhTTNTcXR2MmphYWFqbWFGUXBLOVc2dUliZXF3dlNEbzM0WnJZNmVsRFVId1NDakhSUm1sd215eStlT3JhNjRTc3EwWFNYWWxqTUh0S1krRlNoY01rSHNFVVkvNEJ3NjNkSjZLcHdEYXhtdGhsRGRiZEUrVHZZRjN2MzNjR1NLcU8rMUgxcEtZaEpNdlpENWNrUWNIeU5GOHpydGlSNWIwa282TlBHb1JleFVaVFlQNlZiVWRuM3p6eEdCT2k4WjBPcUhqR3FZeFJYd04zbVlpMEdZRUVaWXErUTNRdmRLY0VISUxMTGo4UytWRmVwU2ZFcnRtZlpDZHZ4YmZJaWZGU3BFektpKzdWSnNMTVQrekVGZXlwMU9kd1JDMVZacmZUTEl5Ujd4VFBVY1pGWVBEOXFJN0Q3MHVUYjRoZHBxUFhzSklSTlliWnROd2NoMU9JM3RyaDN1MlNjb1F5TTlQT25JbnNVYStPb3Zjd2tVUDFVZkl6UGI5NW40QmFGMmV2NTdOSEFlajArQlZNRjkvQ2o5NjYzSE4yL0pOM1NRZ3NsTDkxNGJLZmlUVERGQXo5UGxRRUwvZFN2MUg4eGwzbXRXeGgxTWNGTzlFSlhsUkRhS1FEc3lLTzR2T0pXOTBORkU2eXcydGpiYzJHZUY5NXNiczBJOWVuQWE2UXdRVmYva0pRaEFEMkJ6VURLZ2dPeWp5MVRFaEVENnNmays0MThsUXkzYy91ajhhdzhVRXpaNmhJTUNkOFJvaEFrdW1NdElqOW03M2wyeVBXb0dIVlRQYXl3a0M3WWo5dEJNMU54TWdjckR3UnRrNFJPMldIVDdRbDVrUUNLZEpqNmtOdU9UZXlFQllCakxNaEd6K081L1lHYTg0SEVpVFlFcFo2ZkZ6eTI2R0cyaFd0VHl0ZXVZcmhTeUc1NkJqc1Qvd1FlTFJ5dHBUWTNEN3NJTXFabko5ejFGRHJmeWpGbEdsMlROdzlCUXlzYmF4T3V3WVlacy83STZCQU5na3FDa25XWkM3L0JCWHZhZUt3QW1DOTU5SStHMzlCVUU5YkV4a05sYlJvRlJ5RXROenYrTko5MUZ1aXNHM0pDUzZ1WUJlUm5mdjhBa0FmS1RlZzlFWWFtcW5zR2ZBVjdkMGY5RGdoSEVRNUlzUEdESVVoZ29TajdvYk00QnU1dWhRMy9DWUVEVEhjOTJBc0Z2REs0WEdyd1VlR0JXQkhQbFMrZjR4K0N4bW1IejJzQUdtU0ZOdDY1a3daQzY0bW5hb1dsdTIzMTBsYVluOHI2MkFxc1I1ZGZqeUsxOE1FZHVyZGFnbGR6Zkp0akZYbFpzN1N0NFFoZFBpeWU2VFBoMi9aQVFMVS9GaXA1czdUREVNMTZLdFJXcks5aG14blE3Ym1mYS8rN3BhMTBaOFdEUEszTnVKK05OL1JBYlE1dkh4MnVYMExtNy93N2NBRUgvaHZaQSttdDdKN3pHdzdZdFFZd25OTjZkcGd3a0dqanJTM3lRb2VvWXQxRW5jem10bUpmUVpXelVsUDNIbGc5V3pscjlJSDIzcTN0aEd0aCtRTkVBTkZldHR4S2Zza2tHT2xMazhBcW9LSndEcU94QWE2VXpBeDA3cGxTU3lOQkpTR2NvOXpqbkM1Z0diRG9LdnNNRHVCUjZiR1JsR3pKK2hGc0dhL0l6dDc4YUkrV1o2ZEpsWktwNHBHSVN1djlyVjBzQVMwTVdFd0NtZmF1TzdvUVpNaWFrSFUzNUxCeGl5Sm9PTWRkaFVXZ2NadUM4cjRLc3ZuNzVUVGNRWExKN2tXdFloR3VHcVBkOWRadUZqQldRSE53b3NYWTVzbmJIRlFxNzJDdkhYaElnK3NoUXh5Y3VMT3VXWUVyd0NMWmVGMjRiN0Y3OHBPN3h3NFg2bElBUjAyaFVPZjUwODdSbDBuT2FlYjZDSzRpL0tBL0Vadjc2ZnRPV1p0and4c2xOcjBFL3U4cldVbW5mM2FtZmc2VVptQkFsdXVvajNEZDdVVis5SUFKNmlZY0RmU0psZ21JSW1vaGpmSVVNSjI3eitvcGo1MEFrOWFmMkxDTnJXckJKdk1vdkExT2VOTytNRi9Nd1p2bmFDeFRnRzdDdzRRZlNQRjZBWUNHRnQyMU04UHlTWkZlVjN0MlJxcXM1Sk16TVl6R1JncTRvK1VhS1JnQmY5R0hpLzlYOUhYQTN3eGtDc2QvVWhuSFNoMnpVVkRpcmFpby82blA0eTNYSnFzOEFCZkFMQXRDWVU3REhQTVBSamdjTTZBZC9IaVNYREFiT2RTTWt2R1pQQWtIczh3dVFUeTZYMk92L0pGdmNQdUtmVjMvcjlRMjgnO1xuY29uc3QgRkVOQ0VEID0gbmV3IE1hcChbWzgyMTcsXCJhcG9zdHJvcGhlXCJdLFs4MjYwLFwiZnJhY3Rpb24gc2xhc2hcIl0sWzEyNTM5LFwibWlkZGxlIGRvdFwiXV0pO1xuY29uc3QgTlNNX01BWCA9IDQ7XG5cbmZ1bmN0aW9uIGRlY29kZV9hcml0aG1ldGljKGJ5dGVzKSB7XHJcblx0bGV0IHBvcyA9IDA7XHJcblx0ZnVuY3Rpb24gdTE2KCkgeyByZXR1cm4gKGJ5dGVzW3BvcysrXSA8PCA4KSB8IGJ5dGVzW3BvcysrXTsgfVxyXG5cdFxyXG5cdC8vIGRlY29kZSB0aGUgZnJlcXVlbmN5IHRhYmxlXHJcblx0bGV0IHN5bWJvbF9jb3VudCA9IHUxNigpO1xyXG5cdGxldCB0b3RhbCA9IDE7XHJcblx0bGV0IGFjYyA9IFswLCAxXTsgLy8gZmlyc3Qgc3ltYm9sIGhhcyBmcmVxdWVuY3kgMVxyXG5cdGZvciAobGV0IGkgPSAxOyBpIDwgc3ltYm9sX2NvdW50OyBpKyspIHtcclxuXHRcdGFjYy5wdXNoKHRvdGFsICs9IHUxNigpKTtcclxuXHR9XHJcblxyXG5cdC8vIHNraXAgdGhlIHNpemVkLXBheWxvYWQgdGhhdCB0aGUgbGFzdCAzIHN5bWJvbHMgaW5kZXggaW50b1xyXG5cdGxldCBza2lwID0gdTE2KCk7XHJcblx0bGV0IHBvc19wYXlsb2FkID0gcG9zO1xyXG5cdHBvcyArPSBza2lwO1xyXG5cclxuXHRsZXQgcmVhZF93aWR0aCA9IDA7XHJcblx0bGV0IHJlYWRfYnVmZmVyID0gMDsgXHJcblx0ZnVuY3Rpb24gcmVhZF9iaXQoKSB7XHJcblx0XHRpZiAocmVhZF93aWR0aCA9PSAwKSB7XHJcblx0XHRcdC8vIHRoaXMgd2lsbCByZWFkIGJleW9uZCBlbmQgb2YgYnVmZmVyXHJcblx0XHRcdC8vIGJ1dCAodW5kZWZpbmVkfDApID0+IHplcm8gcGFkXHJcblx0XHRcdHJlYWRfYnVmZmVyID0gKHJlYWRfYnVmZmVyIDw8IDgpIHwgYnl0ZXNbcG9zKytdO1xyXG5cdFx0XHRyZWFkX3dpZHRoID0gODtcclxuXHRcdH1cclxuXHRcdHJldHVybiAocmVhZF9idWZmZXIgPj4gLS1yZWFkX3dpZHRoKSAmIDE7XHJcblx0fVxyXG5cclxuXHRjb25zdCBOID0gMzE7XHJcblx0Y29uc3QgRlVMTCA9IDIqKk47XHJcblx0Y29uc3QgSEFMRiA9IEZVTEwgPj4+IDE7XHJcblx0Y29uc3QgUVJUUiA9IEhBTEYgPj4gMTtcclxuXHRjb25zdCBNQVNLID0gRlVMTCAtIDE7XHJcblxyXG5cdC8vIGZpbGwgcmVnaXN0ZXJcclxuXHRsZXQgcmVnaXN0ZXIgPSAwO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgTjsgaSsrKSByZWdpc3RlciA9IChyZWdpc3RlciA8PCAxKSB8IHJlYWRfYml0KCk7XHJcblxyXG5cdGxldCBzeW1ib2xzID0gW107XHJcblx0bGV0IGxvdyA9IDA7XHJcblx0bGV0IHJhbmdlID0gRlVMTDsgLy8gdHJlYXQgbGlrZSBhIGZsb2F0XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB2YWx1ZSA9IE1hdGguZmxvb3IoKCgocmVnaXN0ZXIgLSBsb3cgKyAxKSAqIHRvdGFsKSAtIDEpIC8gcmFuZ2UpO1xyXG5cdFx0bGV0IHN0YXJ0ID0gMDtcclxuXHRcdGxldCBlbmQgPSBzeW1ib2xfY291bnQ7XHJcblx0XHR3aGlsZSAoZW5kIC0gc3RhcnQgPiAxKSB7IC8vIGJpbmFyeSBzZWFyY2hcclxuXHRcdFx0bGV0IG1pZCA9IChzdGFydCArIGVuZCkgPj4+IDE7XHJcblx0XHRcdGlmICh2YWx1ZSA8IGFjY1ttaWRdKSB7XHJcblx0XHRcdFx0ZW5kID0gbWlkO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0YXJ0ID0gbWlkO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAoc3RhcnQgPT0gMCkgYnJlYWs7IC8vIGZpcnN0IHN5bWJvbCBpcyBlbmQgbWFya1xyXG5cdFx0c3ltYm9scy5wdXNoKHN0YXJ0KTtcclxuXHRcdGxldCBhID0gbG93ICsgTWF0aC5mbG9vcihyYW5nZSAqIGFjY1tzdGFydF0gICAvIHRvdGFsKTtcclxuXHRcdGxldCBiID0gbG93ICsgTWF0aC5mbG9vcihyYW5nZSAqIGFjY1tzdGFydCsxXSAvIHRvdGFsKSAtIDE7XHJcblx0XHR3aGlsZSAoKChhIF4gYikgJiBIQUxGKSA9PSAwKSB7XHJcblx0XHRcdHJlZ2lzdGVyID0gKHJlZ2lzdGVyIDw8IDEpICYgTUFTSyB8IHJlYWRfYml0KCk7XHJcblx0XHRcdGEgPSAoYSA8PCAxKSAmIE1BU0s7XHJcblx0XHRcdGIgPSAoYiA8PCAxKSAmIE1BU0sgfCAxO1xyXG5cdFx0fVxyXG5cdFx0d2hpbGUgKGEgJiB+YiAmIFFSVFIpIHtcclxuXHRcdFx0cmVnaXN0ZXIgPSAocmVnaXN0ZXIgJiBIQUxGKSB8ICgocmVnaXN0ZXIgPDwgMSkgJiAoTUFTSyA+Pj4gMSkpIHwgcmVhZF9iaXQoKTtcclxuXHRcdFx0YSA9IChhIDw8IDEpIF4gSEFMRjtcclxuXHRcdFx0YiA9ICgoYiBeIEhBTEYpIDw8IDEpIHwgSEFMRiB8IDE7XHJcblx0XHR9XHJcblx0XHRsb3cgPSBhO1xyXG5cdFx0cmFuZ2UgPSAxICsgYiAtIGE7XHJcblx0fVxyXG5cdGxldCBvZmZzZXQgPSBzeW1ib2xfY291bnQgLSA0O1xyXG5cdHJldHVybiBzeW1ib2xzLm1hcCh4ID0+IHsgLy8gaW5kZXggaW50byBwYXlsb2FkXHJcblx0XHRzd2l0Y2ggKHggLSBvZmZzZXQpIHtcclxuXHRcdFx0Y2FzZSAzOiByZXR1cm4gb2Zmc2V0ICsgMHgxMDEwMCArICgoYnl0ZXNbcG9zX3BheWxvYWQrK10gPDwgMTYpIHwgKGJ5dGVzW3Bvc19wYXlsb2FkKytdIDw8IDgpIHwgYnl0ZXNbcG9zX3BheWxvYWQrK10pO1xyXG5cdFx0XHRjYXNlIDI6IHJldHVybiBvZmZzZXQgKyAweDEwMCArICgoYnl0ZXNbcG9zX3BheWxvYWQrK10gPDwgOCkgfCBieXRlc1twb3NfcGF5bG9hZCsrXSk7XHJcblx0XHRcdGNhc2UgMTogcmV0dXJuIG9mZnNldCArIGJ5dGVzW3Bvc19wYXlsb2FkKytdO1xyXG5cdFx0XHRkZWZhdWx0OiByZXR1cm4geCAtIDE7XHJcblx0XHR9XHJcblx0fSk7XHJcbn1cdFxyXG5cclxuLy8gcmV0dXJucyBhbiBpdGVyYXRvciB3aGljaCByZXR1cm5zIHRoZSBuZXh0IHN5bWJvbFxyXG5mdW5jdGlvbiByZWFkX3BheWxvYWQodikge1xyXG5cdGxldCBwb3MgPSAwO1xyXG5cdHJldHVybiAoKSA9PiB2W3BvcysrXTtcclxufVxyXG5mdW5jdGlvbiByZWFkX2NvbXByZXNzZWRfcGF5bG9hZChzKSB7XHJcblx0cmV0dXJuIHJlYWRfcGF5bG9hZChkZWNvZGVfYXJpdGhtZXRpYyh1bnNhZmVfYXRvYihzKSkpO1xyXG59XHJcblxyXG4vLyB1bnNhZmUgaW4gdGhlIHNlbnNlOlxyXG4vLyBleHBlY3RlZCB3ZWxsLWZvcm1lZCBCYXNlNjQgdy9vIHBhZGRpbmcgXHJcbi8vIDIwMjIwOTIyOiBhZGRlZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcy9pc3N1ZXMvNFxyXG5mdW5jdGlvbiB1bnNhZmVfYXRvYihzKSB7XHJcblx0bGV0IGxvb2t1cCA9IFtdO1xyXG5cdFsuLi4nQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyddLmZvckVhY2goKGMsIGkpID0+IGxvb2t1cFtjLmNoYXJDb2RlQXQoMCldID0gaSk7XHJcblx0bGV0IG4gPSBzLmxlbmd0aDtcclxuXHRsZXQgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoKDYgKiBuKSA+PiAzKTtcclxuXHRmb3IgKGxldCBpID0gMCwgcG9zID0gMCwgd2lkdGggPSAwLCBjYXJyeSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdGNhcnJ5ID0gKGNhcnJ5IDw8IDYpIHwgbG9va3VwW3MuY2hhckNvZGVBdChpKV07XHJcblx0XHR3aWR0aCArPSA2O1xyXG5cdFx0aWYgKHdpZHRoID49IDgpIHtcclxuXHRcdFx0cmV0W3BvcysrXSA9IChjYXJyeSA+PiAod2lkdGggLT0gOCkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG4vLyBlZy4gWzAsMSwyLDMuLi5dID0+IFswLC0xLDEsLTIsLi4uXVxyXG5mdW5jdGlvbiBzaWduZWQoaSkgeyBcclxuXHRyZXR1cm4gKGkgJiAxKSA/ICh+aSA+PiAxKSA6IChpID4+IDEpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkX2RlbHRhcyhuLCBuZXh0KSB7XHJcblx0bGV0IHYgPSBBcnJheShuKTtcclxuXHRmb3IgKGxldCBpID0gMCwgeCA9IDA7IGkgPCBuOyBpKyspIHZbaV0gPSB4ICs9IHNpZ25lZChuZXh0KCkpO1xyXG5cdHJldHVybiB2O1xyXG59XHJcblxyXG4vLyBbMTIzXVs1XSA9PiBbMCAzXSBbMSAxXSBbMCAwXVxyXG5mdW5jdGlvbiByZWFkX3NvcnRlZChuZXh0LCBwcmV2ID0gMCkge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHggPSBuZXh0KCk7XHJcblx0XHRsZXQgbiA9IG5leHQoKTtcclxuXHRcdGlmICghbikgYnJlYWs7XHJcblx0XHRwcmV2ICs9IHg7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0XHRyZXQucHVzaChwcmV2ICsgaSk7XHJcblx0XHR9XHJcblx0XHRwcmV2ICs9IG4gKyAxO1xyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkX3NvcnRlZF9hcnJheXMobmV4dCkge1xyXG5cdHJldHVybiByZWFkX2FycmF5X3doaWxlKCgpID0+IHsgXHJcblx0XHRsZXQgdiA9IHJlYWRfc29ydGVkKG5leHQpO1xyXG5cdFx0aWYgKHYubGVuZ3RoKSByZXR1cm4gdjtcclxuXHR9KTtcclxufVxyXG5cclxuLy8gcmV0dXJucyBtYXAgb2YgeCA9PiB5c1xyXG5mdW5jdGlvbiByZWFkX21hcHBlZChuZXh0KSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgdyA9IG5leHQoKTtcclxuXHRcdGlmICh3ID09IDApIGJyZWFrO1xyXG5cdFx0cmV0LnB1c2gocmVhZF9saW5lYXJfdGFibGUodywgbmV4dCkpO1xyXG5cdH1cclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHcgPSBuZXh0KCkgLSAxO1xyXG5cdFx0aWYgKHcgPCAwKSBicmVhaztcclxuXHRcdHJldC5wdXNoKHJlYWRfcmVwbGFjZW1lbnRfdGFibGUodywgbmV4dCkpO1xyXG5cdH1cclxuXHRyZXR1cm4gcmV0LmZsYXQoKTtcclxufVxyXG5cclxuLy8gcmVhZCB1bnRpbCBuZXh0IGlzIGZhbHN5XHJcbi8vIHJldHVybiBhcnJheSBvZiByZWFkIHZhbHVlc1xyXG5mdW5jdGlvbiByZWFkX2FycmF5X3doaWxlKG5leHQpIHtcclxuXHRsZXQgdiA9IFtdO1xyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgeCA9IG5leHQodi5sZW5ndGgpO1xyXG5cdFx0aWYgKCF4KSBicmVhaztcclxuXHRcdHYucHVzaCh4KTtcclxuXHR9XHJcblx0cmV0dXJuIHY7XHJcbn1cclxuXHJcbi8vIHJlYWQgdyBjb2x1bW5zIG9mIGxlbmd0aCBuXHJcbi8vIHJldHVybiBhcyBuIHJvd3Mgb2YgbGVuZ3RoIHdcclxuZnVuY3Rpb24gcmVhZF90cmFuc3Bvc2VkKG4sIHcsIG5leHQpIHtcclxuXHRsZXQgbSA9IEFycmF5KG4pLmZpbGwoKS5tYXAoKCkgPT4gW10pO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgdzsgaSsrKSB7XHJcblx0XHRyZWFkX2RlbHRhcyhuLCBuZXh0KS5mb3JFYWNoKCh4LCBqKSA9PiBtW2pdLnB1c2goeCkpO1xyXG5cdH1cclxuXHRyZXR1cm4gbTtcclxufVxyXG4gXHJcbi8vIHJldHVybnMgW1t4LCB5c10sIFt4K2R4LCB5cytkeV0sIFt4KzIqZHgsIHlzKzIqZHldLCAuLi5dXHJcbi8vIHdoZXJlIGR4L2R5ID0gc3RlcHMsIG4gPSBydW4gc2l6ZSwgdyA9IGxlbmd0aCBvZiB5XHJcbmZ1bmN0aW9uIHJlYWRfbGluZWFyX3RhYmxlKHcsIG5leHQpIHtcclxuXHRsZXQgZHggPSAxICsgbmV4dCgpO1xyXG5cdGxldCBkeSA9IG5leHQoKTtcclxuXHRsZXQgdk4gPSByZWFkX2FycmF5X3doaWxlKG5leHQpO1xyXG5cdGxldCBtID0gcmVhZF90cmFuc3Bvc2VkKHZOLmxlbmd0aCwgMSt3LCBuZXh0KTtcclxuXHRyZXR1cm4gbS5mbGF0TWFwKCh2LCBpKSA9PiB7XHJcblx0XHRsZXQgW3gsIC4uLnlzXSA9IHY7XHJcblx0XHRyZXR1cm4gQXJyYXkodk5baV0pLmZpbGwoKS5tYXAoKF8sIGopID0+IHtcclxuXHRcdFx0bGV0IGpfZHkgPSBqICogZHk7XHJcblx0XHRcdHJldHVybiBbeCArIGogKiBkeCwgeXMubWFwKHkgPT4geSArIGpfZHkpXTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG59XHJcblxyXG4vLyByZXR1cm4gW1t4LCB5cy4uLl0sIC4uLl1cclxuLy8gd2hlcmUgdyA9IGxlbmd0aCBvZiB5XHJcbmZ1bmN0aW9uIHJlYWRfcmVwbGFjZW1lbnRfdGFibGUodywgbmV4dCkgeyBcclxuXHRsZXQgbiA9IDEgKyBuZXh0KCk7XHJcblx0bGV0IG0gPSByZWFkX3RyYW5zcG9zZWQobiwgMSt3LCBuZXh0KTtcclxuXHRyZXR1cm4gbS5tYXAodiA9PiBbdlswXSwgdi5zbGljZSgxKV0pO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gcmVhZF90cmllKG5leHQpIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0bGV0IHNvcnRlZCA9IHJlYWRfc29ydGVkKG5leHQpOyBcclxuXHRleHBhbmQoZGVjb2RlKFtdKSwgW10pO1xyXG5cdHJldHVybiByZXQ7IC8vIG5vdCBzb3J0ZWRcclxuXHRmdW5jdGlvbiBkZWNvZGUoUSkgeyAvLyBjaGFyYWN0ZXJzIHRoYXQgbGVhZCBpbnRvIHRoaXMgbm9kZVxyXG5cdFx0bGV0IFMgPSBuZXh0KCk7IC8vIHN0YXRlOiB2YWxpZCwgc2F2ZSwgY2hlY2tcclxuXHRcdGxldCBCID0gcmVhZF9hcnJheV93aGlsZSgoKSA9PiB7IC8vIGJ1Y2tldHMgbGVhZGluZyB0byBuZXcgbm9kZXNcclxuXHRcdFx0bGV0IGNwcyA9IHJlYWRfc29ydGVkKG5leHQpLm1hcChpID0+IHNvcnRlZFtpXSk7XHJcblx0XHRcdGlmIChjcHMubGVuZ3RoKSByZXR1cm4gZGVjb2RlKGNwcyk7XHJcblx0XHR9KTtcclxuXHRcdHJldHVybiB7UywgQiwgUX07XHJcblx0fVxyXG5cdGZ1bmN0aW9uIGV4cGFuZCh7UywgQn0sIGNwcywgc2F2ZWQpIHtcclxuXHRcdGlmIChTICYgNCAmJiBzYXZlZCA9PT0gY3BzW2Nwcy5sZW5ndGgtMV0pIHJldHVybjtcclxuXHRcdGlmIChTICYgMikgc2F2ZWQgPSBjcHNbY3BzLmxlbmd0aC0xXTtcclxuXHRcdGlmIChTICYgMSkgcmV0LnB1c2goY3BzKTsgXHJcblx0XHRmb3IgKGxldCBiciBvZiBCKSB7XHJcblx0XHRcdGZvciAobGV0IGNwIG9mIGJyLlEpIHtcclxuXHRcdFx0XHRleHBhbmQoYnIsIFsuLi5jcHMsIGNwXSwgc2F2ZWQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59XG5cbmZ1bmN0aW9uIGhleF9jcChjcCkge1xyXG5cdHJldHVybiBjcC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKS5wYWRTdGFydCgyLCAnMCcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBxdW90ZV9jcChjcCkge1xyXG5cdHJldHVybiBgeyR7aGV4X2NwKGNwKX19YDsgLy8gcmFmZnkgY29udmVudGlvbjogbGlrZSBcIlxcdXtYfVwiIHcvbyB0aGUgXCJcXHVcIlxyXG59XHJcblxyXG4vKlxyXG5leHBvcnQgZnVuY3Rpb24gZXhwbG9kZV9jcChzKSB7XHJcblx0cmV0dXJuIFsuLi5zXS5tYXAoYyA9PiBjLmNvZGVQb2ludEF0KDApKTtcclxufVxyXG4qL1xyXG5mdW5jdGlvbiBleHBsb2RlX2NwKHMpIHsgLy8gdGhpcyBpcyBhYm91dCAyeCBmYXN0ZXJcclxuXHRsZXQgY3BzID0gW107XHJcblx0Zm9yIChsZXQgcG9zID0gMCwgbGVuID0gcy5sZW5ndGg7IHBvcyA8IGxlbjsgKSB7XHJcblx0XHRsZXQgY3AgPSBzLmNvZGVQb2ludEF0KHBvcyk7XHJcblx0XHRwb3MgKz0gY3AgPCAweDEwMDAwID8gMSA6IDI7XHJcblx0XHRjcHMucHVzaChjcCk7XHJcblx0fVxyXG5cdHJldHVybiBjcHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0cl9mcm9tX2NwcyhjcHMpIHtcclxuXHRjb25zdCBjaHVuayA9IDQwOTY7XHJcblx0bGV0IGxlbiA9IGNwcy5sZW5ndGg7XHJcblx0aWYgKGxlbiA8IGNodW5rKSByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY3BzKTtcclxuXHRsZXQgYnVmID0gW107XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICkge1xyXG5cdFx0YnVmLnB1c2goU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY3BzLnNsaWNlKGksIGkgKz0gY2h1bmspKSk7XHJcblx0fVxyXG5cdHJldHVybiBidWYuam9pbignJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBhcmVfYXJyYXlzKGEsIGIpIHtcclxuXHRsZXQgbiA9IGEubGVuZ3RoO1xyXG5cdGxldCBjID0gbiAtIGIubGVuZ3RoO1xyXG5cdGZvciAobGV0IGkgPSAwOyBjID09IDAgJiYgaSA8IG47IGkrKykgYyA9IGFbaV0gLSBiW2ldO1xyXG5cdHJldHVybiBjO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhcnJheV9yZXBsYWNlKHYsIGEsIGIpIHtcclxuXHRsZXQgcHJldiA9IDA7XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCBuZXh0ID0gdi5pbmRleE9mKGEsIHByZXYpO1xyXG5cdFx0aWYgKG5leHQgPCAwKSBicmVhaztcclxuXHRcdHZbbmV4dF0gPSBiOyBcclxuXHRcdHByZXYgPSBuZXh0ICsgMTtcclxuXHR9XHJcbn1cblxuLy8gY3JlYXRlZCAyMDI0LTA5LTEzVDA2OjQyOjQ1LjY3NVpcbi8vIGNvbXByZXNzZWQgYmFzZTY0LWVuY29kZWQgYmxvYiBmb3IgaW5jbHVkZS1uZiBkYXRhXG4vLyBzb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMvYmxvYi9tYWluL3NyYy9tYWtlLmpzXG4vLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMjc2VjdXJpdHlcbi8vIFNIQS0yNTY6IGE3OWQ1ZjliMTg3OWE3YjQxNmFhNjU5ZjRhM2Q3ODhmODBhOGNmNWYwYWI5NTVhNDU2NTkyYzAyZjU1NmEyOGNcbnZhciBDT01QUkVTU0VEID0gJ0FFVURWZ0hMQ0dNQVR3RFVBRElBZEFBaEFEUUFGQUF0QUJRQUlRQVBBQ2NBRFFBU0FBb0FHQUFKQUJJQUNRQVJBQVVBQ3dBRkFBd0FCUUFRQUFNQUJ3QUVBQW9BQlFBSkFBSUFDZ0FCQUFRQUZBQUxBQUlBQ3dBQkFBSUFBUUFIQUFNQUF3QUVBQXNBREFBTUFBd0FDd0FOQUEwQUF3QUtBQWtBQkFBZEFBWUFad0RUQWVZRE13Q3hDbDhCOHhoWkFxZm9DMTkwVUdjVGhnQnVyd2Y3UFQwOVBiMDlBamdKdW04T2pEbGx4SFlVS1hBUHh6cTZ0QUJBeGdLOHlzVXZXQWdNUFQwOVBUMDlQU3M2TFQySGNnV1hXd0ZMb1NNRUVFbDVSRlZNS3ZPMFhROEV4RGRKTW5JZ1BpODl1ajAwTXN2Qlh4RVBBR1BDRHdCblFLb0Vid1J3QkhFRWNnUnpCSFFFZFFSMkJIY0VlQVI2QkhzRWZBUitCSUFFZ2ZuZEJRb0JZZ1VMQVdJRkRBRmlCTmNFMkFUWkJSQUZFUVV2QmRBTEZBc1ZEUGNOQncxM0RZY09NQTR4RGpNQjRCbGxISTBCMmdyYkFNRHBITGtRN1FIVkFQUk5RUUZuR1JVRWcweUVCMnVhSkY4QUpwSUJwb2I1QUVSU01BS05vQVhxYVFMVUJNQ3pFaUMrQVo0RVdSSkpGYkV1N1FEUUxBUnRFYmdFQ3hEd0FiL1J5QWsxQVY0bkQyY0VRUUtUQXpzQUdwb2JXZ0FhaEFHUENyeXNkeTBPQUt3QWZGSWNCQVFGVW1vQS9QdFpBRGtCSWFkVmoyVU1VZ3g1SWw0QU5RQzl2QUlUQWRRWld4RHpBTE45QWhzWlZ3SWNHU2tDQkFnWE9oRzdBcU1aNE03KzFNMFVBUEROQVdzQyttY0pEZThBQVFBOTl6a0VYTElDeVFvekFvNmxBb2JjUDVKdmpRTEZ6d0tEOWdVL09EOEZFUUN0RVFMNmJXK25BS1VFdnpqREhzdVJ5VXZPRkhjYWNVejVBcUlGUlNFMmt6c0JFUUN1YVFMNURRVGxjZ082dHdTcFRpVWdDd0lGQ0FVWEJIUUVxUVY2c3dBVnhVbG1UbXNDd2pxc1Avd0tKUW1YYjc5M1VnWkJFQnNucFJEM0RETUJ0UUU3RGUxTDJBVHhCanNFeVI5OUdSa1B6WldjQ0tVdDNRenRKdU11b1lCYUkvVXFnd1h0Uy9RODNRdE5VV2dQV1F0bENlTTZZNEZPQXlFQkRTS0xDdDBOT1FodEVQTUt5V3NONVJGRkJ6a0QxVW1hQUtVSEFRc1JIVFVWdFNZUVlxd0xDVGwzQnZzYTlndVBKcThUS1hyOEJkTWFJUVpOQVNrYS93RFBMdWVGc0ZveFhCeFBYd1lEQ3lVanh4U29VQ0FOSlVDM2VFZ2FHd2NWSmFrQ2tVTndTb2RSTmg2VElmWThQUTFtTGhOUmZBZjFQQVVaVHd1QlBKNUdxMFVPRWRJK2pUMUlJa2xNTEFRMWZ5d3ZKNHNKencrRkRMbDhjZ0ZaQ1NFSnNReHhFekVSRnpmRkNEa0hHUzJYSkNjVkNDRkdsV0NhQlBlZkEvTVQwUU1MQlQ4SlFRY1RBN1VjTFJNdUZTa0ZEWUVrMXdMek50VXVzd0tQVm9BQkZ3WExEeVVmM3hCUVIrQU82UWliQW1VRGd5WHJBQzBWSVFBWElwc0lRMk1BWDQvWVV3VXV5d2pIYW13amRBTm5GT2RoRVhNSGtRNVhCNmNjTXhXL0hPRnd5RjRMaGdnb282OEpXd0YxQ1prQlh3VGpDQWsxVzR5Z0lFRm5VNHRZR0pzZ1lVRS9YZndDTVF4bEZaOUV2WWQ0QW9zUGF4SWJBVFVCY3djNURRRUNkeEh0RVdzUWxRanJoZ1ExdFRQNE9pVUVUeUdESUJFS0p3TlBiTTRMSnliNURQaHBBYU1TWWdNTU5EMTM3bWVyWUxZa0YvMEhHVExGUVdBaDhRdVNUODBNbkJyQkdFSlVMaG5rQjc4RDh4cnpKK3BCVndYL0E2TURFenBOTSs0RXZRdHBDSXNKUHdCSkRxTVhCOWNZYWdweGpOQUJNWXNCdDVrRFY1R0RBbStQQmpjSEN3Qm5DNGNGZWVVQUhRS25DS01BQlFEUEExY0FPUUt0QjUwQUdRQ0ZRUUU5QXljdkFTSGxBbzhEa3dneHl3R1ZMd0h6S1FRYnd3d1ZBUGMzYmtvQ3c3RUNnR3Btb2dYZFdBS09Ba2sxQVUwbEJBVk9SMUVEcjNIaEFOc0FTd1lUMzBjQkZhdEt5eHJqUXdIZmJ5c0F4d0Q3QUFVMUJ3VkJBYzBCODIwQXR3RmZDekVKb3JPMUFVM3BLUUNEQUJWckFkY0NpUURkQURVQWYvRUJVd0JOQlZuNUJkTUNUMGtCRVRFWUsxZGhBYnNESHdFekFRMEFlUWJMamFYSkJ4OEViUWZUQWhBYkZlRUM3eTRIdFFFREl0OFR6VUxGQXIzZVZhRmdBbVNCQW1KQ1cwMnZXemNnQXFIM0FtaVlBbVlKQXArRU9Cc0xBbVk3QW1ZbUJHNEVmd04vRXdOK2tqa0dPWGNYT1lJNkl5TUNiQjBDTWpZNENnSnR4d0p0cnUrS00yZEZLd0ZuQU40QTRRQktCUWVZREkwQS9ndkNBQTIxQW5jdkFuYWlQd0o1UzBNQ2VMb2RYTnRGcmtiWEFudy9BbnJJQW4wSkFuendCVmtGSUVnQVNIMWpKQUtCYlFLQUFBS0FCUUovcmtsWVNsc1ZGMHJNQXRFQkF0RE1TeWNEaUU4RGgrWkV4WkV5QXZLaFhRTURBNjVMemt3dEpRUFBUVXhOcndLTFB3S0syTUViQngxRFp3VzNBbzQzQW81Y1FKZUJBbzdaQW81Y2VGRzBVelVLVXRSVWhRS1Qrd0tUREFEcEFCeFZIbFd2VmRBR0xCc3BsWVl5NFhobVJUczVBcGVmQXUreVdDR29BRmtsQXBhUEFwWjhuQUNwV2F4YUNZRk5BRHNDbHJVQ2xrNWNSRnpSQXBuTEFwbGtYTXBkQnhrQ25KczV3anFkQXB3V0FwK2JBcDY0aWdBZER6RXFEd0tkOFFLZWtnQzFQV0UwWWU4Q250TUNvRzRCcVFLZW54OENuazZsWThoa0p5VXJBaWV2QWlaK0FxRDdBcUJNQXFMZEFxSEVBcVl2QXFYT0FxZi9BSDBDcC9Kb2ZHaXhBQU5KYWh4cTBRS3M0d0tzcmdLdFp3S3RBZ0pYSFFKVjNBS3g0ZGNESDA1c2x3S3l2UTBDc3VnWGJPQnRZMjFJWHdNbHpRSzJYRHMvYnBBREtVVUN1RjRDdVVjVkFya3FkM0EyY09FQ3ZSa0N1OXB3bGdNeUVRSytpSElDQXpOeEFyNGFjeUp6VHdMRHl3TERCSE9DZEVzMVJYVGdBenluQXp5YUF6Mi9Bc1Y4QXNaSEFzWVFpUUxJYVZFQ3lFUUN5VThDeVM0Q1pKMEMzZEo0ZVdGNHJua2xTOUFER0tObkFnSmg5Qm56bFNSN0MxNlNYcnNSQXM5ckFzOXNMMHRUMHZNVG53REdyUUxQY3dFcDZnTk9FbjVMQlFMY0p3TGJpZ0xTVHdOU1hBTlRYd0VCQTFXTWdJay9BTXNXN1dCRmdoeUMwNExPZzQwQzJzY0MyZDZFRUlSSnB6d0RocVVBTHdOa0RvWnhXZmtBVlFMZlpRTGV1SE4zQXVJdjdSUUI4ekFuQWZTYkFmTFNod0xyOHdMcGNIa0M2dmtDNnVRQStVY0J1UUx1aVFMcm5KYXFsd01DN2o4RGhlQ1llWERnY2FFQzh3TUFhUU9PRnBtVEF2Y1RBNUZ1QTVLSEF2ZVlBdm5aQXZobW1oeWFxN3MzbXg0RG5ZTUMvdm9CR3dBNW54eWZzd01GalFPbWFnT20yUURSeFFNR2FxR0lvZ1VKQXd4SkF0UUFQd01BNFVFWFV3RVI4d05yQjVkbkJRQ1RMU3UzcjczYkFZbVpGSDhSQkRrQit5a0ZJUTZkQ1o4QWt2MFR0UlFyeFFMM0xTY0FwUUMzQmJtT2tSYy94cWR0UVM0VUpvMHVBVU1CZ1B3QnRTWUFkUU1PQkcwQUxBSVdES0VBQUFvQ1BRSnFBOTBEZmdTUkFTQkZCU0Y4Q2dBRkFFUUFFd0EyRWdKM0FRQUYxUU5yN3dyRkFnRDNDcDhudjdHMzVRR1JJVUZDQWVrVWZ4RTB3SWtBQkFBYkFGb0NSUUtFaXdBR09sTTZsSTF0QUxnNmp6clFBSTA0d1RyY0FLVUE2QURMQVRxQk9qczUvRG41TzNhSk9sczdub2s2YnprWUFWWUJNd0ZzQlM4MVhUV2VOYTAxWmpWMU5iWTF4VFdDTlpFMTBqWGhOWjQxclRYdU5mMDFzalhCTmdJMkVUWEdOZFUyRmpZbk5kNDE3VFl1TmowMkxqVXRJVFk2TmowMlBEYkpOd2dFa0R4WE5qZzIzVGNnTnc4MnlpQTNpVGN3Q2dTd1BHYzJKRGNaTjJ3NmpUY2hRdFJEQjBMZ1F3c2NEdzhKbXlodEtGRlZCZ0RwZndEcHNBRCtteFE5MXdMcE5TTUFyUUM5QmJlT2tSZEx4cHR6Qkw4TURBTU1BUWdEQUFrS0N3c0xDUW9HQkFWVkJJL0R2d0R6OWIyOWthVUNiMFF0c1JUTkx0NGVHQmNTSEFNWkZoWVpFaFlFQVJBRUJVRWNRUnhCSEVFY1FSeEJIRUVhUVJ4QkhFRkNTVHhCUEVsSVNVaEJOa00yUVRZYk5rbElTVm1CVklnRUxnRWFKWmtDN2FNQW9RQ2pCY0dPbXhkTnhyc0J2d0dKQWFRY0VaMGVQQ2tsTUFBaE12QUlNQUw1NGdDN0JtOEVlc2NqelFNcEFSUXBLZ0RVSHFTdkFqNUdxd3I3WXJNVUFDVDlBTjNybHIzSkc5bTh3OWxJQVhsdHAvdjhrZldhSWFhUjlPd3BBRVMvSTNaVmFtRFhTZ0IvVXNPZ0FHNkQwdHErNUNJcUUxNUZpQWhWM3lBMlZoQ1E3dGorbTZ4WGFGNTNGSWZHaS9JQVpJc2tNR0FpMk1VN01EVkpOQ2JNekVSeUhaaStvc2RQdG5GVmJ2cTY1M084cndhQ3k0SUFmOU9Pb2s2NUFxSlV0VXJpVWZZc0dQUFZiZTZqbTBzOWxiS2xQQ1VLamRrSHNGc0Vodlg0a1QzOVpDdEFBYndRZG4vaDRUcE81aFRCeVdBbXI1bitXdXdoZGVndjZibXZYNEx5T2VzM3oyK2N1SHYySkZZd1ZNTnVxMmd6bjhZSFRqbFVRZDM5b3N5V2VpNE5LbDNMQWRmeGxPODc2aGg1RU5wL2NPdnB1STliRjU1Z3VFdGhMTFBPWGpENGRrdFRIMDRQNVR2WnJXVE0wZTQrQkhKeGo3TUxBcFhJRk9zMHNXS2hOa0c4aXd1TTV3UjgzbXk2VjN3VzA2YWJoRHpUWFlmT3IvWnBGWGdYem12NGQxMkZGeVAwMC9kUEdiSVZHVjVhbzhVdWZHelV3cC9JSHg2di93RFdKcjlpYW9DdWxoV3dsWjdBOHEvTk1vRDEyK21CZE5SZ0pZblRoUkx0TXgxQmd3dHRuOC80UW4yQ0RmT1N1cDlHVlhFdkEyMUlMZ3Awb3dIWXhOT2twd0xXejBHN0srV1JFSURqSXpVelNuOEk5OUN1SlNtU3BQeUgwS2U2L05FUllpTngrM2RuY1NlYlBuT1VubldENjFBaEoxbi90U0xabVU1d1lPNUdmZ3p5QVlKbTZWTDkxTHhaOGhMMWxmeGltUXhJRE1SaEllY1FaQm1lRTVSMFhscnB2d3BsVnJKd3BhOEJCQ2RwOTNHUFA5bHlCZVoyemtScjkyMENSM2NZYktwS0hmb2d2bTBuVjdYZER6NkVianpseEFEQ01qU0xYdVhwSXB5dWl6eTM5eVkrSStIOXJtcG9JRjNZd0VqbEg5TWdHZ1djQ05UakhFV01xQWJwcm4yT3g3ck9IdXBhVkUzbE55ZzNudDVYYVpJRDZZK3VtbDVKYSthT1B1K0JJK0RaYmlKVmZhc3BVYWRha1dVWDZUQTRkRVRrSXFkSkpIWW5VNFo0eUtwdDV5OHJWSWFob01VZjhBOGtXdEFRTkNUYmpwNzFneDMvelZkcU56MVN1dGt3MGdGSU1WbTJCRjRYZHYvMG9sdytOYURJUjlCYjNEUHdlWkEySy9jdysvYitBd3lXbDlaT1A2N0E5bmV4bWVUTmpmZHpQR2Y5SjZFNkJNUEthNWxKaCtxTnNkVXozSEJVZXZVNzFlUUZDcU9jeGlJWWhhY0FoaC84UFgwSjVEZFNWaVo2V2F6RER4N2N1a0pOcE1mRWtZTEo1QW80dkxvVmQzZDI1UGc0cWFWYTJwMkQyTDNXdllQSjVZZi9BL01TeHB0amxnWEwvS0p0UDJVMGNSdjJJMDlBVEFpV0NKWXVSd2lhcGVLRnNxbWkxOHlNTXVsRHAzSGRjSWxkcSs3amt3c0pVT0hMSEN6enpCdzVYRnZMMENBbW8xdWI0NTZ6N3piN3NoazNLUEdDTFp6cjQ3b1Qxay9qMDZYTm5KdkczVWR2NlhyUCt3c3FUQmxaNU1hTlB0OUZPcy80QnQvamEvdmJWaFROcEJGbDlHcTdNcUlOdkdsV0tPQXdRendPWnkrRXpTZGpBcUtKVlYyWWNza1R1TTk0YUlLK2tjL0FaYVhpWkxQUkVVRHBrWElWOTQ3SUZmais4NVRycVBxTGZrR2N4Z2JvTVFqb3NmK2F6K29kTE5YZHlwMW1ETkdzcVNkSy9wSjJDYTA0bXQvNGQ2czFYK2xuY09FWWFHQkJlVzRwQXBHY2pmNy9YSkNGYmozTjNtRmIrQnRsSWN3OFppREtvQ2xGWDlSZjBieENxdExwaWNPYktKekJWVkhyLzZ1NHNpSDJoSzc1Uk52N3c5R2ZUYmhKT1FCWWlGVVpBQnlZNHJuMzd0WkJIVC8va3FLc05pM3J5TDlBcVhKUnpxaU1JSk1oSUxqb2kvaThMVkVzYnUrSWg5YnN5VzE2c2dRcWpZTE8wcWRhNkthQ1BLajNEUWN1NkNmVjVsS3RqUzNaQ2RxTEFaa09leTlNUitRdXRKQkdpei9yMTVHVkQ2ckNWd0pSNFVVS0M0R05Ka2ZEZjAwT01XOGFRdExTQUdMWFY4TUlpOW1iYmwvcVFFcHhDbTJMNWh1dEZYNGVrZUxINFFnQldVRktzLzJWVk1LeTQ2V3RGRTZBYndnbVltL1oweUhrNXZlRElyY2wySHBWcWIvclNFMFBDOUViRHpKRVdxZWFQaGg3dkYzNjlVbXEya1NpQjNzNXJCSTZjLzdOOWJrUnU0aDJuKy9oNW5Td3krN24rL0krNm9YUVZBTm8ySmI1ekR3dGlCUGYxeVNDekhkVDZ5SlNoTXpxU1JaZm55a1g0OUNhRmF4aG9WRjRQQmhFdUVDSjFQckZZU3BtSHV5WXNsMTREVEFWOVp4Um1zMVhpUi9rQnJqaFpqaWRPdDBVTmUrR1NtbDdYTmdwVnc4WXNVVG1aWExUSys2aVlueVcvd1lSMVc0VVh3T2kxNHhwRlJPSGI2SGNaemtzZ0Y1RGJMMkFGWHpLTndIVTJhZGpkQVkrS0N5TS9jd1JUQmtrcS9hMjI3TkkwcTZEUjJNa01DUnU2MjB0NzliR2NZVW1BQ3RxTjNtay8wdU53ZDNKU1hIcUUxa3pmNll5ajBXMjA4M0pORFJuSVhEbGdCeEo2dWY1OE5OMWY2RlFpUkNXQjRlZ0Y4UUR4NzRBaXhWOG9UeXc3UGx1SWpyMy9yai9Xemd3UFNxNHhQb2phRjdWMHhxRzJ1NXRpMkwxaDZ5WUh2NzNJc3J1a3Iwa1VSRElFakNsQnNCeDdrZGNYVXhhWU1TMHN5VDN5bUx6RHpzbE5EV1FPVDFUYW8xWU5tSkhBUlVlbmhDa21WOXRxQ1BHSTVHcVphUnBraVB4eWpvbmNXanlPSFlHcXZidlJYK0JuMXBuN0VoUk5YYTFscUpQbW9lTjVWcWRxSURQaEVWaEZzeUcwZDRpUUVJWVgwd1pVYlkyWGJaV1lscFovbDY2SXJERFkwcTFDMVl6QkRwSEM0aDA1WXFIUUxxUzlhbnlsMjJKUTZsRXZqdmRCd01IZkU3ejBsdUNYRDM0L3JGZURhMlRtU2VFQXlrU3BZTzVqMUcvbnNncFIzcW4wcWFRRW1Mam5uTGZjeit2ZW9ZcVBuUnFtUkd3Q0o2RkozR20vWjEvYVZYNVBTYjAzTU1uakFmNDF3dzU0c0Q1azhGcmtmQlArSzBiMU1yWXBhcFdqdHBaZnZlMkhWZjRpY2tYM0xLU09odTdxSTFWZDRjMWtOcm4yYWp5MXQ0eTkzSmhWNGZuV0NLcTdPbUZwY3I3RmpkSkNYUFRxbDBEcnIxNEhvM1o4NytHUFE0Wi9EY1RpR3F0dlp4bFJZaThjTnVoWEFCdmVaSXdObC9CWDFodWhWTGFGYXg1T3F5cFVyUVJ5YjlPRTNTU2tQbERkeTV1bzVYR2cyRUlHRWpMWTFNTzVjcjFpYmZpRldWN3pzcGNUZ2tCS2t3bzVqUHlBaW4wNExxaXpaWGIydERSZ3dLSmpHeDRjVmszbmdBUWl4d2N4allBZzJRN3ZtVVIvaHB3SW5NZHc3T2hDMnF5ZjQxdlRQa3VkUUFPUlMwRGRMdE9HUXhiNGZIMlZZR3N2SkNrZVdQZVV3dGYxL3R1SWh6WEVUaG9DWnp6U0pxcWpVdGJhUEkzbnRIbTNUNXVmODQ5aEdVQTB6VThuaTVXK0VFbjMvMFk2b1VoUUZ3OXowYUdqa2xqQmJBbEZYYzB5ODJHMndrZDdWZGdXYTVLVGdKSk5qTndaTWZtZG5VSVVuMUpVNUxpV1g1VVpFWmJWbEtTTjc2bWxtalVSMmt1K2Z1Y1RObE80SUFBYWhuTGpCaGx2UU5SOXBlOXN3R0JncTBZUjdQM1ZDeUkvc2VZd1E0UUJ6eTlYK0hQZVBnb0Y4V2ZLYUo0TUJPaExDR0hhZTZaOHhrTlh3bmk5UUFLdlROdFZBNTZ4OFlKZmxaL1Z2T05SU2xzU0xtaVN5Tk1uVGpUYUUxa284MXprekdFblZ3RWhqQ3psd0lxcHhtcERBcXdzRW10cGRyM3hwYzdpL1pYM2YyVHpUM00wRmR4SUVRdk8xamdtbWlOK0QxWXBNZHVBekVoQnRqMk9Ca01OL3J2NnA3VGg0cFNINmY1YUgzYVR2d0ZUbDdFT1NnR0FTSTd0dHlNZWh6cG00QVZ5SytiRkVhRmc5Z25ac1NVUHBzYkFlLzBSRmhySCtFWFoxMlo3dGhmNGR6TjErU24rRzhRckRBMVZLYU40SUZ4RDFyUXo5WHE5Q29paTlTOS9oUGJUR2p5QndGSDNIMVVkUXV6NUtzZ1BERUh1YTQva1BnMkdwL0lJSXRzYUxXQnFpVDlYSDQ1TWlReFNvc0dKNTZILzBGMmNqY0NGZDcybDE2NjVSTkhVUmRDM2xzcEk3N2VzZkpzbCtyWFhhYmtBeTd2eERYRy9YR0djS3B3aUtEUEZmdk1FZ2prQUhpbDRaYTFGMzZSbnl4eHZkSUF6dmdmSDhrbnVrWURjazA3dGMrK0RQNFRkV2VJN0hYdXE1WWw2VlZGclVRdGY2NC9ka1hld2xLWlNIUW82WXZDU3BSRUIwR0RyeitZczJHZk84bncyU3dyWXdhZjg4QWlmemxQdlAxN2JmMW1JM0F1Y2NKdkFqWklwQm1xdmhhcktGQWViRWpWS2ZHQXdwUWpXb1hsbTlMUk9zcTliQ2sxVWVRM0NKeEpxcHJ6c3NTL1EwNEplUzFSZUNDdWJMM0o3c3g4NnNwa1A0ZU5wcDk1VUYrOEs3NDhpY0lzOHZkSUxGa2xrOXNrUXFpMVNvNmN4M1g5MDZwdnkxdnorS2lwVEo4ZmlWSnhzVjVNbVQwWHdBJztcblxuLy8gaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyMTUvXHJcbi8vIGZvciByZWZlcmVuY2UgaW1wbGVtZW50YXRpb25cclxuLy8gc2VlOiAvZGVyaXZlL25mLmpzXHJcblxyXG5cclxuLy8gYWxnb3JpdGhtaWMgaGFuZ3VsXHJcbi8vIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3ZlcnNpb25zL1VuaWNvZGUxNS4wLjAvY2gwMy5wZGYgKHBhZ2UgMTQ0KVxyXG5jb25zdCBTMCA9IDB4QUMwMDtcclxuY29uc3QgTDAgPSAweDExMDA7XHJcbmNvbnN0IFYwID0gMHgxMTYxO1xyXG5jb25zdCBUMCA9IDB4MTFBNztcclxuY29uc3QgTF9DT1VOVCA9IDE5O1xyXG5jb25zdCBWX0NPVU5UID0gMjE7XHJcbmNvbnN0IFRfQ09VTlQgPSAyODtcclxuY29uc3QgTl9DT1VOVCA9IFZfQ09VTlQgKiBUX0NPVU5UO1xyXG5jb25zdCBTX0NPVU5UID0gTF9DT1VOVCAqIE5fQ09VTlQ7XHJcbmNvbnN0IFMxID0gUzAgKyBTX0NPVU5UO1xyXG5jb25zdCBMMSA9IEwwICsgTF9DT1VOVDtcclxuY29uc3QgVjEgPSBWMCArIFZfQ09VTlQ7XHJcbmNvbnN0IFQxID0gVDAgKyBUX0NPVU5UO1xyXG5cclxuZnVuY3Rpb24gdW5wYWNrX2NjKHBhY2tlZCkge1xyXG5cdHJldHVybiAocGFja2VkID4+IDI0KSAmIDB4RkY7XHJcbn1cclxuZnVuY3Rpb24gdW5wYWNrX2NwKHBhY2tlZCkge1xyXG5cdHJldHVybiBwYWNrZWQgJiAweEZGRkZGRjtcclxufVxyXG5cclxubGV0IFNISUZURURfUkFOSywgRVhDTFVTSU9OUywgREVDT01QLCBSRUNPTVA7XHJcblxyXG4vLyBleHBvcnQgZnVuY3Rpb24gbmZfZGVpbml0KCkge1xyXG4vLyBcdGlmICghU0hJRlRFRF9SQU5LKSByZXR1cm47XHJcbi8vIFx0U0hJRlRFRF9SQU5LID0gRVhDTFVTSU9OUyA9IERFQ09NUCA9IFJFQ09NUCA9IHVuZGVmaW5lZDtcclxuLy8gfVxyXG5cclxuZnVuY3Rpb24gaW5pdCQxKCkge1xyXG5cdC8vY29uc29sZS50aW1lKCduZicpO1xyXG5cdGxldCByID0gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQoQ09NUFJFU1NFRCk7XHJcblx0U0hJRlRFRF9SQU5LID0gbmV3IE1hcChyZWFkX3NvcnRlZF9hcnJheXMocikuZmxhdE1hcCgodiwgaSkgPT4gdi5tYXAoeCA9PiBbeCwgKGkrMSkgPDwgMjRdKSkpOyAvLyBwcmUtc2hpZnRlZFxyXG5cdEVYQ0xVU0lPTlMgPSBuZXcgU2V0KHJlYWRfc29ydGVkKHIpKTtcclxuXHRERUNPTVAgPSBuZXcgTWFwKCk7XHJcblx0UkVDT01QID0gbmV3IE1hcCgpO1xyXG5cdGZvciAobGV0IFtjcCwgY3BzXSBvZiByZWFkX21hcHBlZChyKSkge1xyXG5cdFx0aWYgKCFFWENMVVNJT05TLmhhcyhjcCkgJiYgY3BzLmxlbmd0aCA9PSAyKSB7XHJcblx0XHRcdGxldCBbYSwgYl0gPSBjcHM7XHJcblx0XHRcdGxldCBidWNrZXQgPSBSRUNPTVAuZ2V0KGEpO1xyXG5cdFx0XHRpZiAoIWJ1Y2tldCkge1xyXG5cdFx0XHRcdGJ1Y2tldCA9IG5ldyBNYXAoKTtcclxuXHRcdFx0XHRSRUNPTVAuc2V0KGEsIGJ1Y2tldCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YnVja2V0LnNldChiLCBjcCk7XHJcblx0XHR9XHJcblx0XHRERUNPTVAuc2V0KGNwLCBjcHMucmV2ZXJzZSgpKTsgLy8gc3RvcmVkIHJldmVyc2VkXHJcblx0fVxyXG5cdC8vY29uc29sZS50aW1lRW5kKCduZicpO1xyXG5cdC8vIDIwMjMwOTA1OiAxMW1zXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzX2hhbmd1bChjcCkge1xyXG5cdHJldHVybiBjcCA+PSBTMCAmJiBjcCA8IFMxO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wb3NlX3BhaXIoYSwgYikge1xyXG5cdGlmIChhID49IEwwICYmIGEgPCBMMSAmJiBiID49IFYwICYmIGIgPCBWMSkge1xyXG5cdFx0cmV0dXJuIFMwICsgKGEgLSBMMCkgKiBOX0NPVU5UICsgKGIgLSBWMCkgKiBUX0NPVU5UO1xyXG5cdH0gZWxzZSBpZiAoaXNfaGFuZ3VsKGEpICYmIGIgPiBUMCAmJiBiIDwgVDEgJiYgKGEgLSBTMCkgJSBUX0NPVU5UID09IDApIHtcclxuXHRcdHJldHVybiBhICsgKGIgLSBUMCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGxldCByZWNvbXAgPSBSRUNPTVAuZ2V0KGEpO1xyXG5cdFx0aWYgKHJlY29tcCkge1xyXG5cdFx0XHRyZWNvbXAgPSByZWNvbXAuZ2V0KGIpO1xyXG5cdFx0XHRpZiAocmVjb21wKSB7XHJcblx0XHRcdFx0cmV0dXJuIHJlY29tcDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIC0xO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGVjb21wb3NlZChjcHMpIHtcclxuXHRpZiAoIVNISUZURURfUkFOSykgaW5pdCQxKCk7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdGxldCBidWYgPSBbXTtcclxuXHRsZXQgY2hlY2tfb3JkZXIgPSBmYWxzZTtcclxuXHRmdW5jdGlvbiBhZGQoY3ApIHtcclxuXHRcdGxldCBjYyA9IFNISUZURURfUkFOSy5nZXQoY3ApO1xyXG5cdFx0aWYgKGNjKSB7XHJcblx0XHRcdGNoZWNrX29yZGVyID0gdHJ1ZTtcclxuXHRcdFx0Y3AgfD0gY2M7XHJcblx0XHR9XHJcblx0XHRyZXQucHVzaChjcCk7XHJcblx0fVxyXG5cdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0aWYgKGNwIDwgMHg4MCkge1xyXG5cdFx0XHRcdHJldC5wdXNoKGNwKTtcclxuXHRcdFx0fSBlbHNlIGlmIChpc19oYW5ndWwoY3ApKSB7XHJcblx0XHRcdFx0bGV0IHNfaW5kZXggPSBjcCAtIFMwO1xyXG5cdFx0XHRcdGxldCBsX2luZGV4ID0gc19pbmRleCAvIE5fQ09VTlQgfCAwO1xyXG5cdFx0XHRcdGxldCB2X2luZGV4ID0gKHNfaW5kZXggJSBOX0NPVU5UKSAvIFRfQ09VTlQgfCAwO1xyXG5cdFx0XHRcdGxldCB0X2luZGV4ID0gc19pbmRleCAlIFRfQ09VTlQ7XHJcblx0XHRcdFx0YWRkKEwwICsgbF9pbmRleCk7XHJcblx0XHRcdFx0YWRkKFYwICsgdl9pbmRleCk7XHJcblx0XHRcdFx0aWYgKHRfaW5kZXggPiAwKSBhZGQoVDAgKyB0X2luZGV4KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgbWFwcGVkID0gREVDT01QLmdldChjcCk7XHJcblx0XHRcdFx0aWYgKG1hcHBlZCkge1xyXG5cdFx0XHRcdFx0YnVmLnB1c2goLi4ubWFwcGVkKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0YWRkKGNwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCFidWYubGVuZ3RoKSBicmVhaztcclxuXHRcdFx0Y3AgPSBidWYucG9wKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChjaGVja19vcmRlciAmJiByZXQubGVuZ3RoID4gMSkge1xyXG5cdFx0bGV0IHByZXZfY2MgPSB1bnBhY2tfY2MocmV0WzBdKTtcclxuXHRcdGZvciAobGV0IGkgPSAxOyBpIDwgcmV0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCBjYyA9IHVucGFja19jYyhyZXRbaV0pO1xyXG5cdFx0XHRpZiAoY2MgPT0gMCB8fCBwcmV2X2NjIDw9IGNjKSB7XHJcblx0XHRcdFx0cHJldl9jYyA9IGNjO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxldCBqID0gaS0xO1xyXG5cdFx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHRcdGxldCB0bXAgPSByZXRbaisxXTtcclxuXHRcdFx0XHRyZXRbaisxXSA9IHJldFtqXTtcclxuXHRcdFx0XHRyZXRbal0gPSB0bXA7XHJcblx0XHRcdFx0aWYgKCFqKSBicmVhaztcclxuXHRcdFx0XHRwcmV2X2NjID0gdW5wYWNrX2NjKHJldFstLWpdKTtcclxuXHRcdFx0XHRpZiAocHJldl9jYyA8PSBjYykgYnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0cHJldl9jYyA9IHVucGFja19jYyhyZXRbaV0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wb3NlZF9mcm9tX2RlY29tcG9zZWQodikge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHRsZXQgc3RhY2sgPSBbXTtcclxuXHRsZXQgcHJldl9jcCA9IC0xO1xyXG5cdGxldCBwcmV2X2NjID0gMDtcclxuXHRmb3IgKGxldCBwYWNrZWQgb2Ygdikge1xyXG5cdFx0bGV0IGNjID0gdW5wYWNrX2NjKHBhY2tlZCk7XHJcblx0XHRsZXQgY3AgPSB1bnBhY2tfY3AocGFja2VkKTtcclxuXHRcdGlmIChwcmV2X2NwID09IC0xKSB7XHJcblx0XHRcdGlmIChjYyA9PSAwKSB7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldC5wdXNoKGNwKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmIChwcmV2X2NjID4gMCAmJiBwcmV2X2NjID49IGNjKSB7XHJcblx0XHRcdGlmIChjYyA9PSAwKSB7XHJcblx0XHRcdFx0cmV0LnB1c2gocHJldl9jcCwgLi4uc3RhY2spO1xyXG5cdFx0XHRcdHN0YWNrLmxlbmd0aCA9IDA7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0YWNrLnB1c2goY3ApO1xyXG5cdFx0XHR9XHJcblx0XHRcdHByZXZfY2MgPSBjYztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBjb21wb3NlZCA9IGNvbXBvc2VfcGFpcihwcmV2X2NwLCBjcCk7XHJcblx0XHRcdGlmIChjb21wb3NlZCA+PSAwKSB7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNvbXBvc2VkO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHByZXZfY2MgPT0gMCAmJiBjYyA9PSAwKSB7XHJcblx0XHRcdFx0cmV0LnB1c2gocHJldl9jcCk7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0YWNrLnB1c2goY3ApO1xyXG5cdFx0XHRcdHByZXZfY2MgPSBjYztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAocHJldl9jcCA+PSAwKSB7XHJcblx0XHRyZXQucHVzaChwcmV2X2NwLCAuLi5zdGFjayk7XHRcclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuLy8gbm90ZTogY3BzIGNhbiBiZSBpdGVyYWJsZVxyXG5mdW5jdGlvbiBuZmQoY3BzKSB7XHJcblx0cmV0dXJuIGRlY29tcG9zZWQoY3BzKS5tYXAodW5wYWNrX2NwKTtcclxufVxyXG5mdW5jdGlvbiBuZmMoY3BzKSB7XHJcblx0cmV0dXJuIGNvbXBvc2VkX2Zyb21fZGVjb21wb3NlZChkZWNvbXBvc2VkKGNwcykpO1xyXG59XG5cbmNvbnN0IEhZUEhFTiA9IDB4MkQ7XHJcbmNvbnN0IFNUT1AgPSAweDJFO1xyXG5jb25zdCBTVE9QX0NIID0gJy4nO1xyXG5jb25zdCBGRTBGID0gMHhGRTBGO1xyXG5jb25zdCBVTklRVUVfUEggPSAxO1xyXG5cclxuLy8gMjAyMzA5MTM6IHJlcGxhY2UgWy4uLnZdIHdpdGggQXJyYXlfZnJvbSh2KSB0byBhdm9pZCBsYXJnZSBzcHJlYWRzXHJcbmNvbnN0IEFycmF5X2Zyb20gPSB4ID0+IEFycmF5LmZyb20oeCk7IC8vIEFycmF5LmZyb20uYmluZChBcnJheSk7XHJcblxyXG5mdW5jdGlvbiBncm91cF9oYXNfY3AoZywgY3ApIHtcclxuXHQvLyAyMDIzMDkxMzoga2VlcCBwcmltYXJ5IGFuZCBzZWNvbmRhcnkgZGlzdGluY3QgaW5zdGVhZCBvZiBjcmVhdGluZyB2YWxpZCB1bmlvblxyXG5cdHJldHVybiBnLlAuaGFzKGNwKSB8fCBnLlEuaGFzKGNwKTtcclxufVxyXG5cclxuY2xhc3MgRW1vamkgZXh0ZW5kcyBBcnJheSB7XHJcblx0Z2V0IGlzX2Vtb2ppKCkgeyByZXR1cm4gdHJ1ZTsgfSAvLyBmcmVlIHRhZ2dpbmcgc3lzdGVtXHJcbn1cclxuXHJcbmxldCBNQVBQRUQsIElHTk9SRUQsIENNLCBOU00sIEVTQ0FQRSwgTkZDX0NIRUNLLCBHUk9VUFMsIFdIT0xFX1ZBTElELCBXSE9MRV9NQVAsIFZBTElELCBFTU9KSV9MSVNULCBFTU9KSV9ST09UO1xyXG5cclxuLy8gZXhwb3J0IGZ1bmN0aW9uIGVuc19kZWluaXQoKSB7XHJcbi8vIFx0bmZfZGVpbml0KCk7XHJcbi8vIFx0aWYgKCFNQVBQRUQpIHJldHVybjtcclxuLy8gXHRNQVBQRUQgPSBJR05PUkVEID0gQ00gPSBOU00gPSBFU0NBUEUgPSBORkNfQ0hFQ0sgPSBHUk9VUFMgPSBXSE9MRV9WQUxJRCA9IFdIT0xFX01BUCA9IFZBTElEID0gRU1PSklfTElTVCA9IEVNT0pJX1JPT1QgPSB1bmRlZmluZWQ7XHJcbi8vIH1cclxuXHJcbmZ1bmN0aW9uIGluaXQoKSB7XHJcblx0aWYgKE1BUFBFRCkgcmV0dXJuO1xyXG5cdFxyXG5cdGxldCByID0gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQoQ09NUFJFU1NFRCQxKTtcclxuXHRjb25zdCByZWFkX3NvcnRlZF9hcnJheSA9ICgpID0+IHJlYWRfc29ydGVkKHIpO1xyXG5cdGNvbnN0IHJlYWRfc29ydGVkX3NldCA9ICgpID0+IG5ldyBTZXQocmVhZF9zb3J0ZWRfYXJyYXkoKSk7XHJcblx0Y29uc3Qgc2V0X2FkZF9tYW55ID0gKHNldCwgdikgPT4gdi5mb3JFYWNoKHggPT4gc2V0LmFkZCh4KSk7XHJcblxyXG5cdE1BUFBFRCA9IG5ldyBNYXAocmVhZF9tYXBwZWQocikpOyBcclxuXHRJR05PUkVEID0gcmVhZF9zb3J0ZWRfc2V0KCk7IC8vIGlnbm9yZWQgY2hhcmFjdGVycyBhcmUgbm90IHZhbGlkLCBzbyBqdXN0IHJlYWQgcmF3IGNvZGVwb2ludHNcclxuXHJcblx0LypcclxuXHQvLyBkaXJlY3QgaW5jbHVkZSBmcm9tIHBheWxvYWQgaXMgc21hbGxlciB0aGFuIHRoZSBkZWNvbXByZXNzaW9uIGNvZGVcclxuXHRjb25zdCBGRU5DRUQgPSBuZXcgTWFwKHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4ge1xyXG5cdFx0bGV0IGNwID0gcigpO1xyXG5cdFx0aWYgKGNwKSByZXR1cm4gW2NwLCByZWFkX3N0cihyKCkpXTtcclxuXHR9KSk7XHJcblx0Ki9cclxuXHQvLyAyMDIzMDIxNzogd2Ugc3RpbGwgbmVlZCBhbGwgQ00gZm9yIHByb3BlciBlcnJvciBmb3JtYXR0aW5nXHJcblx0Ly8gYnV0IG5vcm0gb25seSBuZWVkcyBOU00gc3Vic2V0IHRoYXQgYXJlIHBvdGVudGlhbGx5LXZhbGlkXHJcblx0Q00gPSByZWFkX3NvcnRlZF9hcnJheSgpO1xyXG5cdE5TTSA9IG5ldyBTZXQocmVhZF9zb3J0ZWRfYXJyYXkoKS5tYXAoaSA9PiBDTVtpXSkpO1xyXG5cdENNID0gbmV3IFNldChDTSk7XHJcblx0XHJcblx0RVNDQVBFID0gcmVhZF9zb3J0ZWRfc2V0KCk7IC8vIGNoYXJhY3RlcnMgdGhhdCBzaG91bGQgbm90IGJlIHByaW50ZWRcclxuXHRORkNfQ0hFQ0sgPSByZWFkX3NvcnRlZF9zZXQoKTsgLy8gb25seSBuZWVkZWQgdG8gaWxsdXN0cmF0ZSBlbnNfdG9rZW5pemUoKSB0cmFuc2Zvcm1hdGlvbnNcclxuXHJcblx0bGV0IGNodW5rcyA9IHJlYWRfc29ydGVkX2FycmF5cyhyKTtcclxuXHRsZXQgdW5yZXN0cmljdGVkID0gcigpO1xyXG5cdC8vY29uc3QgcmVhZF9jaHVua2VkID0gKCkgPT4gbmV3IFNldChyZWFkX3NvcnRlZF9hcnJheSgpLmZsYXRNYXAoaSA9PiBjaHVua3NbaV0pLmNvbmNhdChyZWFkX3NvcnRlZF9hcnJheSgpKSk7XHJcblx0Y29uc3QgcmVhZF9jaHVua2VkID0gKCkgPT4ge1xyXG5cdFx0Ly8gMjAyMzA5MjE6IGJ1aWxkIHNldCBpbiBwYXJ0cywgMnggZmFzdGVyXHJcblx0XHRsZXQgc2V0ID0gbmV3IFNldCgpO1xyXG5cdFx0cmVhZF9zb3J0ZWRfYXJyYXkoKS5mb3JFYWNoKGkgPT4gc2V0X2FkZF9tYW55KHNldCwgY2h1bmtzW2ldKSk7XHJcblx0XHRzZXRfYWRkX21hbnkoc2V0LCByZWFkX3NvcnRlZF9hcnJheSgpKTtcclxuXHRcdHJldHVybiBzZXQ7IFxyXG5cdH07XHJcblx0R1JPVVBTID0gcmVhZF9hcnJheV93aGlsZShpID0+IHtcclxuXHRcdC8vIG1pbmlmaWVyIHByb3BlcnR5IG1hbmdsaW5nIHNlZW1zIHVuc2FmZVxyXG5cdFx0Ly8gc28gdGhlc2UgYXJlIG1hbnVhbGx5IHJlbmFtZWQgdG8gc2luZ2xlIGNoYXJzXHJcblx0XHRsZXQgTiA9IHJlYWRfYXJyYXlfd2hpbGUocikubWFwKHggPT4geCsweDYwKTtcclxuXHRcdGlmIChOLmxlbmd0aCkge1xyXG5cdFx0XHRsZXQgUiA9IGkgPj0gdW5yZXN0cmljdGVkOyAvLyB1bnJlc3RyaWN0ZWQgdGhlbiByZXN0cmljdGVkXHJcblx0XHRcdE5bMF0gLT0gMzI7IC8vIGNhcGl0YWxpemVcclxuXHRcdFx0TiA9IHN0cl9mcm9tX2NwcyhOKTtcclxuXHRcdFx0aWYgKFIpIE49YFJlc3RyaWN0ZWRbJHtOfV1gO1xyXG5cdFx0XHRsZXQgUCA9IHJlYWRfY2h1bmtlZCgpOyAvLyBwcmltYXJ5XHJcblx0XHRcdGxldCBRID0gcmVhZF9jaHVua2VkKCk7IC8vIHNlY29uZGFyeVxyXG5cdFx0XHRsZXQgTSA9ICFyKCk7IC8vIG5vdC13aGl0ZWxpc3RlZCwgY2hlY2sgZm9yIE5TTVxyXG5cdFx0XHQvLyAqKiogdGhpcyBjb2RlIGN1cnJlbnRseSBpc24ndCBuZWVkZWQgKioqXHJcblx0XHRcdC8qXHJcblx0XHRcdGxldCBWID0gWy4uLlAsIC4uLlFdLnNvcnQoKGEsIGIpID0+IGEtYik7IC8vIGRlcml2ZTogc29ydGVkIHZhbGlkXHJcblx0XHRcdGxldCBNID0gcigpLTE7IC8vIG51bWJlciBvZiBjb21iaW5pbmcgbWFya1xyXG5cdFx0XHRpZiAoTSA8IDApIHsgLy8gd2hpdGVsaXN0ZWRcclxuXHRcdFx0XHRNID0gbmV3IE1hcChyZWFkX2FycmF5X3doaWxlKCgpID0+IHtcclxuXHRcdFx0XHRcdGxldCBpID0gcigpO1xyXG5cdFx0XHRcdFx0aWYgKGkpIHJldHVybiBbVltpLTFdLCByZWFkX2FycmF5X3doaWxlKCgpID0+IHtcclxuXHRcdFx0XHRcdFx0bGV0IHYgPSByZWFkX2FycmF5X3doaWxlKHIpO1xyXG5cdFx0XHRcdFx0XHRpZiAodi5sZW5ndGgpIHJldHVybiB2Lm1hcCh4ID0+IHgtMSk7XHJcblx0XHRcdFx0XHR9KV07XHJcblx0XHRcdFx0fSkpO1xyXG5cdFx0XHR9Ki9cclxuXHRcdFx0cmV0dXJuIHtOLCBQLCBRLCBNLCBSfTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0Ly8gZGVjb2RlIGNvbXByZXNzZWQgd2hvbGVzXHJcblx0V0hPTEVfVkFMSUQgPSByZWFkX3NvcnRlZF9zZXQoKTtcclxuXHRXSE9MRV9NQVAgPSBuZXcgTWFwKCk7XHJcblx0bGV0IHdob2xlcyA9IHJlYWRfc29ydGVkX2FycmF5KCkuY29uY2F0KEFycmF5X2Zyb20oV0hPTEVfVkFMSUQpKS5zb3J0KChhLCBiKSA9PiBhLWIpOyAvLyBtdXN0IGJlIHNvcnRlZFxyXG5cdHdob2xlcy5mb3JFYWNoKChjcCwgaSkgPT4ge1xyXG5cdFx0bGV0IGQgPSByKCk7IFxyXG5cdFx0bGV0IHcgPSB3aG9sZXNbaV0gPSBkID8gd2hvbGVzW2ktZF0gOiB7VjogW10sIE06IG5ldyBNYXAoKX07XHJcblx0XHR3LlYucHVzaChjcCk7IC8vIGFkZCB0byBtZW1iZXIgc2V0XHJcblx0XHRpZiAoIVdIT0xFX1ZBTElELmhhcyhjcCkpIHtcclxuXHRcdFx0V0hPTEVfTUFQLnNldChjcCwgdyk7ICAvLyByZWdpc3RlciB3aXRoIHdob2xlIG1hcFxyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHQvLyBjb21wdXRlIGNvbmZ1c2FibGUtZXh0ZW50IGNvbXBsZW1lbnRzXHJcblx0Ly8gdXNhZ2U6IFdIT0xFX01BUC5nZXQoY3ApLk0uZ2V0KGNwKSA9IGNvbXBsZW1lbnQgc2V0XHJcblx0Zm9yIChsZXQge1YsIE19IG9mIG5ldyBTZXQoV0hPTEVfTUFQLnZhbHVlcygpKSkge1xyXG5cdFx0Ly8gY29ubmVjdCBhbGwgZ3JvdXBzIHRoYXQgaGF2ZSBlYWNoIHdob2xlIGNoYXJhY3RlclxyXG5cdFx0bGV0IHJlY3MgPSBbXTtcclxuXHRcdGZvciAobGV0IGNwIG9mIFYpIHtcclxuXHRcdFx0bGV0IGdzID0gR1JPVVBTLmZpbHRlcihnID0+IGdyb3VwX2hhc19jcChnLCBjcCkpO1xyXG5cdFx0XHRsZXQgcmVjID0gcmVjcy5maW5kKCh7R30pID0+IGdzLnNvbWUoZyA9PiBHLmhhcyhnKSkpO1xyXG5cdFx0XHRpZiAoIXJlYykge1xyXG5cdFx0XHRcdHJlYyA9IHtHOiBuZXcgU2V0KCksIFY6IFtdfTtcclxuXHRcdFx0XHRyZWNzLnB1c2gocmVjKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZWMuVi5wdXNoKGNwKTtcclxuXHRcdFx0c2V0X2FkZF9tYW55KHJlYy5HLCBncyk7XHJcblx0XHR9XHJcblx0XHQvLyBwZXIgY2hhcmFjdGVyIGNhY2hlIGdyb3VwcyB3aGljaCBhcmUgbm90IGEgbWVtYmVyIG9mIHRoZSBleHRlbnRcclxuXHRcdGxldCB1bmlvbiA9IHJlY3MuZmxhdE1hcCh4ID0+IEFycmF5X2Zyb20oeC5HKSk7IC8vIGFsbCBvZiB0aGUgZ3JvdXBzIHVzZWQgYnkgdGhpcyB3aG9sZVxyXG5cdFx0Zm9yIChsZXQge0csIFZ9IG9mIHJlY3MpIHtcclxuXHRcdFx0bGV0IGNvbXBsZW1lbnQgPSBuZXcgU2V0KHVuaW9uLmZpbHRlcihnID0+ICFHLmhhcyhnKSkpOyAvLyBncm91cHMgbm90IGNvdmVyZWQgYnkgdGhlIGV4dGVudFxyXG5cdFx0XHRmb3IgKGxldCBjcCBvZiBWKSB7XHJcblx0XHRcdFx0TS5zZXQoY3AsIGNvbXBsZW1lbnQpOyAvLyB0aGlzIGlzIHRoZSBzYW1lIHJlZmVyZW5jZVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBjb21wdXRlIHZhbGlkIHNldFxyXG5cdC8vIDIwMjMwOTI0OiBWQUxJRCB3YXMgdW5pb24gYnV0IGNhbiBiZSByZS11c2VkXHJcblx0VkFMSUQgPSBuZXcgU2V0KCk7IC8vIGV4aXN0cyBpbiAxKyBncm91cHNcclxuXHRsZXQgbXVsdGkgPSBuZXcgU2V0KCk7IC8vIGV4aXN0cyBpbiAyKyBncm91cHNcclxuXHRjb25zdCBhZGRfdG9fdW5pb24gPSBjcCA9PiBWQUxJRC5oYXMoY3ApID8gbXVsdGkuYWRkKGNwKSA6IFZBTElELmFkZChjcCk7XHJcblx0Zm9yIChsZXQgZyBvZiBHUk9VUFMpIHtcclxuXHRcdGZvciAobGV0IGNwIG9mIGcuUCkgYWRkX3RvX3VuaW9uKGNwKTtcclxuXHRcdGZvciAobGV0IGNwIG9mIGcuUSkgYWRkX3RvX3VuaW9uKGNwKTtcclxuXHR9XHJcblx0Ly8gZHVhbCBwdXJwb3NlIFdIT0xFX01BUDogcmV0dXJuIHBsYWNlaG9sZGVyIGlmIHVuaXF1ZSBub24tY29uZnVzYWJsZVxyXG5cdGZvciAobGV0IGNwIG9mIFZBTElEKSB7XHJcblx0XHRpZiAoIVdIT0xFX01BUC5oYXMoY3ApICYmICFtdWx0aS5oYXMoY3ApKSB7XHJcblx0XHRcdFdIT0xFX01BUC5zZXQoY3AsIFVOSVFVRV9QSCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdC8vIGFkZCBhbGwgZGVjb21wb3NlZCBwYXJ0c1xyXG5cdC8vIHNlZSBkZXJpdmU6IFwiVmFsaWQgaXMgQ2xvc2VkICh2aWEgQnJ1dGUtZm9yY2UpXCJcclxuXHRzZXRfYWRkX21hbnkoVkFMSUQsIG5mZChWQUxJRCkpO1xyXG5cdFxyXG5cdC8vIGRlY29kZSBlbW9qaVxyXG5cdC8vIDIwMjMwNzE5OiBlbW9qaSBhcmUgbm93IGZ1bGx5LWV4cGFuZGVkIHRvIGF2b2lkIHF1aXJrIGxvZ2ljIFxyXG5cdEVNT0pJX0xJU1QgPSByZWFkX3RyaWUocikubWFwKHYgPT4gRW1vamkuZnJvbSh2KSkuc29ydChjb21wYXJlX2FycmF5cyk7XHJcblx0RU1PSklfUk9PVCA9IG5ldyBNYXAoKTsgLy8gdGhpcyBoYXMgYXBwcm94IDdLIG5vZGVzICgyKyBwZXIgZW1vamkpXHJcblx0Zm9yIChsZXQgY3BzIG9mIEVNT0pJX0xJU1QpIHtcclxuXHRcdC8vIDIwMjMwNzE5OiBjaGFuZ2UgdG8gKnNsaWdodGx5KiBzdHJpY3RlciBhbGdvcml0aG0gd2hpY2ggZGlzYWxsb3dzIFxyXG5cdFx0Ly8gaW5zZXJ0aW9uIG9mIG1pc3BsYWNlZCBGRTBGIGluIGVtb2ppIHNlcXVlbmNlcyAobWF0Y2hpbmcgRU5TSVAtMTUpXHJcblx0XHQvLyBleGFtcGxlOiBiZWF1dGlmaWVkIFtBIEJdIChlZy4gZmxhZyBlbW9qaSkgXHJcblx0XHQvLyAgYmVmb3JlOiBhbGxvdzogW0EgRkUwRiBCXSwgZXJyb3I6IFtBIEZFMEYgRkUwRiBCXSBcclxuXHRcdC8vICAgYWZ0ZXI6IGVycm9yOiBib3RoXHJcblx0XHQvLyBub3RlOiB0aGlzIGNvZGUgbm93IG1hdGNoZXMgRU5TTm9ybWFsaXplLntjcyxqYXZhfSBsb2dpY1xyXG5cdFx0bGV0IHByZXYgPSBbRU1PSklfUk9PVF07XHJcblx0XHRmb3IgKGxldCBjcCBvZiBjcHMpIHtcclxuXHRcdFx0bGV0IG5leHQgPSBwcmV2Lm1hcChub2RlID0+IHtcclxuXHRcdFx0XHRsZXQgY2hpbGQgPSBub2RlLmdldChjcCk7XHJcblx0XHRcdFx0aWYgKCFjaGlsZCkge1xyXG5cdFx0XHRcdFx0Ly8gc2hvdWxkIHRoaXMgYmUgb2JqZWN0PyBcclxuXHRcdFx0XHRcdC8vIChtb3N0IGhhdmUgMS0yIGl0ZW1zLCBmZXcgaGF2ZSBtYW55KVxyXG5cdFx0XHRcdFx0Ly8gMjAyMzA3MTk6IG5vLCB2OCBkZWZhdWx0IG1hcCBpcyA0P1xyXG5cdFx0XHRcdFx0Y2hpbGQgPSBuZXcgTWFwKCk7XHJcblx0XHRcdFx0XHRub2RlLnNldChjcCwgY2hpbGQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gY2hpbGQ7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpZiAoY3AgPT09IEZFMEYpIHtcclxuXHRcdFx0XHRwcmV2LnB1c2goLi4ubmV4dCk7IC8vIGxlc3MgdGhhbiAyMCBlbGVtZW50c1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHByZXYgPSBuZXh0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRmb3IgKGxldCB4IG9mIHByZXYpIHtcclxuXHRcdFx0eC5WID0gY3BzO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuLy8gaWYgZXNjYXBlZDoge0hFWH1cclxuLy8gICAgICAgZWxzZTogXCJ4XCIge0hFWH1cclxuZnVuY3Rpb24gcXVvdGVkX2NwKGNwKSB7XHJcblx0cmV0dXJuIChzaG91bGRfZXNjYXBlKGNwKSA/ICcnIDogYCR7YmlkaV9xcShzYWZlX3N0cl9mcm9tX2NwcyhbY3BdKSl9IGApICsgcXVvdGVfY3AoY3ApO1xyXG59XHJcblxyXG4vLyAyMDIzMDIxMTogc29tZSBtZXNzYWdlcyBjYW4gYmUgbWl4ZWQtZGlyZWN0aW9uYWwgYW5kIHJlc3VsdCBpbiBzcGlsbG92ZXJcclxuLy8gdXNlIDIwMEUgYWZ0ZXIgYSBxdW90ZWQgc3RyaW5nIHRvIGZvcmNlIHRoZSByZW1haW5kZXIgb2YgYSBzdHJpbmcgZnJvbSBcclxuLy8gYWNxdXJpbmcgdGhlIGRpcmVjdGlvbiBvZiB0aGUgcXVvdGVcclxuLy8gaHR0cHM6Ly93d3cudzMub3JnL0ludGVybmF0aW9uYWwvcXVlc3Rpb25zL3FhLWJpZGktdW5pY29kZS1jb250cm9scyNleGNlcHRpb25zXHJcbmZ1bmN0aW9uIGJpZGlfcXEocykge1xyXG5cdHJldHVybiBgXCIke3N9XCJcXHUyMDBFYDsgLy8gc3Ryb25nIExUUlxyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja19sYWJlbF9leHRlbnNpb24oY3BzKSB7XHJcblx0aWYgKGNwcy5sZW5ndGggPj0gNCAmJiBjcHNbMl0gPT0gSFlQSEVOICYmIGNwc1szXSA9PSBIWVBIRU4pIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBsYWJlbCBleHRlbnNpb246IFwiJHtzdHJfZnJvbV9jcHMoY3BzLnNsaWNlKDAsIDQpKX1cImApOyAvLyB0aGlzIGNhbiBvbmx5IGJlIGFzY2lpIHNvIGNhbnQgYmUgYmlkaVxyXG5cdH1cclxufVxyXG5mdW5jdGlvbiBjaGVja19sZWFkaW5nX3VuZGVyc2NvcmUoY3BzKSB7XHJcblx0Y29uc3QgVU5ERVJTQ09SRSA9IDB4NUY7XHJcblx0Zm9yIChsZXQgaSA9IGNwcy5sYXN0SW5kZXhPZihVTkRFUlNDT1JFKTsgaSA+IDA7ICkge1xyXG5cdFx0aWYgKGNwc1stLWldICE9PSBVTkRFUlNDT1JFKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcigndW5kZXJzY29yZSBhbGxvd2VkIG9ubHkgYXQgc3RhcnQnKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuLy8gY2hlY2sgdGhhdCBhIGZlbmNlZCBjcCBpcyBub3QgbGVhZGluZywgdHJhaWxpbmcsIG9yIHRvdWNoaW5nIGFub3RoZXIgZmVuY2VkIGNwXHJcbmZ1bmN0aW9uIGNoZWNrX2ZlbmNlZChjcHMpIHtcclxuXHRsZXQgY3AgPSBjcHNbMF07XHJcblx0bGV0IHByZXYgPSBGRU5DRUQuZ2V0KGNwKTtcclxuXHRpZiAocHJldikgdGhyb3cgZXJyb3JfcGxhY2VtZW50KGBsZWFkaW5nICR7cHJldn1gKTtcclxuXHRsZXQgbiA9IGNwcy5sZW5ndGg7XHJcblx0bGV0IGxhc3QgPSAtMTsgLy8gcHJldmVudHMgdHJhaWxpbmcgZnJvbSB0aHJvd2luZ1xyXG5cdGZvciAobGV0IGkgPSAxOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRjcCA9IGNwc1tpXTtcclxuXHRcdGxldCBtYXRjaCA9IEZFTkNFRC5nZXQoY3ApO1xyXG5cdFx0aWYgKG1hdGNoKSB7XHJcblx0XHRcdC8vIHNpbmNlIGNwc1swXSBpc24ndCBmZW5jZWQsIGNwc1sxXSBjYW5ub3QgdGhyb3dcclxuXHRcdFx0aWYgKGxhc3QgPT0gaSkgdGhyb3cgZXJyb3JfcGxhY2VtZW50KGAke3ByZXZ9ICsgJHttYXRjaH1gKTtcclxuXHRcdFx0bGFzdCA9IGkgKyAxO1xyXG5cdFx0XHRwcmV2ID0gbWF0Y2g7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChsYXN0ID09IG4pIHRocm93IGVycm9yX3BsYWNlbWVudChgdHJhaWxpbmcgJHtwcmV2fWApO1xyXG59XHJcblxyXG4vLyBjcmVhdGUgYSBzYWZlIHRvIHByaW50IHN0cmluZyBcclxuLy8gaW52aXNpYmxlcyBhcmUgZXNjYXBlZFxyXG4vLyBsZWFkaW5nIGNtIHVzZXMgcGxhY2Vob2xkZXJcclxuLy8gaWYgY3BzIGV4Y2VlZCBtYXgsIG1pZGRsZSB0cnVuY2F0ZSB3aXRoIGVsbGlwc2lzXHJcbi8vIHF1b3RlcihjcCkgPT4gc3RyaW5nLCBlZy4gMzAwMCA9PiBcInszMDAwfVwiXHJcbi8vIG5vdGU6IGluIGh0bWwsIHlvdSdkIGNhbGwgdGhpcyBmdW5jdGlvbiB0aGVuIHJlcGxhY2UgWzw+Jl0gd2l0aCBlbnRpdGllc1xyXG5mdW5jdGlvbiBzYWZlX3N0cl9mcm9tX2NwcyhjcHMsIG1heCA9IEluZmluaXR5LCBxdW90ZXIgPSBxdW90ZV9jcCkge1xyXG5cdC8vaWYgKE51bWJlci5pc0ludGVnZXIoY3BzKSkgY3BzID0gW2Nwc107XHJcblx0Ly9pZiAoIUFycmF5LmlzQXJyYXkoY3BzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgY29kZXBvaW50c2ApO1xyXG5cdGxldCBidWYgPSBbXTtcclxuXHRpZiAoaXNfY29tYmluaW5nX21hcmsoY3BzWzBdKSkgYnVmLnB1c2goJ+KXjCcpO1xyXG5cdGlmIChjcHMubGVuZ3RoID4gbWF4KSB7XHJcblx0XHRtYXggPj49IDE7XHJcblx0XHRjcHMgPSBbLi4uY3BzLnNsaWNlKDAsIG1heCksIDB4MjAyNiwgLi4uY3BzLnNsaWNlKC1tYXgpXTtcclxuXHR9XHJcblx0bGV0IHByZXYgPSAwO1xyXG5cdGxldCBuID0gY3BzLmxlbmd0aDtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0bGV0IGNwID0gY3BzW2ldO1xyXG5cdFx0aWYgKHNob3VsZF9lc2NhcGUoY3ApKSB7XHJcblx0XHRcdGJ1Zi5wdXNoKHN0cl9mcm9tX2NwcyhjcHMuc2xpY2UocHJldiwgaSkpKTtcclxuXHRcdFx0YnVmLnB1c2gocXVvdGVyKGNwKSk7XHJcblx0XHRcdHByZXYgPSBpICsgMTtcclxuXHRcdH1cclxuXHR9XHJcblx0YnVmLnB1c2goc3RyX2Zyb21fY3BzKGNwcy5zbGljZShwcmV2LCBuKSkpO1xyXG5cdHJldHVybiBidWYuam9pbignJyk7XHJcbn1cclxuXHJcbi8vIG5vdGU6IHNldChzKSBjYW5ub3QgYmUgZXhwb3NlZCBiZWNhdXNlIHRoZXkgY2FuIGJlIG1vZGlmaWVkXHJcbi8vIG5vdGU6IE9iamVjdC5mcmVlemUoKSBkb2Vzbid0IHdvcmtcclxuZnVuY3Rpb24gaXNfY29tYmluaW5nX21hcmsoY3AsIG9ubHlfbnNtKSB7IC8vIDIwMjQwMTI3OiBhZGQgZXh0cmEgYXJndW1lbnRcclxuXHRpbml0KCk7XHJcblx0cmV0dXJuIG9ubHlfbnNtID8gTlNNLmhhcyhjcCkgOiBDTS5oYXMoY3ApO1xyXG59XHJcbmZ1bmN0aW9uIHNob3VsZF9lc2NhcGUoY3ApIHtcclxuXHRpbml0KCk7XHJcblx0cmV0dXJuIEVTQ0FQRS5oYXMoY3ApO1xyXG59XHJcblxyXG4vLyByZXR1cm4gYWxsIHN1cHBvcnRlZCBlbW9qaSBhcyBmdWxseS1xdWFsaWZpZWQgZW1vamkgXHJcbi8vIG9yZGVyZWQgYnkgbGVuZ3RoIHRoZW4gbGV4aWNvZ3JhcGhpYyBcclxuZnVuY3Rpb24gZW5zX2Vtb2ppKCkge1xyXG5cdGluaXQoKTtcclxuXHRyZXR1cm4gRU1PSklfTElTVC5tYXAoeCA9PiB4LnNsaWNlKCkpOyAvLyBlbW9qaSBhcmUgZXhwb3NlZCBzbyBjb3B5XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19ub3JtYWxpemVfZnJhZ21lbnQoZnJhZywgZGVjb21wb3NlKSB7XHJcblx0aW5pdCgpO1xyXG5cdGxldCBuZiA9IGRlY29tcG9zZSA/IG5mZCA6IG5mYztcclxuXHRyZXR1cm4gZnJhZy5zcGxpdChTVE9QX0NIKS5tYXAobGFiZWwgPT4gc3RyX2Zyb21fY3BzKHRva2Vuc19mcm9tX3N0cihleHBsb2RlX2NwKGxhYmVsKSwgbmYsIGZpbHRlcl9mZTBmKS5mbGF0KCkpKS5qb2luKFNUT1BfQ0gpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbnNfbm9ybWFsaXplKG5hbWUpIHtcclxuXHRyZXR1cm4gZmxhdHRlbihzcGxpdChuYW1lLCBuZmMsIGZpbHRlcl9mZTBmKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19iZWF1dGlmeShuYW1lKSB7XHJcblx0bGV0IGxhYmVscyA9IHNwbGl0KG5hbWUsIG5mYywgeCA9PiB4KTsgLy8gZW1vamkgbm90IGV4cG9zZWRcclxuXHRmb3IgKGxldCB7dHlwZSwgb3V0cHV0LCBlcnJvcn0gb2YgbGFiZWxzKSB7XHJcblx0XHRpZiAoZXJyb3IpIGJyZWFrOyAvLyBmbGF0dGVuIHdpbGwgdGhyb3dcclxuXHJcblx0XHQvLyByZXBsYWNlIGxlYWRpbmcvdHJhaWxpbmcgaHlwaGVuXHJcblx0XHQvLyAyMDIzMDEyMTogY29uc2lkZXIgYmVhdXRpZmluZyBhbGwgb3IgbGVhZGluZy90cmFpbGluZyBoeXBoZW4gdG8gdW5pY29kZSB2YXJpYW50XHJcblx0XHQvLyBub3QgZXhhY3RseSB0aGUgc2FtZSBpbiBldmVyeSBmb250LCBidXQgdmVyeSBzaW1pbGFyOiBcIi1cIiB2cyBcIuKAkFwiXHJcblx0XHQvKlxyXG5cdFx0Y29uc3QgVU5JQ09ERV9IWVBIRU4gPSAweDIwMTA7XHJcblx0XHQvLyBtYXliZSB0aGlzIHNob3VsZCByZXBsYWNlIGFsbCBmb3IgdmlzdWFsIGNvbnNpc3RhbmN5P1xyXG5cdFx0Ly8gYG5vZGUgdG9vbHMvcmVnLWNvdW50LmpzIHJlZ2V4IF4tXFx7MixcXH1gID0+IDU5MlxyXG5cdFx0Ly9mb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dC5sZW5ndGg7IGkrKykgaWYgKG91dHB1dFtpXSA9PSAweDJEKSBvdXRwdXRbaV0gPSAweDIwMTA7XHJcblx0XHRpZiAob3V0cHV0WzBdID09IEhZUEhFTikgb3V0cHV0WzBdID0gVU5JQ09ERV9IWVBIRU47XHJcblx0XHRsZXQgZW5kID0gb3V0cHV0Lmxlbmd0aC0xO1xyXG5cdFx0aWYgKG91dHB1dFtlbmRdID09IEhZUEhFTikgb3V0cHV0W2VuZF0gPSBVTklDT0RFX0hZUEhFTjtcclxuXHRcdCovXHJcblx0XHQvLyAyMDIzMDEyMzogV0hBVFdHIFVSTCB1c2VzIFwiQ2hlY2tIeXBoZW5zXCIgZmFsc2VcclxuXHRcdC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jaWRuYVxyXG5cclxuXHRcdC8vIHVwZGF0ZSBldGhlcmV1bSBzeW1ib2xcclxuXHRcdC8vIM6+ID0+IM6eIGlmIG5vdCBncmVla1xyXG5cdFx0aWYgKHR5cGUgIT09ICdHcmVlaycpIGFycmF5X3JlcGxhY2Uob3V0cHV0LCAweDNCRSwgMHgzOUUpO1xyXG5cclxuXHRcdC8vIDIwMjIxMjEzOiBmaXhlcyBiaWRpIHN1YmRvbWFpbiBpc3N1ZSwgYnV0IGJyZWFrcyBpbnZhcmlhbnQgKDIwMEUgaXMgZGlzYWxsb3dlZClcclxuXHRcdC8vIGNvdWxkIGJlIGZpeGVkIHdpdGggc3BlY2lhbCBjYXNlIGZvcjogMkQgKC4pICsgMjAwRSAoTFRSKVxyXG5cdFx0Ly8gaHR0cHM6Ly9kaXNjdXNzLmVucy5kb21haW5zL3QvYmlkaS1sYWJlbC1vcmRlcmluZy1zcG9vZi8xNTgyNFxyXG5cdFx0Ly9vdXRwdXQuc3BsaWNlKDAsIDAsIDB4MjAwRSk7XHJcblx0fVxyXG5cdHJldHVybiBmbGF0dGVuKGxhYmVscyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19zcGxpdChuYW1lLCBwcmVzZXJ2ZV9lbW9qaSkge1xyXG5cdHJldHVybiBzcGxpdChuYW1lLCBuZmMsIHByZXNlcnZlX2Vtb2ppID8geCA9PiB4LnNsaWNlKCkgOiBmaWx0ZXJfZmUwZik7IC8vIGVtb2ppIGFyZSBleHBvc2VkIHNvIGNvcHlcclxufVxyXG5cclxuZnVuY3Rpb24gc3BsaXQobmFtZSwgbmYsIGVmKSB7XHJcblx0aWYgKCFuYW1lKSByZXR1cm4gW107IC8vIDIwMjMwNzE5OiBlbXB0eSBuYW1lIGFsbG93YW5jZVxyXG5cdGluaXQoKTtcclxuXHRsZXQgb2Zmc2V0ID0gMDtcclxuXHQvLyBodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI0Ni8jVmFsaWRpdHlfQ3JpdGVyaWFcclxuXHQvLyA0LikgXCJUaGUgbGFiZWwgbXVzdCBub3QgY29udGFpbiBhIFUrMDAyRSAoIC4gKSBGVUxMIFNUT1AuXCJcclxuXHRyZXR1cm4gbmFtZS5zcGxpdChTVE9QX0NIKS5tYXAobGFiZWwgPT4ge1xyXG5cdFx0bGV0IGlucHV0ID0gZXhwbG9kZV9jcChsYWJlbCk7XHJcblx0XHRsZXQgaW5mbyA9IHtcclxuXHRcdFx0aW5wdXQsXHJcblx0XHRcdG9mZnNldCwgLy8gY29kZXBvaW50LCBub3Qgc3Vic3RyaW5nIVxyXG5cdFx0fTtcclxuXHRcdG9mZnNldCArPSBpbnB1dC5sZW5ndGggKyAxOyAvLyArIHN0b3BcclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIDEuKSBcIlRoZSBsYWJlbCBtdXN0IGJlIGluIFVuaWNvZGUgTm9ybWFsaXphdGlvbiBGb3JtIE5GQ1wiXHJcblx0XHRcdGxldCB0b2tlbnMgPSBpbmZvLnRva2VucyA9IHRva2Vuc19mcm9tX3N0cihpbnB1dCwgbmYsIGVmKTtcclxuXHRcdFx0bGV0IHRva2VuX2NvdW50ID0gdG9rZW5zLmxlbmd0aDtcclxuXHRcdFx0bGV0IHR5cGU7XHJcblx0XHRcdGlmICghdG9rZW5fY291bnQpIHsgLy8gdGhlIGxhYmVsIHdhcyBlZmZlY3RpdmVseSBlbXB0eSAoY291bGQgb2YgaGFkIGlnbm9yZWQgY2hhcmFjdGVycylcclxuXHRcdFx0XHQvL25vcm0gPSBbXTtcclxuXHRcdFx0XHQvL3R5cGUgPSAnTm9uZSc7IC8vIHVzZSB0aGlzIGluc3RlYWQgb2YgbmV4dCBtYXRjaCwgXCJBU0NJSVwiXHJcblx0XHRcdFx0Ly8gMjAyMzAxMjA6IGNoYW5nZSB0byBzdHJpY3RcclxuXHRcdFx0XHQvLyBodHRwczovL2Rpc2N1c3MuZW5zLmRvbWFpbnMvdC9lbnMtbmFtZS1ub3JtYWxpemF0aW9uLTJuZC8xNDU2NC81OVxyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgZW1wdHkgbGFiZWxgKTtcclxuXHRcdFx0fSBcclxuXHRcdFx0bGV0IG5vcm0gPSBpbmZvLm91dHB1dCA9IHRva2Vucy5mbGF0KCk7XHJcblx0XHRcdGNoZWNrX2xlYWRpbmdfdW5kZXJzY29yZShub3JtKTtcclxuXHRcdFx0bGV0IGVtb2ppID0gaW5mby5lbW9qaSA9IHRva2VuX2NvdW50ID4gMSB8fCB0b2tlbnNbMF0uaXNfZW1vamk7IC8vIHNhbWUgYXM6IHRva2Vucy5zb21lKHggPT4geC5pc19lbW9qaSk7XHJcblx0XHRcdGlmICghZW1vamkgJiYgbm9ybS5ldmVyeShjcCA9PiBjcCA8IDB4ODApKSB7IC8vIHNwZWNpYWwgY2FzZSBmb3IgYXNjaWlcclxuXHRcdFx0XHQvLyAyMDIzMDEyMzogbWF0Y2hlcyBtYXRjaGVzIFdIQVRXRywgc2VlIG5vdGUgMy4zXHJcblx0XHRcdFx0Y2hlY2tfbGFiZWxfZXh0ZW5zaW9uKG5vcm0pOyAvLyBvbmx5IG5lZWRlZCBmb3IgYXNjaWlcclxuXHRcdFx0XHQvLyBjYW50IGhhdmUgZmVuY2VkXHJcblx0XHRcdFx0Ly8gY2FudCBoYXZlIGNtXHJcblx0XHRcdFx0Ly8gY2FudCBoYXZlIHdob2xlc1xyXG5cdFx0XHRcdC8vIHNlZSBkZXJpdmU6IFwiRmFzdHBhdGggQVNDSUlcIlxyXG5cdFx0XHRcdHR5cGUgPSAnQVNDSUknO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBjaGFycyA9IHRva2Vucy5mbGF0TWFwKHggPT4geC5pc19lbW9qaSA/IFtdIDogeCk7IC8vIGFsbCBvZiB0aGUgbmZjIHRva2VucyBjb25jYXQgdG9nZXRoZXJcclxuXHRcdFx0XHRpZiAoIWNoYXJzLmxlbmd0aCkgeyAvLyB0aGVyZXMgbm8gdGV4dCwganVzdCBlbW9qaVxyXG5cdFx0XHRcdFx0dHlwZSA9ICdFbW9qaSc7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdC8vIDUuKSBcIlRoZSBsYWJlbCBtdXN0IG5vdCBiZWdpbiB3aXRoIGEgY29tYmluaW5nIG1hcmssIHRoYXQgaXM6IEdlbmVyYWxfQ2F0ZWdvcnk9TWFyay5cIlxyXG5cdFx0XHRcdFx0aWYgKENNLmhhcyhub3JtWzBdKSkgdGhyb3cgZXJyb3JfcGxhY2VtZW50KCdsZWFkaW5nIGNvbWJpbmluZyBtYXJrJyk7XHJcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IHRva2VuX2NvdW50OyBpKyspIHsgLy8gd2UndmUgYWxyZWFkeSBjaGVja2VkIHRoZSBmaXJzdCB0b2tlblxyXG5cdFx0XHRcdFx0XHRsZXQgY3BzID0gdG9rZW5zW2ldO1xyXG5cdFx0XHRcdFx0XHRpZiAoIWNwcy5pc19lbW9qaSAmJiBDTS5oYXMoY3BzWzBdKSkgeyAvLyBldmVyeSB0ZXh0IHRva2VuIGhhcyBlbW9qaSBuZWlnaGJvcnMsIGVnLiBFdEVFRXRFdC4uLlxyXG5cdFx0XHRcdFx0XHRcdC8vIGJpZGlfcXEoKSBub3QgbmVlZGVkIHNpbmNlIGVtb2ppIGlzIExUUiBhbmQgY3BzIGlzIGEgQ01cclxuXHRcdFx0XHRcdFx0XHR0aHJvdyBlcnJvcl9wbGFjZW1lbnQoYGVtb2ppICsgY29tYmluaW5nIG1hcms6IFwiJHtzdHJfZnJvbV9jcHModG9rZW5zW2ktMV0pfSArICR7c2FmZV9zdHJfZnJvbV9jcHMoW2Nwc1swXV0pfVwiYCk7IFxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRjaGVja19mZW5jZWQobm9ybSk7XHJcblx0XHRcdFx0XHRsZXQgdW5pcXVlID0gQXJyYXlfZnJvbShuZXcgU2V0KGNoYXJzKSk7XHJcblx0XHRcdFx0XHRsZXQgW2ddID0gZGV0ZXJtaW5lX2dyb3VwKHVuaXF1ZSk7IC8vIHRha2UgdGhlIGZpcnN0IG1hdGNoXHJcblx0XHRcdFx0XHQvLyBzZWUgZGVyaXZlOiBcIk1hdGNoaW5nIEdyb3VwcyBoYXZlIFNhbWUgQ00gU3R5bGVcIlxyXG5cdFx0XHRcdFx0Ly8gYWx0ZXJuYXRpdmU6IGNvdWxkIGZvcm0gYSBoeWJyaWQgdHlwZTogTGF0aW4vSmFwYW5lc2UvLi4uXHRcclxuXHRcdFx0XHRcdGNoZWNrX2dyb3VwKGcsIGNoYXJzKTsgLy8gbmVlZCB0ZXh0IGluIG9yZGVyXHJcblx0XHRcdFx0XHRjaGVja193aG9sZShnLCB1bmlxdWUpOyAvLyBvbmx5IG5lZWQgdW5pcXVlIHRleHQgKG9yZGVyIHdvdWxkIGJlIHJlcXVpcmVkIGZvciBtdWx0aXBsZS1jaGFyIGNvbmZ1c2FibGVzKVxyXG5cdFx0XHRcdFx0dHlwZSA9IGcuTjtcclxuXHRcdFx0XHRcdC8vIDIwMjMwMTIxOiBjb25zaWRlciBleHBvc2luZyByZXN0cmljdGVkIGZsYWdcclxuXHRcdFx0XHRcdC8vIGl0J3Mgc2ltcGxlciB0byBqdXN0IGNoZWNrIGZvciAnUmVzdHJpY3RlZCdcclxuXHRcdFx0XHRcdC8vIG9yIGV2ZW4gYmV0dGVyOiB0eXBlLmVuZHNXaXRoKCddJylcclxuXHRcdFx0XHRcdC8vaWYgKGcuUikgaW5mby5yZXN0cmljdGVkID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aW5mby50eXBlID0gdHlwZTtcclxuXHRcdH0gY2F0Y2ggKGVycikge1xyXG5cdFx0XHRpbmZvLmVycm9yID0gZXJyOyAvLyB1c2UgZnVsbCBlcnJvciBvYmplY3RcclxuXHRcdH1cclxuXHRcdHJldHVybiBpbmZvO1xyXG5cdH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja193aG9sZShncm91cCwgdW5pcXVlKSB7XHJcblx0bGV0IG1ha2VyO1xyXG5cdGxldCBzaGFyZWQgPSBbXTtcclxuXHRmb3IgKGxldCBjcCBvZiB1bmlxdWUpIHtcclxuXHRcdGxldCB3aG9sZSA9IFdIT0xFX01BUC5nZXQoY3ApO1xyXG5cdFx0aWYgKHdob2xlID09PSBVTklRVUVfUEgpIHJldHVybjsgLy8gdW5pcXVlLCBub24tY29uZnVzYWJsZVxyXG5cdFx0aWYgKHdob2xlKSB7XHJcblx0XHRcdGxldCBzZXQgPSB3aG9sZS5NLmdldChjcCk7IC8vIGdyb3VwcyB3aGljaCBoYXZlIGEgY2hhcmFjdGVyIHRoYXQgbG9vay1saWtlIHRoaXMgY2hhcmFjdGVyXHJcblx0XHRcdG1ha2VyID0gbWFrZXIgPyBtYWtlci5maWx0ZXIoZyA9PiBzZXQuaGFzKGcpKSA6IEFycmF5X2Zyb20oc2V0KTtcclxuXHRcdFx0aWYgKCFtYWtlci5sZW5ndGgpIHJldHVybjsgLy8gY29uZnVzYWJsZSBpbnRlcnNlY3Rpb24gaXMgZW1wdHlcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHNoYXJlZC5wdXNoKGNwKTsgXHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChtYWtlcikge1xyXG5cdFx0Ly8gd2UgaGF2ZSAxKyBjb25mdXNhYmxlXHJcblx0XHQvLyBjaGVjayBpZiBhbnkgb2YgdGhlIHJlbWFpbmluZyBncm91cHNcclxuXHRcdC8vIGNvbnRhaW4gdGhlIHNoYXJlZCBjaGFyYWN0ZXJzIHRvb1xyXG5cdFx0Zm9yIChsZXQgZyBvZiBtYWtlcikge1xyXG5cdFx0XHRpZiAoc2hhcmVkLmV2ZXJ5KGNwID0+IGdyb3VwX2hhc19jcChnLCBjcCkpKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGB3aG9sZS1zY3JpcHQgY29uZnVzYWJsZTogJHtncm91cC5OfS8ke2cuTn1gKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuLy8gYXNzdW1wdGlvbjogdW5pcXVlLnNpemUgPiAwXHJcbi8vIHJldHVybnMgbGlzdCBvZiBtYXRjaGluZyBncm91cHNcclxuZnVuY3Rpb24gZGV0ZXJtaW5lX2dyb3VwKHVuaXF1ZSkge1xyXG5cdGxldCBncm91cHMgPSBHUk9VUFM7XHJcblx0Zm9yIChsZXQgY3Agb2YgdW5pcXVlKSB7XHJcblx0XHQvLyBub3RlOiB3ZSBuZWVkIHRvIGRvZGdlIENNIHRoYXQgYXJlIHdoaXRlbGlzdGVkXHJcblx0XHQvLyBidXQgdGhhdCBjb2RlIGlzbid0IGN1cnJlbnRseSBuZWNlc3NhcnlcclxuXHRcdGxldCBncyA9IGdyb3Vwcy5maWx0ZXIoZyA9PiBncm91cF9oYXNfY3AoZywgY3ApKTtcclxuXHRcdGlmICghZ3MubGVuZ3RoKSB7XHJcblx0XHRcdGlmICghR1JPVVBTLnNvbWUoZyA9PiBncm91cF9oYXNfY3AoZywgY3ApKSkgeyBcclxuXHRcdFx0XHQvLyB0aGUgY2hhcmFjdGVyIHdhcyBjb21wb3NlZCBvZiB2YWxpZCBwYXJ0c1xyXG5cdFx0XHRcdC8vIGJ1dCBpdCdzIE5GQyBmb3JtIGlzIGludmFsaWRcclxuXHRcdFx0XHQvLyAyMDIzMDcxNjogY2hhbmdlIHRvIG1vcmUgZXhhY3Qgc3RhdGVtZW50LCBzZWU6IEVOU05vcm1hbGl6ZS57Y3MsamF2YX1cclxuXHRcdFx0XHQvLyBub3RlOiB0aGlzIGRvZXNuJ3QgaGF2ZSB0byBiZSBhIGNvbXBvc2l0aW9uXHJcblx0XHRcdFx0Ly8gMjAyMzA3MjA6IGNoYW5nZSB0byBmdWxsIGNoZWNrXHJcblx0XHRcdFx0dGhyb3cgZXJyb3JfZGlzYWxsb3dlZChjcCk7IC8vIHRoaXMgc2hvdWxkIGJlIHJhcmVcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyB0aGVyZSBpcyBubyBncm91cCB0aGF0IGNvbnRhaW5zIGFsbCB0aGVzZSBjaGFyYWN0ZXJzXHJcblx0XHRcdFx0Ly8gdGhyb3cgdXNpbmcgdGhlIGhpZ2hlc3QgcHJpb3JpdHkgZ3JvdXAgdGhhdCBtYXRjaGVkXHJcblx0XHRcdFx0Ly8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM5LyNtaXhlZF9zY3JpcHRfY29uZnVzYWJsZXNcclxuXHRcdFx0XHR0aHJvdyBlcnJvcl9ncm91cF9tZW1iZXIoZ3JvdXBzWzBdLCBjcCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGdyb3VwcyA9IGdzO1xyXG5cdFx0aWYgKGdzLmxlbmd0aCA9PSAxKSBicmVhazsgLy8gdGhlcmUgaXMgb25seSBvbmUgZ3JvdXAgbGVmdFxyXG5cdH1cclxuXHQvLyB0aGVyZSBhcmUgYXQgbGVhc3QgMSBncm91cChzKSB3aXRoIGFsbCBvZiB0aGVzZSBjaGFyYWN0ZXJzXHJcblx0cmV0dXJuIGdyb3VwcztcclxufVxyXG5cclxuLy8gdGhyb3cgb24gZmlyc3QgZXJyb3JcclxuZnVuY3Rpb24gZmxhdHRlbihzcGxpdCkge1xyXG5cdHJldHVybiBzcGxpdC5tYXAoKHtpbnB1dCwgZXJyb3IsIG91dHB1dH0pID0+IHtcclxuXHRcdGlmIChlcnJvcikge1xyXG5cdFx0XHQvLyBkb24ndCBwcmludCBsYWJlbCBhZ2FpbiBpZiBqdXN0IGEgc2luZ2xlIGxhYmVsXHJcblx0XHRcdGxldCBtc2cgPSBlcnJvci5tZXNzYWdlO1xyXG5cdFx0XHQvLyBiaWRpX3FxKCkgb25seSBuZWNlc3NhcnkgaWYgbXNnIGlzIGRpZ2l0c1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3Ioc3BsaXQubGVuZ3RoID09IDEgPyBtc2cgOiBgSW52YWxpZCBsYWJlbCAke2JpZGlfcXEoc2FmZV9zdHJfZnJvbV9jcHMoaW5wdXQsIDYzKSl9OiAke21zZ31gKTsgXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gc3RyX2Zyb21fY3BzKG91dHB1dCk7XHJcblx0fSkuam9pbihTVE9QX0NIKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXJyb3JfZGlzYWxsb3dlZChjcCkge1xyXG5cdC8vIFRPRE86IGFkZCBjcCB0byBlcnJvcj9cclxuXHRyZXR1cm4gbmV3IEVycm9yKGBkaXNhbGxvd2VkIGNoYXJhY3RlcjogJHtxdW90ZWRfY3AoY3ApfWApOyBcclxufVxyXG5mdW5jdGlvbiBlcnJvcl9ncm91cF9tZW1iZXIoZywgY3ApIHtcclxuXHRsZXQgcXVvdGVkID0gcXVvdGVkX2NwKGNwKTtcclxuXHRsZXQgZ2cgPSBHUk9VUFMuZmluZChnID0+IGcuUC5oYXMoY3ApKTsgLy8gb25seSBjaGVjayBwcmltYXJ5XHJcblx0aWYgKGdnKSB7XHJcblx0XHRxdW90ZWQgPSBgJHtnZy5OfSAke3F1b3RlZH1gO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IEVycm9yKGBpbGxlZ2FsIG1peHR1cmU6ICR7Zy5OfSArICR7cXVvdGVkfWApO1xyXG59XHJcbmZ1bmN0aW9uIGVycm9yX3BsYWNlbWVudCh3aGVyZSkge1xyXG5cdHJldHVybiBuZXcgRXJyb3IoYGlsbGVnYWwgcGxhY2VtZW50OiAke3doZXJlfWApO1xyXG59XHJcblxyXG4vLyBhc3N1bXB0aW9uOiBjcHMubGVuZ3RoID4gMFxyXG4vLyBhc3N1bXB0aW9uOiBjcHNbMF0gaXNuJ3QgYSBDTVxyXG4vLyBhc3N1bXB0aW9uOiB0aGUgcHJldmlvdXMgY2hhcmFjdGVyIGlzbid0IGFuIGVtb2ppXHJcbmZ1bmN0aW9uIGNoZWNrX2dyb3VwKGcsIGNwcykge1xyXG5cdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0aWYgKCFncm91cF9oYXNfY3AoZywgY3ApKSB7XHJcblx0XHRcdC8vIGZvciB3aGl0ZWxpc3RlZCBzY3JpcHRzLCB0aGlzIHdpbGwgdGhyb3cgaWxsZWdhbCBtaXh0dXJlIG9uIGludmFsaWQgY20sIGVnLiBcImV7MzAwfXszMDB9XCJcclxuXHRcdFx0Ly8gYXQgdGhlIG1vbWVudCwgaXQncyB1bm5lY2Vzc2FyeSB0byBpbnRyb2R1Y2UgYW4gZXh0cmEgZXJyb3IgdHlwZVxyXG5cdFx0XHQvLyB1bnRpbCB0aGVyZSBleGlzdHMgYSB3aGl0ZWxpc3RlZCBtdWx0aS1jaGFyYWN0ZXJcclxuXHRcdFx0Ly8gICBlZy4gaWYgKE0gPCAwICYmIGlzX2NvbWJpbmluZ19tYXJrKGNwKSkgeyAuLi4gfVxyXG5cdFx0XHQvLyB0aGVyZSBhcmUgMyBjYXNlczpcclxuXHRcdFx0Ly8gICAxLiBpbGxlZ2FsIGNtIGZvciB3cm9uZyBncm91cCA9PiBtaXh0dXJlIGVycm9yXHJcblx0XHRcdC8vICAgMi4gaWxsZWdhbCBjbSBmb3Igc2FtZSBncm91cCA9PiBjbSBlcnJvclxyXG5cdFx0XHQvLyAgICAgICByZXF1aXJlcyBzZXQgb2Ygd2hpdGVsaXN0IGNtIHBlciBncm91cDogXHJcblx0XHRcdC8vICAgICAgICBlZy4gbmV3IFNldChbLi4uZy5QLCAuLi5nLlFdLmZsYXRNYXAobmZjKS5maWx0ZXIoY3AgPT4gQ00uaGFzKGNwKSkpXHJcblx0XHRcdC8vICAgMy4gd3JvbmcgZ3JvdXAgPT4gbWl4dHVyZSBlcnJvclxyXG5cdFx0XHR0aHJvdyBlcnJvcl9ncm91cF9tZW1iZXIoZywgY3ApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHQvL2lmIChNID49IDApIHsgLy8gd2UgaGF2ZSBhIGtub3duIGZpeGVkIGNtIGNvdW50XHJcblx0aWYgKGcuTSkgeyAvLyB3ZSBuZWVkIHRvIGNoZWNrIGZvciBOU01cclxuXHRcdGxldCBkZWNvbXBvc2VkID0gbmZkKGNwcyk7XHJcblx0XHRmb3IgKGxldCBpID0gMSwgZSA9IGRlY29tcG9zZWQubGVuZ3RoOyBpIDwgZTsgaSsrKSB7IC8vIHNlZTogYXNzdW1wdGlvblxyXG5cdFx0XHQvLyAyMDIzMDIxMDogYnVnZml4OiB1c2luZyBjcHMgaW5zdGVhZCBvZiBkZWNvbXBvc2VkIGgvdCBDYXJib24yMjVcclxuXHRcdFx0LypcclxuXHRcdFx0aWYgKENNLmhhcyhkZWNvbXBvc2VkW2ldKSkge1xyXG5cdFx0XHRcdGxldCBqID0gaSArIDE7XHJcblx0XHRcdFx0d2hpbGUgKGogPCBlICYmIENNLmhhcyhkZWNvbXBvc2VkW2pdKSkgaisrO1xyXG5cdFx0XHRcdGlmIChqIC0gaSA+IE0pIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgdG9vIG1hbnkgY29tYmluaW5nIG1hcmtzOiAke2cuTn0gJHtiaWRpX3FxKHN0cl9mcm9tX2NwcyhkZWNvbXBvc2VkLnNsaWNlKGktMSwgaikpKX0gKCR7ai1pfS8ke019KWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpID0gajtcclxuXHRcdFx0fVxyXG5cdFx0XHQqL1xyXG5cdFx0XHQvLyAyMDIzMDIxNzogc3dpdGNoIHRvIE5TTSBjb3VudGluZ1xyXG5cdFx0XHQvLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzkvI09wdGlvbmFsX0RldGVjdGlvblxyXG5cdFx0XHRpZiAoTlNNLmhhcyhkZWNvbXBvc2VkW2ldKSkge1xyXG5cdFx0XHRcdGxldCBqID0gaSArIDE7XHJcblx0XHRcdFx0Zm9yIChsZXQgY3A7IGogPCBlICYmIE5TTS5oYXMoY3AgPSBkZWNvbXBvc2VkW2pdKTsgaisrKSB7XHJcblx0XHRcdFx0XHQvLyBhLiBGb3JiaWQgc2VxdWVuY2VzIG9mIHRoZSBzYW1lIG5vbnNwYWNpbmcgbWFyay5cclxuXHRcdFx0XHRcdGZvciAobGV0IGsgPSBpOyBrIDwgajsgaysrKSB7IC8vIE8obl4yKSBidXQgbiA8IDEwMFxyXG5cdFx0XHRcdFx0XHRpZiAoZGVjb21wb3NlZFtrXSA9PSBjcCkge1xyXG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlIG5vbi1zcGFjaW5nIG1hcmtzOiAke3F1b3RlZF9jcChjcCl9YCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gcGFyc2UgdG8gZW5kIHNvIHdlIGhhdmUgZnVsbCBuc20gY291bnRcclxuXHRcdFx0XHQvLyBiLiBGb3JiaWQgc2VxdWVuY2VzIG9mIG1vcmUgdGhhbiA0IG5vbnNwYWNpbmcgbWFya3MgKGdjPU1uIG9yIGdjPU1lKS5cclxuXHRcdFx0XHRpZiAoaiAtIGkgPiBOU01fTUFYKSB7XHJcblx0XHRcdFx0XHQvLyBub3RlOiB0aGlzIHNsaWNlIHN0YXJ0cyB3aXRoIGEgYmFzZSBjaGFyIG9yIHNwYWNpbmctbWFyayBjbVxyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBleGNlc3NpdmUgbm9uLXNwYWNpbmcgbWFya3M6ICR7YmlkaV9xcShzYWZlX3N0cl9mcm9tX2NwcyhkZWNvbXBvc2VkLnNsaWNlKGktMSwgaikpKX0gKCR7ai1pfS8ke05TTV9NQVh9KWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpID0gajtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHQvLyAqKiogdGhpcyBjb2RlIGN1cnJlbnRseSBpc24ndCBuZWVkZWQgKioqXHJcblx0LypcclxuXHRsZXQgY21fd2hpdGVsaXN0ID0gTSBpbnN0YW5jZW9mIE1hcDtcclxuXHRmb3IgKGxldCBpID0gMCwgZSA9IGNwcy5sZW5ndGg7IGkgPCBlOyApIHtcclxuXHRcdGxldCBjcCA9IGNwc1tpKytdO1xyXG5cdFx0bGV0IHNlcXMgPSBjbV93aGl0ZWxpc3QgJiYgTS5nZXQoY3ApO1xyXG5cdFx0aWYgKHNlcXMpIHsgXHJcblx0XHRcdC8vIGxpc3Qgb2YgY29kZXBvaW50cyB0aGF0IGNhbiBmb2xsb3dcclxuXHRcdFx0Ly8gaWYgdGhpcyBleGlzdHMsIHRoaXMgd2lsbCBhbHdheXMgYmUgMStcclxuXHRcdFx0bGV0IGogPSBpO1xyXG5cdFx0XHR3aGlsZSAoaiA8IGUgJiYgQ00uaGFzKGNwc1tqXSkpIGorKztcclxuXHRcdFx0bGV0IGNtcyA9IGNwcy5zbGljZShpLCBqKTtcclxuXHRcdFx0bGV0IG1hdGNoID0gc2Vxcy5maW5kKHNlcSA9PiAhY29tcGFyZV9hcnJheXMoc2VxLCBjbXMpKTtcclxuXHRcdFx0aWYgKCFtYXRjaCkgdGhyb3cgbmV3IEVycm9yKGBkaXNhbGxvd2VkIGNvbWJpbmluZyBtYXJrIHNlcXVlbmNlOiBcIiR7c2FmZV9zdHJfZnJvbV9jcHMoW2NwLCAuLi5jbXNdKX1cImApO1xyXG5cdFx0XHRpID0gajtcclxuXHRcdH0gZWxzZSBpZiAoIVYuaGFzKGNwKSkge1xyXG5cdFx0XHQvLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzkvI21peGVkX3NjcmlwdF9jb25mdXNhYmxlc1xyXG5cdFx0XHRsZXQgcXVvdGVkID0gcXVvdGVkX2NwKGNwKTtcclxuXHRcdFx0Zm9yIChsZXQgY3Agb2YgY3BzKSB7XHJcblx0XHRcdFx0bGV0IHUgPSBVTklRVUUuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAodSAmJiB1ICE9PSBnKSB7XHJcblx0XHRcdFx0XHQvLyBpZiBib3RoIHNjcmlwdHMgYXJlIHJlc3RyaWN0ZWQgdGhpcyBlcnJvciBpcyBjb25mdXNpbmdcclxuXHRcdFx0XHRcdC8vIGJlY2F1c2Ugd2UgZG9uJ3QgZGlmZmVyZW50aWF0ZSBSZXN0cmljdGVkQSBmcm9tIFJlc3RyaWN0ZWRCIFxyXG5cdFx0XHRcdFx0aWYgKCF1LlIpIHF1b3RlZCA9IGAke3F1b3RlZH0gaXMgJHt1Lk59YDtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGRpc2FsbG93ZWQgJHtnLk59IGNoYXJhY3RlcjogJHtxdW90ZWR9YCk7XHJcblx0XHRcdC8vdGhyb3cgbmV3IEVycm9yKGBkaXNhbGxvd2VkIGNoYXJhY3RlcjogJHtxdW90ZWR9IChleHBlY3RlZCAke2cuTn0pYCk7XHJcblx0XHRcdC8vdGhyb3cgbmV3IEVycm9yKGAke2cuTn0gZG9lcyBub3QgYWxsb3c6ICR7cXVvdGVkfWApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoIWNtX3doaXRlbGlzdCkge1xyXG5cdFx0bGV0IGRlY29tcG9zZWQgPSBuZmQoY3BzKTtcclxuXHRcdGZvciAobGV0IGkgPSAxLCBlID0gZGVjb21wb3NlZC5sZW5ndGg7IGkgPCBlOyBpKyspIHsgLy8gd2Uga25vdyBpdCBjYW4ndCBiZSBjbSBsZWFkaW5nXHJcblx0XHRcdGlmIChDTS5oYXMoZGVjb21wb3NlZFtpXSkpIHtcclxuXHRcdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHRcdHdoaWxlIChqIDwgZSAmJiBDTS5oYXMoZGVjb21wb3NlZFtqXSkpIGorKztcclxuXHRcdFx0XHRpZiAoaiAtIGkgPiBNKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHRvbyBtYW55IGNvbWJpbmluZyBtYXJrczogXCIke3N0cl9mcm9tX2NwcyhkZWNvbXBvc2VkLnNsaWNlKGktMSwgaikpfVwiICgke2otaX0vJHtNfSlgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aSA9IGo7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0Ki9cclxufVxyXG5cclxuLy8gZ2l2ZW4gYSBsaXN0IG9mIGNvZGVwb2ludHNcclxuLy8gcmV0dXJucyBhIGxpc3Qgb2YgbGlzdHMsIHdoZXJlIGVtb2ppIGFyZSBhIGZ1bGx5LXF1YWxpZmllZCAoYXMgQXJyYXkgc3ViY2xhc3MpXHJcbi8vIGVnLiBleHBsb2RlX2NwKFwiYWJj8J+SqWRcIikgPT4gW1s2MSwgNjIsIDYzXSwgRW1vamlbMUY0QTksIEZFMEZdLCBbNjRdXVxyXG4vLyAyMDIzMDgxODogcmVuYW1lIGZvciAncHJvY2VzcycgbmFtZSBjb2xsaXNpb24gaC90IEphdmFyb21lXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMvaXNzdWVzLzIzXHJcbmZ1bmN0aW9uIHRva2Vuc19mcm9tX3N0cihpbnB1dCwgbmYsIGVmKSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdGxldCBjaGFycyA9IFtdO1xyXG5cdGlucHV0ID0gaW5wdXQuc2xpY2UoKS5yZXZlcnNlKCk7IC8vIGZsaXAgc28gd2UgY2FuIHBvcFxyXG5cdHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcclxuXHRcdGxldCBlbW9qaSA9IGNvbnN1bWVfZW1vamlfcmV2ZXJzZWQoaW5wdXQpO1xyXG5cdFx0aWYgKGVtb2ppKSB7XHJcblx0XHRcdGlmIChjaGFycy5sZW5ndGgpIHtcclxuXHRcdFx0XHRyZXQucHVzaChuZihjaGFycykpO1xyXG5cdFx0XHRcdGNoYXJzID0gW107XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0LnB1c2goZWYoZW1vamkpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBjcCA9IGlucHV0LnBvcCgpO1xyXG5cdFx0XHRpZiAoVkFMSUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdGNoYXJzLnB1c2goY3ApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBjcHMgPSBNQVBQRUQuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAoY3BzKSB7XHJcblx0XHRcdFx0XHRjaGFycy5wdXNoKC4uLmNwcyk7IC8vIGxlc3MgdGhhbiAxMCBlbGVtZW50c1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIUlHTk9SRUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdFx0Ly8gMjAyMzA5MTI6IHVuaWNvZGUgMTUuMSBjaGFuZ2VkIHRoZSBvcmRlciBvZiBwcm9jZXNzaW5nIHN1Y2ggdGhhdFxyXG5cdFx0XHRcdFx0Ly8gZGlzYWxsb3dlZCBwYXJ0cyBhcmUgb25seSByZWplY3RlZCBhZnRlciBORkNcclxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjQ2LyNWYWxpZGl0eV9Dcml0ZXJpYVxyXG5cdFx0XHRcdFx0Ly8gdGhpcyBkb2Vzbid0IGltcGFjdCBub3JtYWxpemF0aW9uIGFzIG9mIHRvZGF5XHJcblx0XHRcdFx0XHQvLyB0ZWNobmljYWxseSwgdGhpcyBlcnJvciBjYW4gYmUgcmVtb3ZlZCBhcyB0aGUgZ3JvdXAgbG9naWMgd2lsbCBhcHBseSBzaW1pbGFyIGxvZ2ljXHJcblx0XHRcdFx0XHQvLyBob3dldmVyIHRoZSBlcnJvciB0eXBlIG1pZ2h0IGJlIGxlc3MgY2xlYXJcclxuXHRcdFx0XHRcdHRocm93IGVycm9yX2Rpc2FsbG93ZWQoY3ApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoY2hhcnMubGVuZ3RoKSB7XHJcblx0XHRyZXQucHVzaChuZihjaGFycykpO1xyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaWx0ZXJfZmUwZihjcHMpIHtcclxuXHRyZXR1cm4gY3BzLmZpbHRlcihjcCA9PiBjcCAhPSBGRTBGKTtcclxufVxyXG5cclxuLy8gZ2l2ZW4gYXJyYXkgb2YgY29kZXBvaW50c1xyXG4vLyByZXR1cm5zIHRoZSBsb25nZXN0IHZhbGlkIGVtb2ppIHNlcXVlbmNlIChvciB1bmRlZmluZWQgaWYgbm8gbWF0Y2gpXHJcbi8vICpNVVRBVEVTKiB0aGUgc3VwcGxpZWQgYXJyYXlcclxuLy8gZGlzYWxsb3dzIGludGVybGVhdmVkIGlnbm9yZWQgY2hhcmFjdGVyc1xyXG4vLyBmaWxscyAob3B0aW9uYWwpIGVhdGVuIGFycmF5IHdpdGggbWF0Y2hlZCBjb2RlcG9pbnRzXHJcbmZ1bmN0aW9uIGNvbnN1bWVfZW1vamlfcmV2ZXJzZWQoY3BzLCBlYXRlbikge1xyXG5cdGxldCBub2RlID0gRU1PSklfUk9PVDtcclxuXHRsZXQgZW1vamk7XHJcblx0bGV0IHBvcyA9IGNwcy5sZW5ndGg7XHJcblx0d2hpbGUgKHBvcykge1xyXG5cdFx0bm9kZSA9IG5vZGUuZ2V0KGNwc1stLXBvc10pO1xyXG5cdFx0aWYgKCFub2RlKSBicmVhaztcclxuXHRcdGxldCB7Vn0gPSBub2RlO1xyXG5cdFx0aWYgKFYpIHsgLy8gdGhpcyBpcyBhIHZhbGlkIGVtb2ppIChzbyBmYXIpXHJcblx0XHRcdGVtb2ppID0gVjtcclxuXHRcdFx0aWYgKGVhdGVuKSBlYXRlbi5wdXNoKC4uLmNwcy5zbGljZShwb3MpLnJldmVyc2UoKSk7IC8vIChvcHRpb25hbCkgY29weSBpbnB1dCwgdXNlZCBmb3IgZW5zX3Rva2VuaXplKClcclxuXHRcdFx0Y3BzLmxlbmd0aCA9IHBvczsgLy8gdHJ1bmNhdGVcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGVtb2ppO1xyXG59XHJcblxyXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gdG9rZW5pemVyIFxyXG5cclxuY29uc3QgVFlfVkFMSUQgPSAndmFsaWQnO1xyXG5jb25zdCBUWV9NQVBQRUQgPSAnbWFwcGVkJztcclxuY29uc3QgVFlfSUdOT1JFRCA9ICdpZ25vcmVkJztcclxuY29uc3QgVFlfRElTQUxMT1dFRCA9ICdkaXNhbGxvd2VkJztcclxuY29uc3QgVFlfRU1PSkkgPSAnZW1vamknO1xyXG5jb25zdCBUWV9ORkMgPSAnbmZjJztcclxuY29uc3QgVFlfU1RPUCA9ICdzdG9wJztcclxuXHJcbmZ1bmN0aW9uIGVuc190b2tlbml6ZShuYW1lLCB7XHJcblx0bmYgPSB0cnVlLCAvLyBjb2xsYXBzZSB1bm5vcm1hbGl6ZWQgcnVucyBpbnRvIGEgc2luZ2xlIHRva2VuXHJcbn0gPSB7fSkge1xyXG5cdGluaXQoKTtcclxuXHRsZXQgaW5wdXQgPSBleHBsb2RlX2NwKG5hbWUpLnJldmVyc2UoKTtcclxuXHRsZXQgZWF0ZW4gPSBbXTtcclxuXHRsZXQgdG9rZW5zID0gW107XHJcblx0d2hpbGUgKGlucHV0Lmxlbmd0aCkge1xyXG5cdFx0bGV0IGVtb2ppID0gY29uc3VtZV9lbW9qaV9yZXZlcnNlZChpbnB1dCwgZWF0ZW4pO1xyXG5cdFx0aWYgKGVtb2ppKSB7XHJcblx0XHRcdHRva2Vucy5wdXNoKHtcclxuXHRcdFx0XHR0eXBlOiBUWV9FTU9KSSxcclxuXHRcdFx0XHRlbW9qaTogZW1vamkuc2xpY2UoKSwgLy8gY29weSBlbW9qaVxyXG5cdFx0XHRcdGlucHV0OiBlYXRlbixcclxuXHRcdFx0XHRjcHM6IGZpbHRlcl9mZTBmKGVtb2ppKVxyXG5cdFx0XHR9KTtcclxuXHRcdFx0ZWF0ZW4gPSBbXTsgLy8gcmVzZXQgYnVmZmVyXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgY3AgPSBpbnB1dC5wb3AoKTtcclxuXHRcdFx0aWYgKGNwID09IFNUT1ApIHtcclxuXHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogVFlfU1RPUCwgY3B9KTtcclxuXHRcdFx0fSBlbHNlIGlmIChWQUxJRC5oYXMoY3ApKSB7XHJcblx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX1ZBTElELCBjcHM6IFtjcF19KTtcclxuXHRcdFx0fSBlbHNlIGlmIChJR05PUkVELmhhcyhjcCkpIHtcclxuXHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogVFlfSUdOT1JFRCwgY3B9KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgY3BzID0gTUFQUEVELmdldChjcCk7XHJcblx0XHRcdFx0aWYgKGNwcykge1xyXG5cdFx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX01BUFBFRCwgY3AsIGNwczogY3BzLnNsaWNlKCl9KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX0RJU0FMTE9XRUQsIGNwfSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChuZikge1xyXG5cdFx0Zm9yIChsZXQgaSA9IDAsIHN0YXJ0ID0gLTE7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IHRva2VuID0gdG9rZW5zW2ldO1xyXG5cdFx0XHRpZiAoaXNfdmFsaWRfb3JfbWFwcGVkKHRva2VuLnR5cGUpKSB7XHJcblx0XHRcdFx0aWYgKHJlcXVpcmVzX2NoZWNrKHRva2VuLmNwcykpIHsgLy8gbm9ybWFsaXphdGlvbiBtaWdodCBiZSBuZWVkZWRcclxuXHRcdFx0XHRcdGxldCBlbmQgPSBpICsgMTtcclxuXHRcdFx0XHRcdGZvciAobGV0IHBvcyA9IGVuZDsgcG9zIDwgdG9rZW5zLmxlbmd0aDsgcG9zKyspIHsgLy8gZmluZCBhZGphY2VudCB0ZXh0XHJcblx0XHRcdFx0XHRcdGxldCB7dHlwZSwgY3BzfSA9IHRva2Vuc1twb3NdO1xyXG5cdFx0XHRcdFx0XHRpZiAoaXNfdmFsaWRfb3JfbWFwcGVkKHR5cGUpKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKCFyZXF1aXJlc19jaGVjayhjcHMpKSBicmVhaztcclxuXHRcdFx0XHRcdFx0XHRlbmQgPSBwb3MgKyAxO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgIT09IFRZX0lHTk9SRUQpIHsgLy8gfHwgdHlwZSAhPT0gVFlfRElTQUxMT1dFRCkgeyBcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBpO1xyXG5cdFx0XHRcdFx0bGV0IHNsaWNlID0gdG9rZW5zLnNsaWNlKHN0YXJ0LCBlbmQpO1xyXG5cdFx0XHRcdFx0bGV0IGNwczAgPSBzbGljZS5mbGF0TWFwKHggPT4gaXNfdmFsaWRfb3JfbWFwcGVkKHgudHlwZSkgPyB4LmNwcyA6IFtdKTsgLy8gc3RyaXAganVuayB0b2tlbnNcclxuXHRcdFx0XHRcdGxldCBjcHMgPSBuZmMoY3BzMCk7XHJcblx0XHRcdFx0XHRpZiAoY29tcGFyZV9hcnJheXMoY3BzLCBjcHMwKSkgeyAvLyBidW5kbGUgaW50byBhbiBuZmMgdG9rZW5cclxuXHRcdFx0XHRcdFx0dG9rZW5zLnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQsIHtcclxuXHRcdFx0XHRcdFx0XHR0eXBlOiBUWV9ORkMsIFxyXG5cdFx0XHRcdFx0XHRcdGlucHV0OiBjcHMwLCAvLyB0aGVyZSBhcmUgMyBzdGF0ZXM6IHRva2VuczAgPT0ocHJvY2Vzcyk9PiBpbnB1dCA9PShuZmMpPT4gdG9rZW5zL2Nwc1xyXG5cdFx0XHRcdFx0XHRcdGNwcywgXHJcblx0XHRcdFx0XHRcdFx0dG9rZW5zMDogY29sbGFwc2VfdmFsaWRfdG9rZW5zKHNsaWNlKSxcclxuXHRcdFx0XHRcdFx0XHR0b2tlbnM6IGVuc190b2tlbml6ZShzdHJfZnJvbV9jcHMoY3BzKSwge25mOiBmYWxzZX0pXHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0XHRpID0gc3RhcnQ7XHJcblx0XHRcdFx0XHR9IGVsc2UgeyBcclxuXHRcdFx0XHRcdFx0aSA9IGVuZCAtIDE7IC8vIHNraXAgdG8gZW5kIG9mIHNsaWNlXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRzdGFydCA9IC0xOyAvLyByZXNldFxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRzdGFydCA9IGk7IC8vIHJlbWVtYmVyIGxhc3RcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAodG9rZW4udHlwZSAhPT0gVFlfSUdOT1JFRCkgeyAvLyAyMDIyMTAyNDogaXMgdGhpcyBjb3JyZWN0P1xyXG5cdFx0XHRcdHN0YXJ0ID0gLTE7IC8vIHJlc2V0XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGNvbGxhcHNlX3ZhbGlkX3Rva2Vucyh0b2tlbnMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc192YWxpZF9vcl9tYXBwZWQodHlwZSkge1xyXG5cdHJldHVybiB0eXBlID09IFRZX1ZBTElEIHx8IHR5cGUgPT0gVFlfTUFQUEVEO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXF1aXJlc19jaGVjayhjcHMpIHtcclxuXHRyZXR1cm4gY3BzLnNvbWUoY3AgPT4gTkZDX0NIRUNLLmhhcyhjcCkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb2xsYXBzZV92YWxpZF90b2tlbnModG9rZW5zKSB7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmICh0b2tlbnNbaV0udHlwZSA9PSBUWV9WQUxJRCkge1xyXG5cdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHR3aGlsZSAoaiA8IHRva2Vucy5sZW5ndGggJiYgdG9rZW5zW2pdLnR5cGUgPT0gVFlfVkFMSUQpIGorKztcclxuXHRcdFx0dG9rZW5zLnNwbGljZShpLCBqIC0gaSwge3R5cGU6IFRZX1ZBTElELCBjcHM6IHRva2Vucy5zbGljZShpLCBqKS5mbGF0TWFwKHggPT4geC5jcHMpfSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiB0b2tlbnM7XHJcbn1cblxuZXhwb3J0IHsgZW5zX2JlYXV0aWZ5LCBlbnNfZW1vamksIGVuc19ub3JtYWxpemUsIGVuc19ub3JtYWxpemVfZnJhZ21lbnQsIGVuc19zcGxpdCwgZW5zX3Rva2VuaXplLCBpc19jb21iaW5pbmdfbWFyaywgbmZjLCBuZmQsIHNhZmVfc3RyX2Zyb21fY3BzLCBzaG91bGRfZXNjYXBlIH07XG4iXSwibmFtZXMiOlsiQ09NUFJFU1NFRCQxIiwiRkVOQ0VEIiwiTWFwIiwiTlNNX01BWCIsImRlY29kZV9hcml0aG1ldGljIiwiYnl0ZXMiLCJwb3MiLCJ1MTYiLCJzeW1ib2xfY291bnQiLCJ0b3RhbCIsImFjYyIsImkiLCJwdXNoIiwic2tpcCIsInBvc19wYXlsb2FkIiwicmVhZF93aWR0aCIsInJlYWRfYnVmZmVyIiwicmVhZF9iaXQiLCJOIiwiRlVMTCIsIkhBTEYiLCJRUlRSIiwiTUFTSyIsInJlZ2lzdGVyIiwic3ltYm9scyIsImxvdyIsInJhbmdlIiwidmFsdWUiLCJNYXRoIiwiZmxvb3IiLCJzdGFydCIsImVuZCIsIm1pZCIsImEiLCJiIiwib2Zmc2V0IiwibWFwIiwieCIsInJlYWRfcGF5bG9hZCIsInYiLCJyZWFkX2NvbXByZXNzZWRfcGF5bG9hZCIsInMiLCJ1bnNhZmVfYXRvYiIsImxvb2t1cCIsImZvckVhY2giLCJjIiwiY2hhckNvZGVBdCIsIm4iLCJsZW5ndGgiLCJyZXQiLCJVaW50OEFycmF5Iiwid2lkdGgiLCJjYXJyeSIsInNpZ25lZCIsInJlYWRfZGVsdGFzIiwibmV4dCIsIkFycmF5IiwicmVhZF9zb3J0ZWQiLCJwcmV2IiwicmVhZF9zb3J0ZWRfYXJyYXlzIiwicmVhZF9hcnJheV93aGlsZSIsInJlYWRfbWFwcGVkIiwidyIsInJlYWRfbGluZWFyX3RhYmxlIiwicmVhZF9yZXBsYWNlbWVudF90YWJsZSIsImZsYXQiLCJyZWFkX3RyYW5zcG9zZWQiLCJtIiwiZmlsbCIsImoiLCJkeCIsImR5Iiwidk4iLCJmbGF0TWFwIiwieXMiLCJfIiwial9keSIsInkiLCJzbGljZSIsInJlYWRfdHJpZSIsInNvcnRlZCIsImV4cGFuZCIsImRlY29kZSIsIlEiLCJTIiwiQiIsImNwcyIsInNhdmVkIiwiYnIiLCJjcCIsImhleF9jcCIsInRvU3RyaW5nIiwidG9VcHBlckNhc2UiLCJwYWRTdGFydCIsInF1b3RlX2NwIiwiZXhwbG9kZV9jcCIsImxlbiIsImNvZGVQb2ludEF0Iiwic3RyX2Zyb21fY3BzIiwiY2h1bmsiLCJTdHJpbmciLCJmcm9tQ29kZVBvaW50IiwiYnVmIiwiam9pbiIsImNvbXBhcmVfYXJyYXlzIiwiYXJyYXlfcmVwbGFjZSIsImluZGV4T2YiLCJDT01QUkVTU0VEIiwiUzAiLCJMMCIsIlYwIiwiVDAiLCJMX0NPVU5UIiwiVl9DT1VOVCIsIlRfQ09VTlQiLCJOX0NPVU5UIiwiU19DT1VOVCIsIlMxIiwiTDEiLCJWMSIsIlQxIiwidW5wYWNrX2NjIiwicGFja2VkIiwidW5wYWNrX2NwIiwiU0hJRlRFRF9SQU5LIiwiRVhDTFVTSU9OUyIsIkRFQ09NUCIsIlJFQ09NUCIsImluaXQkMSIsInIiLCJTZXQiLCJoYXMiLCJidWNrZXQiLCJnZXQiLCJzZXQiLCJyZXZlcnNlIiwiaXNfaGFuZ3VsIiwiY29tcG9zZV9wYWlyIiwicmVjb21wIiwiZGVjb21wb3NlZCIsImNoZWNrX29yZGVyIiwiYWRkIiwiY2MiLCJzX2luZGV4IiwibF9pbmRleCIsInZfaW5kZXgiLCJ0X2luZGV4IiwibWFwcGVkIiwicG9wIiwicHJldl9jYyIsInRtcCIsImNvbXBvc2VkX2Zyb21fZGVjb21wb3NlZCIsInN0YWNrIiwicHJldl9jcCIsImNvbXBvc2VkIiwibmZkIiwibmZjIiwiSFlQSEVOIiwiU1RPUCIsIlNUT1BfQ0giLCJGRTBGIiwiVU5JUVVFX1BIIiwiQXJyYXlfZnJvbSIsImZyb20iLCJncm91cF9oYXNfY3AiLCJnIiwiUCIsIkVtb2ppIiwiaXNfZW1vamkiLCJNQVBQRUQiLCJJR05PUkVEIiwiQ00iLCJOU00iLCJFU0NBUEUiLCJORkNfQ0hFQ0siLCJHUk9VUFMiLCJXSE9MRV9WQUxJRCIsIldIT0xFX01BUCIsIlZBTElEIiwiRU1PSklfTElTVCIsIkVNT0pJX1JPT1QiLCJpbml0IiwicmVhZF9zb3J0ZWRfYXJyYXkiLCJyZWFkX3NvcnRlZF9zZXQiLCJzZXRfYWRkX21hbnkiLCJjaHVua3MiLCJ1bnJlc3RyaWN0ZWQiLCJyZWFkX2NodW5rZWQiLCJSIiwiTSIsIndob2xlcyIsImNvbmNhdCIsInNvcnQiLCJkIiwiViIsInZhbHVlcyIsInJlY3MiLCJncyIsImZpbHRlciIsInJlYyIsImZpbmQiLCJHIiwic29tZSIsInVuaW9uIiwiY29tcGxlbWVudCIsIm11bHRpIiwiYWRkX3RvX3VuaW9uIiwibm9kZSIsImNoaWxkIiwicXVvdGVkX2NwIiwic2hvdWxkX2VzY2FwZSIsImJpZGlfcXEiLCJzYWZlX3N0cl9mcm9tX2NwcyIsImNoZWNrX2xhYmVsX2V4dGVuc2lvbiIsIkVycm9yIiwiY2hlY2tfbGVhZGluZ191bmRlcnNjb3JlIiwiVU5ERVJTQ09SRSIsImxhc3RJbmRleE9mIiwiY2hlY2tfZmVuY2VkIiwiZXJyb3JfcGxhY2VtZW50IiwibGFzdCIsIm1hdGNoIiwibWF4IiwiSW5maW5pdHkiLCJxdW90ZXIiLCJpc19jb21iaW5pbmdfbWFyayIsIm9ubHlfbnNtIiwiZW5zX2Vtb2ppIiwiZW5zX25vcm1hbGl6ZV9mcmFnbWVudCIsImZyYWciLCJkZWNvbXBvc2UiLCJuZiIsInNwbGl0IiwibGFiZWwiLCJ0b2tlbnNfZnJvbV9zdHIiLCJmaWx0ZXJfZmUwZiIsImVuc19ub3JtYWxpemUiLCJuYW1lIiwiZmxhdHRlbiIsImVuc19iZWF1dGlmeSIsImxhYmVscyIsInR5cGUiLCJvdXRwdXQiLCJlcnJvciIsImVuc19zcGxpdCIsInByZXNlcnZlX2Vtb2ppIiwiZWYiLCJpbnB1dCIsImluZm8iLCJ0b2tlbnMiLCJ0b2tlbl9jb3VudCIsIm5vcm0iLCJlbW9qaSIsImV2ZXJ5IiwiY2hhcnMiLCJ1bmlxdWUiLCJkZXRlcm1pbmVfZ3JvdXAiLCJjaGVja19ncm91cCIsImNoZWNrX3dob2xlIiwiZXJyIiwiZ3JvdXAiLCJtYWtlciIsInNoYXJlZCIsIndob2xlIiwiZ3JvdXBzIiwiZXJyb3JfZGlzYWxsb3dlZCIsImVycm9yX2dyb3VwX21lbWJlciIsIm1zZyIsIm1lc3NhZ2UiLCJxdW90ZWQiLCJnZyIsIndoZXJlIiwiZSIsImsiLCJjb25zdW1lX2Vtb2ppX3JldmVyc2VkIiwiZWF0ZW4iLCJUWV9WQUxJRCIsIlRZX01BUFBFRCIsIlRZX0lHTk9SRUQiLCJUWV9ESVNBTExPV0VEIiwiVFlfRU1PSkkiLCJUWV9ORkMiLCJUWV9TVE9QIiwiZW5zX3Rva2VuaXplIiwidG9rZW4iLCJpc192YWxpZF9vcl9tYXBwZWQiLCJyZXF1aXJlc19jaGVjayIsImNwczAiLCJzcGxpY2UiLCJ0b2tlbnMwIiwiY29sbGFwc2VfdmFsaWRfdG9rZW5zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@adraffy/ens-normalize/dist/index.mjs\n");

/***/ })

};
;