"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/eth-block-tracker";
exports.ids = ["vendor-chunks/eth-block-tracker"];
exports.modules = {

/***/ "(ssr)/./node_modules/eth-block-tracker/dist/BaseBlockTracker.js":
/*!*****************************************************************!*\
  !*** ./node_modules/eth-block-tracker/dist/BaseBlockTracker.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BaseBlockTracker = void 0;\nconst safe_event_emitter_1 = __importDefault(__webpack_require__(/*! @metamask/safe-event-emitter */ \"(ssr)/./node_modules/@metamask/safe-event-emitter/dist/cjs/index.js\"));\nconst sec = 1000;\nconst calculateSum = (accumulator, currentValue)=>accumulator + currentValue;\nconst blockTrackerEvents = [\n    \"sync\",\n    \"latest\"\n];\nclass BaseBlockTracker extends safe_event_emitter_1.default {\n    constructor(opts){\n        super();\n        // config\n        this._blockResetDuration = opts.blockResetDuration || 20 * sec;\n        this._usePastBlocks = opts.usePastBlocks || false;\n        // state\n        this._currentBlock = null;\n        this._isRunning = false;\n        // bind functions for internal use\n        this._onNewListener = this._onNewListener.bind(this);\n        this._onRemoveListener = this._onRemoveListener.bind(this);\n        this._resetCurrentBlock = this._resetCurrentBlock.bind(this);\n        // listen for handler changes\n        this._setupInternalEvents();\n    }\n    async destroy() {\n        this._cancelBlockResetTimeout();\n        await this._maybeEnd();\n        super.removeAllListeners();\n    }\n    isRunning() {\n        return this._isRunning;\n    }\n    getCurrentBlock() {\n        return this._currentBlock;\n    }\n    async getLatestBlock() {\n        // return if available\n        if (this._currentBlock) {\n            return this._currentBlock;\n        }\n        // wait for a new latest block\n        const latestBlock = await new Promise((resolve)=>this.once(\"latest\", resolve));\n        // return newly set current block\n        return latestBlock;\n    }\n    // dont allow module consumer to remove our internal event listeners\n    removeAllListeners(eventName) {\n        // perform default behavior, preserve fn arity\n        if (eventName) {\n            super.removeAllListeners(eventName);\n        } else {\n            super.removeAllListeners();\n        }\n        // re-add internal events\n        this._setupInternalEvents();\n        // trigger stop check just in case\n        this._onRemoveListener();\n        return this;\n    }\n    _setupInternalEvents() {\n        // first remove listeners for idempotence\n        this.removeListener(\"newListener\", this._onNewListener);\n        this.removeListener(\"removeListener\", this._onRemoveListener);\n        // then add them\n        this.on(\"newListener\", this._onNewListener);\n        this.on(\"removeListener\", this._onRemoveListener);\n    }\n    _onNewListener(eventName) {\n        // `newListener` is called *before* the listener is added\n        if (blockTrackerEvents.includes(eventName)) {\n            this._maybeStart();\n        }\n    }\n    _onRemoveListener() {\n        // `removeListener` is called *after* the listener is removed\n        if (this._getBlockTrackerEventCount() > 0) {\n            return;\n        }\n        this._maybeEnd();\n    }\n    async _maybeStart() {\n        if (this._isRunning) {\n            return;\n        }\n        this._isRunning = true;\n        // cancel setting latest block to stale\n        this._cancelBlockResetTimeout();\n        await this._start();\n        this.emit(\"_started\");\n    }\n    async _maybeEnd() {\n        if (!this._isRunning) {\n            return;\n        }\n        this._isRunning = false;\n        this._setupBlockResetTimeout();\n        await this._end();\n        this.emit(\"_ended\");\n    }\n    _getBlockTrackerEventCount() {\n        return blockTrackerEvents.map((eventName)=>this.listenerCount(eventName)).reduce(calculateSum);\n    }\n    _shouldUseNewBlock(newBlock) {\n        const currentBlock = this._currentBlock;\n        if (!currentBlock) {\n            return true;\n        }\n        const newBlockInt = hexToInt(newBlock);\n        const currentBlockInt = hexToInt(currentBlock);\n        return this._usePastBlocks && newBlockInt < currentBlockInt || newBlockInt > currentBlockInt;\n    }\n    _newPotentialLatest(newBlock) {\n        if (!this._shouldUseNewBlock(newBlock)) {\n            return;\n        }\n        this._setCurrentBlock(newBlock);\n    }\n    _setCurrentBlock(newBlock) {\n        const oldBlock = this._currentBlock;\n        this._currentBlock = newBlock;\n        this.emit(\"latest\", newBlock);\n        this.emit(\"sync\", {\n            oldBlock,\n            newBlock\n        });\n    }\n    _setupBlockResetTimeout() {\n        // clear any existing timeout\n        this._cancelBlockResetTimeout();\n        // clear latest block when stale\n        this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration);\n        // nodejs - dont hold process open\n        if (this._blockResetTimeout.unref) {\n            this._blockResetTimeout.unref();\n        }\n    }\n    _cancelBlockResetTimeout() {\n        if (this._blockResetTimeout) {\n            clearTimeout(this._blockResetTimeout);\n        }\n    }\n    _resetCurrentBlock() {\n        this._currentBlock = null;\n    }\n}\nexports.BaseBlockTracker = BaseBlockTracker;\n/**\n * Converts a number represented as a string in hexadecimal format into a native\n * number.\n *\n * @param hexInt - The hex string.\n * @returns The number.\n */ function hexToInt(hexInt) {\n    return Number.parseInt(hexInt, 16);\n} //# sourceMappingURL=BaseBlockTracker.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvZGlzdC9CYXNlQmxvY2tUcmFja2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx3QkFBd0IsR0FBRyxLQUFLO0FBQ2hDLE1BQU1HLHVCQUF1QlIsZ0JBQWdCUyxtQkFBT0EsQ0FBQyx5R0FBOEI7QUFDbkYsTUFBTUMsTUFBTTtBQUNaLE1BQU1DLGVBQWUsQ0FBQ0MsYUFBYUMsZUFBaUJELGNBQWNDO0FBQ2xFLE1BQU1DLHFCQUFxQjtJQUFDO0lBQVE7Q0FBUztBQUM3QyxNQUFNUCx5QkFBeUJDLHFCQUFxQk8sT0FBTztJQUN2REMsWUFBWUMsSUFBSSxDQUFFO1FBQ2QsS0FBSztRQUNMLFNBQVM7UUFDVCxJQUFJLENBQUNDLG1CQUFtQixHQUFHRCxLQUFLRSxrQkFBa0IsSUFBSSxLQUFLVDtRQUMzRCxJQUFJLENBQUNVLGNBQWMsR0FBR0gsS0FBS0ksYUFBYSxJQUFJO1FBQzVDLFFBQVE7UUFDUixJQUFJLENBQUNDLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNDLFVBQVUsR0FBRztRQUNsQixrQ0FBa0M7UUFDbEMsSUFBSSxDQUFDQyxjQUFjLEdBQUcsSUFBSSxDQUFDQSxjQUFjLENBQUNDLElBQUksQ0FBQyxJQUFJO1FBQ25ELElBQUksQ0FBQ0MsaUJBQWlCLEdBQUcsSUFBSSxDQUFDQSxpQkFBaUIsQ0FBQ0QsSUFBSSxDQUFDLElBQUk7UUFDekQsSUFBSSxDQUFDRSxrQkFBa0IsR0FBRyxJQUFJLENBQUNBLGtCQUFrQixDQUFDRixJQUFJLENBQUMsSUFBSTtRQUMzRCw2QkFBNkI7UUFDN0Is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QUFDRCxrQkFBa0IsQ0FBQ0MsV0FBVztZQUNwQztRQUNKO1FBQ0EsSUFBSSxDQUFDTSxnQkFBZ0IsQ0FBQ047SUFDMUI7SUFDQU0saUJBQWlCTixRQUFRLEVBQUU7UUFDdkIsTUFBTU8sV0FBVyxJQUFJLENBQUN2QyxhQUFhO1FBQ25DLElBQUksQ0FBQ0EsYUFBYSxHQUFHZ0M7UUFDckIsSUFBSSxDQUFDUCxJQUFJLENBQUMsVUFBVU87UUFDcEIsSUFBSSxDQUFDUCxJQUFJLENBQUMsUUFBUTtZQUFFYztZQUFVUDtRQUFTO0lBQzNDO0lBQ0FOLDBCQUEwQjtRQUN0Qiw2QkFBNkI7UUFDN0IsSUFBSSxDQUFDbEIsd0JBQXdCO1FBQzdCLGdDQUFnQztRQUNoQyxJQUFJLENBQUNnQyxrQkFBa0IsR0FBR0MsV0FBVyxJQUFJLENBQUNwQyxrQkFBa0IsRUFBRSxJQUFJLENBQUNULG1CQUFtQjtRQUN0RixrQ0FBa0M7UUFDbEMsSUFBSSxJQUFJLENBQUM0QyxrQkFBa0IsQ0FBQ0UsS0FBSyxFQUFFO1lBQy9CLElBQUksQ0FBQ0Ysa0JBQWtCLENBQUNFLEtBQUs7UUFDakM7SUFDSjtJQUNBbEMsMkJBQTJCO1FBQ3ZCLElBQUksSUFBSSxDQUFDZ0Msa0JBQWtCLEVBQUU7WUFDekJHLGFBQWEsSUFBSSxDQUFDSCxrQkFBa0I7UUFDeEM7SUFDSjtJQUNBbkMscUJBQXFCO1FBQ2pCLElBQUksQ0FBQ0wsYUFBYSxHQUFHO0lBQ3pCO0FBQ0o7QUFDQWpCLHdCQUF3QixHQUFHRTtBQUMzQjs7Ozs7O0NBTUMsR0FDRCxTQUFTa0QsU0FBU1MsTUFBTTtJQUNwQixPQUFPQyxPQUFPQyxRQUFRLENBQUNGLFFBQVE7QUFDbkMsRUFDQSw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aXRoLW5leHQtYXBwLy4vbm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL2Rpc3QvQmFzZUJsb2NrVHJhY2tlci5qcz9kMDI1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlQmxvY2tUcmFja2VyID0gdm9pZCAwO1xuY29uc3Qgc2FmZV9ldmVudF9lbWl0dGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBtZXRhbWFzay9zYWZlLWV2ZW50LWVtaXR0ZXJcIikpO1xuY29uc3Qgc2VjID0gMTAwMDtcbmNvbnN0IGNhbGN1bGF0ZVN1bSA9IChhY2N1bXVsYXRvciwgY3VycmVudFZhbHVlKSA9PiBhY2N1bXVsYXRvciArIGN1cnJlbnRWYWx1ZTtcbmNvbnN0IGJsb2NrVHJhY2tlckV2ZW50cyA9IFsnc3luYycsICdsYXRlc3QnXTtcbmNsYXNzIEJhc2VCbG9ja1RyYWNrZXIgZXh0ZW5kcyBzYWZlX2V2ZW50X2VtaXR0ZXJfMS5kZWZhdWx0IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIGNvbmZpZ1xuICAgICAgICB0aGlzLl9ibG9ja1Jlc2V0RHVyYXRpb24gPSBvcHRzLmJsb2NrUmVzZXREdXJhdGlvbiB8fCAyMCAqIHNlYztcbiAgICAgICAgdGhpcy5fdXNlUGFzdEJsb2NrcyA9IG9wdHMudXNlUGFzdEJsb2NrcyB8fCBmYWxzZTtcbiAgICAgICAgLy8gc3RhdGVcbiAgICAgICAgdGhpcy5fY3VycmVudEJsb2NrID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIGJpbmQgZnVuY3Rpb25zIGZvciBpbnRlcm5hbCB1c2VcbiAgICAgICAgdGhpcy5fb25OZXdMaXN0ZW5lciA9IHRoaXMuX29uTmV3TGlzdGVuZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fb25SZW1vdmVMaXN0ZW5lciA9IHRoaXMuX29uUmVtb3ZlTGlzdGVuZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcmVzZXRDdXJyZW50QmxvY2sgPSB0aGlzLl9yZXNldEN1cnJlbnRCbG9jay5iaW5kKHRoaXMpO1xuICAgICAgICAvLyBsaXN0ZW4gZm9yIGhhbmRsZXIgY2hhbmdlc1xuICAgICAgICB0aGlzLl9zZXR1cEludGVybmFsRXZlbnRzKCk7XG4gICAgfVxuICAgIGFzeW5jIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2NhbmNlbEJsb2NrUmVzZXRUaW1lb3V0KCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX21heWJlRW5kKCk7XG4gICAgICAgIHN1cGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIH1cbiAgICBpc1J1bm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1J1bm5pbmc7XG4gICAgfVxuICAgIGdldEN1cnJlbnRCbG9jaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRCbG9jaztcbiAgICB9XG4gICAgYXN5bmMgZ2V0TGF0ZXN0QmxvY2soKSB7XG4gICAgICAgIC8vIHJldHVybiBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRCbG9jaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRCbG9jaztcbiAgICAgICAgfVxuICAgICAgICAvLyB3YWl0IGZvciBhIG5ldyBsYXRlc3QgYmxvY2tcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2sgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gdGhpcy5vbmNlKCdsYXRlc3QnLCByZXNvbHZlKSk7XG4gICAgICAgIC8vIHJldHVybiBuZXdseSBzZXQgY3VycmVudCBibG9ja1xuICAgICAgICByZXR1cm4gbGF0ZXN0QmxvY2s7XG4gICAgfVxuICAgIC8vIGRvbnQgYWxsb3cgbW9kdWxlIGNvbnN1bWVyIHRvIHJlbW92ZSBvdXIgaW50ZXJuYWwgZXZlbnQgbGlzdGVuZXJzXG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgICAgICAvLyBwZXJmb3JtIGRlZmF1bHQgYmVoYXZpb3IsIHByZXNlcnZlIGZuIGFyaXR5XG4gICAgICAgIGlmIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgIHN1cGVyLnJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmUtYWRkIGludGVybmFsIGV2ZW50c1xuICAgICAgICB0aGlzLl9zZXR1cEludGVybmFsRXZlbnRzKCk7XG4gICAgICAgIC8vIHRyaWdnZXIgc3RvcCBjaGVjayBqdXN0IGluIGNhc2VcbiAgICAgICAgdGhpcy5fb25SZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgX3NldHVwSW50ZXJuYWxFdmVudHMoKSB7XG4gICAgICAgIC8vIGZpcnN0IHJlbW92ZSBsaXN0ZW5lcnMgZm9yIGlkZW1wb3RlbmNlXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ25ld0xpc3RlbmVyJywgdGhpcy5fb25OZXdMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3JlbW92ZUxpc3RlbmVyJywgdGhpcy5fb25SZW1vdmVMaXN0ZW5lcik7XG4gICAgICAgIC8vIHRoZW4gYWRkIHRoZW1cbiAgICAgICAgdGhpcy5vbignbmV3TGlzdGVuZXInLCB0aGlzLl9vbk5ld0xpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5vbigncmVtb3ZlTGlzdGVuZXInLCB0aGlzLl9vblJlbW92ZUxpc3RlbmVyKTtcbiAgICB9XG4gICAgX29uTmV3TGlzdGVuZXIoZXZlbnROYW1lKSB7XG4gICAgICAgIC8vIGBuZXdMaXN0ZW5lcmAgaXMgY2FsbGVkICpiZWZvcmUqIHRoZSBsaXN0ZW5lciBpcyBhZGRlZFxuICAgICAgICBpZiAoYmxvY2tUcmFja2VyRXZlbnRzLmluY2x1ZGVzKGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX21heWJlU3RhcnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfb25SZW1vdmVMaXN0ZW5lcigpIHtcbiAgICAgICAgLy8gYHJlbW92ZUxpc3RlbmVyYCBpcyBjYWxsZWQgKmFmdGVyKiB0aGUgbGlzdGVuZXIgaXMgcmVtb3ZlZFxuICAgICAgICBpZiAodGhpcy5fZ2V0QmxvY2tUcmFja2VyRXZlbnRDb3VudCgpID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21heWJlRW5kKCk7XG4gICAgfVxuICAgIGFzeW5jIF9tYXliZVN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgLy8gY2FuY2VsIHNldHRpbmcgbGF0ZXN0IGJsb2NrIHRvIHN0YWxlXG4gICAgICAgIHRoaXMuX2NhbmNlbEJsb2NrUmVzZXRUaW1lb3V0KCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX3N0YXJ0KCk7XG4gICAgICAgIHRoaXMuZW1pdCgnX3N0YXJ0ZWQnKTtcbiAgICB9XG4gICAgYXN5bmMgX21heWJlRW5kKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzUnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zZXR1cEJsb2NrUmVzZXRUaW1lb3V0KCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZCgpO1xuICAgICAgICB0aGlzLmVtaXQoJ19lbmRlZCcpO1xuICAgIH1cbiAgICBfZ2V0QmxvY2tUcmFja2VyRXZlbnRDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrVHJhY2tlckV2ZW50c1xuICAgICAgICAgICAgLm1hcCgoZXZlbnROYW1lKSA9PiB0aGlzLmxpc3RlbmVyQ291bnQoZXZlbnROYW1lKSlcbiAgICAgICAgICAgIC5yZWR1Y2UoY2FsY3VsYXRlU3VtKTtcbiAgICB9XG4gICAgX3Nob3VsZFVzZU5ld0Jsb2NrKG5ld0Jsb2NrKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRCbG9jayA9IHRoaXMuX2N1cnJlbnRCbG9jaztcbiAgICAgICAgaWYgKCFjdXJyZW50QmxvY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0Jsb2NrSW50ID0gaGV4VG9JbnQobmV3QmxvY2spO1xuICAgICAgICBjb25zdCBjdXJyZW50QmxvY2tJbnQgPSBoZXhUb0ludChjdXJyZW50QmxvY2spO1xuICAgICAgICByZXR1cm4gKCh0aGlzLl91c2VQYXN0QmxvY2tzICYmIG5ld0Jsb2NrSW50IDwgY3VycmVudEJsb2NrSW50KSB8fFxuICAgICAgICAgICAgbmV3QmxvY2tJbnQgPiBjdXJyZW50QmxvY2tJbnQpO1xuICAgIH1cbiAgICBfbmV3UG90ZW50aWFsTGF0ZXN0KG5ld0Jsb2NrKSB7XG4gICAgICAgIGlmICghdGhpcy5fc2hvdWxkVXNlTmV3QmxvY2sobmV3QmxvY2spKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0Q3VycmVudEJsb2NrKG5ld0Jsb2NrKTtcbiAgICB9XG4gICAgX3NldEN1cnJlbnRCbG9jayhuZXdCbG9jaykge1xuICAgICAgICBjb25zdCBvbGRCbG9jayA9IHRoaXMuX2N1cnJlbnRCbG9jaztcbiAgICAgICAgdGhpcy5fY3VycmVudEJsb2NrID0gbmV3QmxvY2s7XG4gICAgICAgIHRoaXMuZW1pdCgnbGF0ZXN0JywgbmV3QmxvY2spO1xuICAgICAgICB0aGlzLmVtaXQoJ3N5bmMnLCB7IG9sZEJsb2NrLCBuZXdCbG9jayB9KTtcbiAgICB9XG4gICAgX3NldHVwQmxvY2tSZXNldFRpbWVvdXQoKSB7XG4gICAgICAgIC8vIGNsZWFyIGFueSBleGlzdGluZyB0aW1lb3V0XG4gICAgICAgIHRoaXMuX2NhbmNlbEJsb2NrUmVzZXRUaW1lb3V0KCk7XG4gICAgICAgIC8vIGNsZWFyIGxhdGVzdCBibG9jayB3aGVuIHN0YWxlXG4gICAgICAgIHRoaXMuX2Jsb2NrUmVzZXRUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLl9yZXNldEN1cnJlbnRCbG9jaywgdGhpcy5fYmxvY2tSZXNldER1cmF0aW9uKTtcbiAgICAgICAgLy8gbm9kZWpzIC0gZG9udCBob2xkIHByb2Nlc3Mgb3BlblxuICAgICAgICBpZiAodGhpcy5fYmxvY2tSZXNldFRpbWVvdXQudW5yZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX2Jsb2NrUmVzZXRUaW1lb3V0LnVucmVmKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NhbmNlbEJsb2NrUmVzZXRUaW1lb3V0KCkge1xuICAgICAgICBpZiAodGhpcy5fYmxvY2tSZXNldFRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9ibG9ja1Jlc2V0VGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3Jlc2V0Q3VycmVudEJsb2NrKCkge1xuICAgICAgICB0aGlzLl9jdXJyZW50QmxvY2sgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUJsb2NrVHJhY2tlciA9IEJhc2VCbG9ja1RyYWNrZXI7XG4vKipcbiAqIENvbnZlcnRzIGEgbnVtYmVyIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nIGluIGhleGFkZWNpbWFsIGZvcm1hdCBpbnRvIGEgbmF0aXZlXG4gKiBudW1iZXIuXG4gKlxuICogQHBhcmFtIGhleEludCAtIFRoZSBoZXggc3RyaW5nLlxuICogQHJldHVybnMgVGhlIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gaGV4VG9JbnQoaGV4SW50KSB7XG4gICAgcmV0dXJuIE51bWJlci5wYXJzZUludChoZXhJbnQsIDE2KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhc2VCbG9ja1RyYWNrZXIuanMubWFwIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkJhc2VCbG9ja1RyYWNrZXIiLCJzYWZlX2V2ZW50X2VtaXR0ZXJfMSIsInJlcXVpcmUiLCJzZWMiLCJjYWxjdWxhdGVTdW0iLCJhY2N1bXVsYXRvciIsImN1cnJlbnRWYWx1ZSIsImJsb2NrVHJhY2tlckV2ZW50cyIsImRlZmF1bHQiLCJjb25zdHJ1Y3RvciIsIm9wdHMiLCJfYmxvY2tSZXNldER1cmF0aW9uIiwiYmxvY2tSZXNldER1cmF0aW9uIiwiX3VzZVBhc3RCbG9ja3MiLCJ1c2VQYXN0QmxvY2tzIiwiX2N1cnJlbnRCbG9jayIsIl9pc1J1bm5pbmciLCJfb25OZXdMaXN0ZW5lciIsImJpbmQiLCJfb25SZW1vdmVMaXN0ZW5lciIsIl9yZXNldEN1cnJlbnRCbG9jayIsIl9zZXR1cEludGVybmFsRXZlbnRzIiwiZGVzdHJveSIsIl9jYW5jZWxCbG9ja1Jlc2V0VGltZW91dCIsIl9tYXliZUVuZCIsInJlbW92ZUFsbExpc3RlbmVycyIsImlzUnVubmluZyIsImdldEN1cnJlbnRCbG9jayIsImdldExhdGVzdEJsb2NrIiwibGF0ZXN0QmxvY2siLCJQcm9taXNlIiwicmVzb2x2ZSIsIm9uY2UiLCJldmVudE5hbWUiLCJyZW1vdmVMaXN0ZW5lciIsIm9uIiwiaW5jbHVkZXMiLCJfbWF5YmVTdGFydCIsIl9nZXRCbG9ja1RyYWNrZXJFdmVudENvdW50IiwiX3N0YXJ0IiwiZW1pdCIsIl9zZXR1cEJsb2NrUmVzZXRUaW1lb3V0IiwiX2VuZCIsIm1hcCIsImxpc3RlbmVyQ291bnQiLCJyZWR1Y2UiLCJfc2hvdWxkVXNlTmV3QmxvY2siLCJuZXdCbG9jayIsImN1cnJlbnRCbG9jayIsIm5ld0Jsb2NrSW50IiwiaGV4VG9JbnQiLCJjdXJyZW50QmxvY2tJbnQiLCJfbmV3UG90ZW50aWFsTGF0ZXN0IiwiX3NldEN1cnJlbnRCbG9jayIsIm9sZEJsb2NrIiwiX2Jsb2NrUmVzZXRUaW1lb3V0Iiwic2V0VGltZW91dCIsInVucmVmIiwiY2xlYXJUaW1lb3V0IiwiaGV4SW50IiwiTnVtYmVyIiwicGFyc2VJbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/dist/BaseBlockTracker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/dist/PollingBlockTracker.js":
/*!********************************************************************!*\
  !*** ./node_modules/eth-block-tracker/dist/PollingBlockTracker.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PollingBlockTracker = void 0;\nconst json_rpc_random_id_1 = __importDefault(__webpack_require__(/*! json-rpc-random-id */ \"(ssr)/./node_modules/json-rpc-random-id/index.js\"));\nconst pify_1 = __importDefault(__webpack_require__(/*! pify */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/pify/index.js\"));\nconst BaseBlockTracker_1 = __webpack_require__(/*! ./BaseBlockTracker */ \"(ssr)/./node_modules/eth-block-tracker/dist/BaseBlockTracker.js\");\nconst logging_utils_1 = __webpack_require__(/*! ./logging-utils */ \"(ssr)/./node_modules/eth-block-tracker/dist/logging-utils.js\");\nconst log = (0, logging_utils_1.createModuleLogger)(logging_utils_1.projectLogger, \"polling-block-tracker\");\nconst createRandomId = (0, json_rpc_random_id_1.default)();\nconst sec = 1000;\nclass PollingBlockTracker extends BaseBlockTracker_1.BaseBlockTracker {\n    constructor(opts = {}){\n        var _a;\n        // parse + validate args\n        if (!opts.provider) {\n            throw new Error(\"PollingBlockTracker - no provider specified.\");\n        }\n        super(Object.assign(Object.assign({}, opts), {\n            blockResetDuration: (_a = opts.blockResetDuration) !== null && _a !== void 0 ? _a : opts.pollingInterval\n        }));\n        // config\n        this._provider = opts.provider;\n        this._pollingInterval = opts.pollingInterval || 20 * sec;\n        this._retryTimeout = opts.retryTimeout || this._pollingInterval / 10;\n        this._keepEventLoopActive = opts.keepEventLoopActive === undefined ? true : opts.keepEventLoopActive;\n        this._setSkipCacheFlag = opts.setSkipCacheFlag || false;\n    }\n    // trigger block polling\n    async checkForLatestBlock() {\n        await this._updateLatestBlock();\n        return await this.getLatestBlock();\n    }\n    async _start() {\n        this._synchronize();\n    }\n    async _end() {\n    // No-op\n    }\n    async _synchronize() {\n        var _a;\n        while(this._isRunning){\n            try {\n                await this._updateLatestBlock();\n                const promise = timeout(this._pollingInterval, !this._keepEventLoopActive);\n                this.emit(\"_waitingForNextIteration\");\n                await promise;\n            } catch (err) {\n                const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:\\n${(_a = err.stack) !== null && _a !== void 0 ? _a : err}`);\n                try {\n                    this.emit(\"error\", newErr);\n                } catch (emitErr) {\n                    console.error(newErr);\n                }\n                const promise = timeout(this._retryTimeout, !this._keepEventLoopActive);\n                this.emit(\"_waitingForNextIteration\");\n                await promise;\n            }\n        }\n    }\n    async _updateLatestBlock() {\n        // fetch + set latest block\n        const latestBlock = await this._fetchLatestBlock();\n        this._newPotentialLatest(latestBlock);\n    }\n    async _fetchLatestBlock() {\n        const req = {\n            jsonrpc: \"2.0\",\n            id: createRandomId(),\n            method: \"eth_blockNumber\",\n            params: []\n        };\n        if (this._setSkipCacheFlag) {\n            req.skipCache = true;\n        }\n        log(\"Making request\", req);\n        const res = await (0, pify_1.default)((cb)=>this._provider.sendAsync(req, cb))();\n        log(\"Got response\", res);\n        if (res.error) {\n            throw new Error(`PollingBlockTracker - encountered error fetching block:\\n${res.error.message}`);\n        }\n        return res.result;\n    }\n}\nexports.PollingBlockTracker = PollingBlockTracker;\n/**\n * Waits for the specified amount of time.\n *\n * @param duration - The amount of time in milliseconds.\n * @param unref - Assuming this function is run in a Node context, governs\n * whether Node should wait before the `setTimeout` has completed before ending\n * the process (true for no, false for yes). Defaults to false.\n * @returns A promise that can be used to wait.\n */ function timeout(duration, unref) {\n    return new Promise((resolve)=>{\n        const timeoutRef = setTimeout(resolve, duration);\n        // don't keep process open\n        if (timeoutRef.unref && unref) {\n            timeoutRef.unref();\n        }\n    });\n} //# sourceMappingURL=PollingBlockTracker.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvZGlzdC9Qb2xsaW5nQmxvY2tUcmFja2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwyQkFBMkIsR0FBRyxLQUFLO0FBQ25DLE1BQU1HLHVCQUF1QlIsZ0JBQWdCUyxtQkFBT0EsQ0FBQyw0RUFBb0I7QUFDekUsTUFBTUMsU0FBU1YsZ0JBQWdCUyxtQkFBT0EsQ0FBQywrRUFBTTtBQUM3QyxNQUFNRSxxQkFBcUJGLG1CQUFPQSxDQUFDLDJGQUFvQjtBQUN2RCxNQUFNRyxrQkFBa0JILG1CQUFPQSxDQUFDLHFGQUFpQjtBQUNqRCxNQUFNSSxNQUFNLENBQUMsR0FBR0QsZ0JBQWdCRSxrQkFBa0IsRUFBRUYsZ0JBQWdCRyxhQUFhLEVBQUU7QUFDbkYsTUFBTUMsaUJBQWlCLENBQUMsR0FBR1IscUJBQXFCUyxPQUFPO0FBQ3ZELE1BQU1DLE1BQU07QUFDWixNQUFNWCw0QkFBNEJJLG1CQUFtQlEsZ0JBQWdCO0lBQ2pFQyxZQUFZQyxPQUFPLENBQUMsQ0FBQyxDQUFFO1FBQ25CLElBQUlDO1FBQ0osd0JBQXdCO1FBQ3hCLElBQUksQ0FBQ0QsS0FBS0UsUUFBUSxFQUFFO1lBQ2hCLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUNBLEtBQUssQ0FBQ3JCLE9BQU9zQixNQUFNLENBQUN0QixPQUFPc0IsTUFBTSxDQUFDLENBQUMsR0FBR0osT0FBTztZQUFFSyxvQkFBb0IsQ0FBQ0osS0FBS0QsS0FBS0ssa0JBQWtCLE1BQU0sUUFBUUosT0FBTyxLQUFLLElBQUlBLEtBQUtELEtBQUtNLGVBQWU7UUFBQztR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QSwrQ0FBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aXRoLW5leHQtYXBwLy4vbm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL2Rpc3QvUG9sbGluZ0Jsb2NrVHJhY2tlci5qcz8zMWQyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb2xsaW5nQmxvY2tUcmFja2VyID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfcmFuZG9tX2lkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImpzb24tcnBjLXJhbmRvbS1pZFwiKSk7XG5jb25zdCBwaWZ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInBpZnlcIikpO1xuY29uc3QgQmFzZUJsb2NrVHJhY2tlcl8xID0gcmVxdWlyZShcIi4vQmFzZUJsb2NrVHJhY2tlclwiKTtcbmNvbnN0IGxvZ2dpbmdfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmctdXRpbHNcIik7XG5jb25zdCBsb2cgPSAoMCwgbG9nZ2luZ191dGlsc18xLmNyZWF0ZU1vZHVsZUxvZ2dlcikobG9nZ2luZ191dGlsc18xLnByb2plY3RMb2dnZXIsICdwb2xsaW5nLWJsb2NrLXRyYWNrZXInKTtcbmNvbnN0IGNyZWF0ZVJhbmRvbUlkID0gKDAsIGpzb25fcnBjX3JhbmRvbV9pZF8xLmRlZmF1bHQpKCk7XG5jb25zdCBzZWMgPSAxMDAwO1xuY2xhc3MgUG9sbGluZ0Jsb2NrVHJhY2tlciBleHRlbmRzIEJhc2VCbG9ja1RyYWNrZXJfMS5CYXNlQmxvY2tUcmFja2VyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBwYXJzZSArIHZhbGlkYXRlIGFyZ3NcbiAgICAgICAgaWYgKCFvcHRzLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvbGxpbmdCbG9ja1RyYWNrZXIgLSBubyBwcm92aWRlciBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRzKSwgeyBibG9ja1Jlc2V0RHVyYXRpb246IChfYSA9IG9wdHMuYmxvY2tSZXNldER1cmF0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBvcHRzLnBvbGxpbmdJbnRlcnZhbCB9KSk7XG4gICAgICAgIC8vIGNvbmZpZ1xuICAgICAgICB0aGlzLl9wcm92aWRlciA9IG9wdHMucHJvdmlkZXI7XG4gICAgICAgIHRoaXMuX3BvbGxpbmdJbnRlcnZhbCA9IG9wdHMucG9sbGluZ0ludGVydmFsIHx8IDIwICogc2VjO1xuICAgICAgICB0aGlzLl9yZXRyeVRpbWVvdXQgPSBvcHRzLnJldHJ5VGltZW91dCB8fCB0aGlzLl9wb2xsaW5nSW50ZXJ2YWwgLyAxMDtcbiAgICAgICAgdGhpcy5fa2VlcEV2ZW50TG9vcEFjdGl2ZSA9XG4gICAgICAgICAgICBvcHRzLmtlZXBFdmVudExvb3BBY3RpdmUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRzLmtlZXBFdmVudExvb3BBY3RpdmU7XG4gICAgICAgIHRoaXMuX3NldFNraXBDYWNoZUZsYWcgPSBvcHRzLnNldFNraXBDYWNoZUZsYWcgfHwgZmFsc2U7XG4gICAgfVxuICAgIC8vIHRyaWdnZXIgYmxvY2sgcG9sbGluZ1xuICAgIGFzeW5jIGNoZWNrRm9yTGF0ZXN0QmxvY2soKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZUxhdGVzdEJsb2NrKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldExhdGVzdEJsb2NrKCk7XG4gICAgfVxuICAgIGFzeW5jIF9zdGFydCgpIHtcbiAgICAgICAgdGhpcy5fc3luY2hyb25pemUoKTtcbiAgICB9XG4gICAgYXN5bmMgX2VuZCgpIHtcbiAgICAgICAgLy8gTm8tb3BcbiAgICB9XG4gICAgYXN5bmMgX3N5bmNocm9uaXplKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHdoaWxlICh0aGlzLl9pc1J1bm5pbmcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlTGF0ZXN0QmxvY2soKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gdGltZW91dCh0aGlzLl9wb2xsaW5nSW50ZXJ2YWwsICF0aGlzLl9rZWVwRXZlbnRMb29wQWN0aXZlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ193YWl0aW5nRm9yTmV4dEl0ZXJhdGlvbicpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RXJyID0gbmV3IEVycm9yKGBQb2xsaW5nQmxvY2tUcmFja2VyIC0gZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgYXR0ZW1wdGluZyB0byB1cGRhdGUgbGF0ZXN0IGJsb2NrOlxcbiR7KF9hID0gZXJyLnN0YWNrKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBlcnJ9YCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ld0Vycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlbWl0RXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobmV3RXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRpbWVvdXQodGhpcy5fcmV0cnlUaW1lb3V0LCAhdGhpcy5fa2VlcEV2ZW50TG9vcEFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdfd2FpdGluZ0Zvck5leHRJdGVyYXRpb24nKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF91cGRhdGVMYXRlc3RCbG9jaygpIHtcbiAgICAgICAgLy8gZmV0Y2ggKyBzZXQgbGF0ZXN0IGJsb2NrXG4gICAgICAgIGNvbnN0IGxhdGVzdEJsb2NrID0gYXdhaXQgdGhpcy5fZmV0Y2hMYXRlc3RCbG9jaygpO1xuICAgICAgICB0aGlzLl9uZXdQb3RlbnRpYWxMYXRlc3QobGF0ZXN0QmxvY2spO1xuICAgIH1cbiAgICBhc3luYyBfZmV0Y2hMYXRlc3RCbG9jaygpIHtcbiAgICAgICAgY29uc3QgcmVxID0ge1xuICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICBpZDogY3JlYXRlUmFuZG9tSWQoKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9ibG9ja051bWJlcicsXG4gICAgICAgICAgICBwYXJhbXM6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5fc2V0U2tpcENhY2hlRmxhZykge1xuICAgICAgICAgICAgcmVxLnNraXBDYWNoZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbG9nKCdNYWtpbmcgcmVxdWVzdCcsIHJlcSk7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0ICgwLCBwaWZ5XzEuZGVmYXVsdCkoKGNiKSA9PiB0aGlzLl9wcm92aWRlci5zZW5kQXN5bmMocmVxLCBjYikpKCk7XG4gICAgICAgIGxvZygnR290IHJlc3BvbnNlJywgcmVzKTtcbiAgICAgICAgaWYgKHJlcy5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb2xsaW5nQmxvY2tUcmFja2VyIC0gZW5jb3VudGVyZWQgZXJyb3IgZmV0Y2hpbmcgYmxvY2s6XFxuJHtyZXMuZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLlBvbGxpbmdCbG9ja1RyYWNrZXIgPSBQb2xsaW5nQmxvY2tUcmFja2VyO1xuLyoqXG4gKiBXYWl0cyBmb3IgdGhlIHNwZWNpZmllZCBhbW91bnQgb2YgdGltZS5cbiAqXG4gKiBAcGFyYW0gZHVyYXRpb24gLSBUaGUgYW1vdW50IG9mIHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuICogQHBhcmFtIHVucmVmIC0gQXNzdW1pbmcgdGhpcyBmdW5jdGlvbiBpcyBydW4gaW4gYSBOb2RlIGNvbnRleHQsIGdvdmVybnNcbiAqIHdoZXRoZXIgTm9kZSBzaG91bGQgd2FpdCBiZWZvcmUgdGhlIGBzZXRUaW1lb3V0YCBoYXMgY29tcGxldGVkIGJlZm9yZSBlbmRpbmdcbiAqIHRoZSBwcm9jZXNzICh0cnVlIGZvciBubywgZmFsc2UgZm9yIHllcykuIERlZmF1bHRzIHRvIGZhbHNlLlxuICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgY2FuIGJlIHVzZWQgdG8gd2FpdC5cbiAqL1xuZnVuY3Rpb24gdGltZW91dChkdXJhdGlvbiwgdW5yZWYpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3QgdGltZW91dFJlZiA9IHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pO1xuICAgICAgICAvLyBkb24ndCBrZWVwIHByb2Nlc3Mgb3BlblxuICAgICAgICBpZiAodGltZW91dFJlZi51bnJlZiAmJiB1bnJlZikge1xuICAgICAgICAgICAgdGltZW91dFJlZi51bnJlZigpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb2xsaW5nQmxvY2tUcmFja2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJQb2xsaW5nQmxvY2tUcmFja2VyIiwianNvbl9ycGNfcmFuZG9tX2lkXzEiLCJyZXF1aXJlIiwicGlmeV8xIiwiQmFzZUJsb2NrVHJhY2tlcl8xIiwibG9nZ2luZ191dGlsc18xIiwibG9nIiwiY3JlYXRlTW9kdWxlTG9nZ2VyIiwicHJvamVjdExvZ2dlciIsImNyZWF0ZVJhbmRvbUlkIiwiZGVmYXVsdCIsInNlYyIsIkJhc2VCbG9ja1RyYWNrZXIiLCJjb25zdHJ1Y3RvciIsIm9wdHMiLCJfYSIsInByb3ZpZGVyIiwiRXJyb3IiLCJhc3NpZ24iLCJibG9ja1Jlc2V0RHVyYXRpb24iLCJwb2xsaW5nSW50ZXJ2YWwiLCJfcHJvdmlkZXIiLCJfcG9sbGluZ0ludGVydmFsIiwiX3JldHJ5VGltZW91dCIsInJldHJ5VGltZW91dCIsIl9rZWVwRXZlbnRMb29wQWN0aXZlIiwia2VlcEV2ZW50TG9vcEFjdGl2ZSIsInVuZGVmaW5lZCIsIl9zZXRTa2lwQ2FjaGVGbGFnIiwic2V0U2tpcENhY2hlRmxhZyIsImNoZWNrRm9yTGF0ZXN0QmxvY2siLCJfdXBkYXRlTGF0ZXN0QmxvY2siLCJnZXRMYXRlc3RCbG9jayIsIl9zdGFydCIsIl9zeW5jaHJvbml6ZSIsIl9lbmQiLCJfaXNSdW5uaW5nIiwicHJvbWlzZSIsInRpbWVvdXQiLCJlbWl0IiwiZXJyIiwibmV3RXJyIiwic3RhY2siLCJlbWl0RXJyIiwiY29uc29sZSIsImVycm9yIiwibGF0ZXN0QmxvY2siLCJfZmV0Y2hMYXRlc3RCbG9jayIsIl9uZXdQb3RlbnRpYWxMYXRlc3QiLCJyZXEiLCJqc29ucnBjIiwiaWQiLCJtZXRob2QiLCJwYXJhbXMiLCJza2lwQ2FjaGUiLCJyZXMiLCJjYiIsInNlbmRBc3luYyIsIm1lc3NhZ2UiLCJyZXN1bHQiLCJkdXJhdGlvbiIsInVucmVmIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aW1lb3V0UmVmIiwic2V0VGltZW91dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/dist/PollingBlockTracker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/dist/SubscribeBlockTracker.js":
/*!**********************************************************************!*\
  !*** ./node_modules/eth-block-tracker/dist/SubscribeBlockTracker.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SubscribeBlockTracker = void 0;\nconst json_rpc_random_id_1 = __importDefault(__webpack_require__(/*! json-rpc-random-id */ \"(ssr)/./node_modules/json-rpc-random-id/index.js\"));\nconst BaseBlockTracker_1 = __webpack_require__(/*! ./BaseBlockTracker */ \"(ssr)/./node_modules/eth-block-tracker/dist/BaseBlockTracker.js\");\nconst createRandomId = (0, json_rpc_random_id_1.default)();\nclass SubscribeBlockTracker extends BaseBlockTracker_1.BaseBlockTracker {\n    constructor(opts = {}){\n        // parse + validate args\n        if (!opts.provider) {\n            throw new Error(\"SubscribeBlockTracker - no provider specified.\");\n        }\n        // BaseBlockTracker constructor\n        super(opts);\n        // config\n        this._provider = opts.provider;\n        this._subscriptionId = null;\n    }\n    async checkForLatestBlock() {\n        return await this.getLatestBlock();\n    }\n    async _start() {\n        if (this._subscriptionId === undefined || this._subscriptionId === null) {\n            try {\n                const blockNumber = await this._call(\"eth_blockNumber\");\n                this._subscriptionId = await this._call(\"eth_subscribe\", \"newHeads\");\n                this._provider.on(\"data\", this._handleSubData.bind(this));\n                this._newPotentialLatest(blockNumber);\n            } catch (e) {\n                this.emit(\"error\", e);\n            }\n        }\n    }\n    async _end() {\n        if (this._subscriptionId !== null && this._subscriptionId !== undefined) {\n            try {\n                await this._call(\"eth_unsubscribe\", this._subscriptionId);\n                this._subscriptionId = null;\n            } catch (e) {\n                this.emit(\"error\", e);\n            }\n        }\n    }\n    _call(method, ...params) {\n        return new Promise((resolve, reject)=>{\n            this._provider.sendAsync({\n                id: createRandomId(),\n                method,\n                params,\n                jsonrpc: \"2.0\"\n            }, (err, res)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(res.result);\n                }\n            });\n        });\n    }\n    _handleSubData(_, response) {\n        var _a;\n        if (response.method === \"eth_subscription\" && ((_a = response.params) === null || _a === void 0 ? void 0 : _a.subscription) === this._subscriptionId) {\n            this._newPotentialLatest(response.params.result.number);\n        }\n    }\n}\nexports.SubscribeBlockTracker = SubscribeBlockTracker; //# sourceMappingURL=SubscribeBlockTracker.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvZGlzdC9TdWJzY3JpYmVCbG9ja1RyYWNrZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQUssU0FBVUMsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQUUsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHLEtBQUs7QUFDckMsTUFBTUcsdUJBQXVCUixnQkFBZ0JTLG1CQUFPQSxDQUFDLDRFQUFvQjtBQUN6RSxNQUFNQyxxQkFBcUJELG1CQUFPQSxDQUFDLDJGQUFvQjtBQUN2RCxNQUFNRSxpQkFBaUIsQ0FBQyxHQUFHSCxxQkFBcUJJLE9BQU87QUFDdkQsTUFBTUwsOEJBQThCRyxtQkFBbUJHLGdCQUFnQjtJQUNuRUMsWUFBWUMsT0FBTyxDQUFDLENBQUMsQ0FBRTtRQUNuQix3QkFBd0I7UUFDeEIsSUFBSSxDQUFDQSxLQUFLQyxRQUFRLEVBQUU7WUFDaEIsTUFBTSxJQUFJQyxNQUFNO1FBQ3BCO1FBQ0EsK0JBQStCO1FBQy9CLEtBQUssQ0FBQ0Y7UUFDTixTQUFTO1FBQ1QsSUFBSSxDQUFDRyxTQUFTLEdBQUdILEtBQUtDLFFBQVE7UUFDOUIsSUFBSSxDQUFDRyxlQUFlLEdBQUc7SUFDM0I7SUFDQSxNQUFNQyxzQkFBc0I7UUFDeEIsT0FBTyxNQUFNLElBQUksQ0FBQ0MsY0FBYztJQUNwQztJQUNBLE1BQU1DLFNBQVM7UUFDWCxJQUFJLElBQUksQ0FBQ0gsZUFBZSxLQUFLSSxhQUFhLElBQUksQ0FBQ0osZUFBZSxLQUFLLE1BQU07WUFDckUsSUFBSTtnQkFDQSxNQUFNSyxjQUFlLE1BQU0sSUFBSSxDQUFDQyxLQUFLLENBQUM7Z0JBQ3RDLElBQUksQ0FBQ04sZUFBZSxHQUFJLE1BQU0sSUFBSSxDQUFDTSxLQUFLLENBQUMsaUJBQWlCO2dCQUMxRCxJQUFJLENBQUNQLFNBQVMsQ0FBQ1EsRUFBRSxDQUFDLFFBQVEsSUFBSSxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQyxJQUFJO2dCQUN2RCxJQUFJLENBQUNDLG1CQUFtQixDQUFDTDtZQUM3QixFQUNBLE9BQU9NLEdBQUc7Z0JBQ04sSUFBSSxDQUFDQyxJQUFJLENBQUMsU0FBU0Q7WUFDdkI7UUFDSjtJQUNKO0lBQ0EsTUFBTUUsT0FBTztRQUNULElBQUksSUFBSSxDQUFDYixlQUFlLEtBQUssUUFBUSxJQUFJLENBQUNBLGVBQWUsS0FBS0ksV0FBVztZQUNyRSxJQUFJO2dCQUNBLE1BQU0sSUFBSSxDQUFDRSxLQUFLLENBQUMsbUJBQW1CLElBQUksQ0FBQ04sZUFBZTtnQkFDeEQsSUFBSSxDQUFDQSxlQUFlLEdBQUc7WUFDM0IsRUFDQSxPQUFPVyxHQUFHO2dCQUNOLElBQUksQ0FBQ0MsSUFBSSxDQUFDLFNBQVNEO1lBQ3ZCO1FBQ0o7SUFDSjtJQUNBTCxNQUFNUSxNQUFNLEVBQUUsR0FBR0MsTUFBTSxFQUFFO1FBQ3JCLE9BQU8sSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztZQUN6QixJQUFJLENBQUNuQixTQUFTLENBQUNvQixTQUFTLENBQUM7Z0JBQ3JCQyxJQUFJNUI7Z0JBQ0pzQjtnQkFDQUM7Z0JBQ0FNLFNBQVM7WUFDYixHQUFHLENBQUNDLEtBQUtDO2dCQUNMLElBQUlELEtBQUs7b0JBQ0xKLE9BQU9JO2dCQUNYLE9BQ0s7b0JBQ0RMLFFBQVFNLElBQUlDLE1BQU07Z0JBQ3RCO1lBQ0o7UUFDSjtJQUNKO0lBQ0FoQixlQUFlaUIsQ0FBQyxFQUFFQyxRQUFRLEVBQUU7UUFDeEIsSUFBSUM7UUFDSixJQUFJRCxTQUFTWixNQUFNLEtBQUssc0JBQ3BCLENBQUMsQ0FBQ2EsS0FBS0QsU0FBU1gsTUFBTSxNQUFNLFFBQVFZLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0MsWUFBWSxNQUFNLElBQUksQ0FBQzVCLGVBQWUsRUFBRTtZQUN4RyxJQUFJLENBQUNVLG1CQUFtQixDQUFDZ0IsU0FBU1gsTUFBTSxDQUFDUyxNQUFNLENBQUNLLE1BQU07UUFDMUQ7SUFDSjtBQUNKO0FBQ0EzQyw2QkFBNkIsR0FBR0UsdUJBQ2hDLGlEQUFpRCIsInNvdXJjZXMiOlsid2VicGFjazovL3dpdGgtbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvZGlzdC9TdWJzY3JpYmVCbG9ja1RyYWNrZXIuanM/YmQ4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3Vic2NyaWJlQmxvY2tUcmFja2VyID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfcmFuZG9tX2lkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImpzb24tcnBjLXJhbmRvbS1pZFwiKSk7XG5jb25zdCBCYXNlQmxvY2tUcmFja2VyXzEgPSByZXF1aXJlKFwiLi9CYXNlQmxvY2tUcmFja2VyXCIpO1xuY29uc3QgY3JlYXRlUmFuZG9tSWQgPSAoMCwganNvbl9ycGNfcmFuZG9tX2lkXzEuZGVmYXVsdCkoKTtcbmNsYXNzIFN1YnNjcmliZUJsb2NrVHJhY2tlciBleHRlbmRzIEJhc2VCbG9ja1RyYWNrZXJfMS5CYXNlQmxvY2tUcmFja2VyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICAgICAgLy8gcGFyc2UgKyB2YWxpZGF0ZSBhcmdzXG4gICAgICAgIGlmICghb3B0cy5wcm92aWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdWJzY3JpYmVCbG9ja1RyYWNrZXIgLSBubyBwcm92aWRlciBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFzZUJsb2NrVHJhY2tlciBjb25zdHJ1Y3RvclxuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgLy8gY29uZmlnXG4gICAgICAgIHRoaXMuX3Byb3ZpZGVyID0gb3B0cy5wcm92aWRlcjtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uSWQgPSBudWxsO1xuICAgIH1cbiAgICBhc3luYyBjaGVja0ZvckxhdGVzdEJsb2NrKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRMYXRlc3RCbG9jaygpO1xuICAgIH1cbiAgICBhc3luYyBfc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdWJzY3JpcHRpb25JZCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3N1YnNjcmlwdGlvbklkID09PSBudWxsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gKGF3YWl0IHRoaXMuX2NhbGwoJ2V0aF9ibG9ja051bWJlcicpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25JZCA9IChhd2FpdCB0aGlzLl9jYWxsKCdldGhfc3Vic2NyaWJlJywgJ25ld0hlYWRzJykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3ZpZGVyLm9uKCdkYXRhJywgdGhpcy5faGFuZGxlU3ViRGF0YS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZXdQb3RlbnRpYWxMYXRlc3QoYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2VuZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N1YnNjcmlwdGlvbklkICE9PSBudWxsICYmIHRoaXMuX3N1YnNjcmlwdGlvbklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fY2FsbCgnZXRoX3Vuc3Vic2NyaWJlJywgdGhpcy5fc3Vic2NyaXB0aW9uSWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbklkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9jYWxsKG1ldGhvZCwgLi4ucGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wcm92aWRlci5zZW5kQXN5bmMoe1xuICAgICAgICAgICAgICAgIGlkOiBjcmVhdGVSYW5kb21JZCgpLFxuICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICB9LCAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXMucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9oYW5kbGVTdWJEYXRhKF8sIHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLm1ldGhvZCA9PT0gJ2V0aF9zdWJzY3JpcHRpb24nICYmXG4gICAgICAgICAgICAoKF9hID0gcmVzcG9uc2UucGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3Vic2NyaXB0aW9uKSA9PT0gdGhpcy5fc3Vic2NyaXB0aW9uSWQpIHtcbiAgICAgICAgICAgIHRoaXMuX25ld1BvdGVudGlhbExhdGVzdChyZXNwb25zZS5wYXJhbXMucmVzdWx0Lm51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlN1YnNjcmliZUJsb2NrVHJhY2tlciA9IFN1YnNjcmliZUJsb2NrVHJhY2tlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YnNjcmliZUJsb2NrVHJhY2tlci5qcy5tYXAiXSwibmFtZXMiOlsiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU3Vic2NyaWJlQmxvY2tUcmFja2VyIiwianNvbl9ycGNfcmFuZG9tX2lkXzEiLCJyZXF1aXJlIiwiQmFzZUJsb2NrVHJhY2tlcl8xIiwiY3JlYXRlUmFuZG9tSWQiLCJkZWZhdWx0IiwiQmFzZUJsb2NrVHJhY2tlciIsImNvbnN0cnVjdG9yIiwib3B0cyIsInByb3ZpZGVyIiwiRXJyb3IiLCJfcHJvdmlkZXIiLCJfc3Vic2NyaXB0aW9uSWQiLCJjaGVja0ZvckxhdGVzdEJsb2NrIiwiZ2V0TGF0ZXN0QmxvY2siLCJfc3RhcnQiLCJ1bmRlZmluZWQiLCJibG9ja051bWJlciIsIl9jYWxsIiwib24iLCJfaGFuZGxlU3ViRGF0YSIsImJpbmQiLCJfbmV3UG90ZW50aWFsTGF0ZXN0IiwiZSIsImVtaXQiLCJfZW5kIiwibWV0aG9kIiwicGFyYW1zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJzZW5kQXN5bmMiLCJpZCIsImpzb25ycGMiLCJlcnIiLCJyZXMiLCJyZXN1bHQiLCJfIiwicmVzcG9uc2UiLCJfYSIsInN1YnNjcmlwdGlvbiIsIm51bWJlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/dist/SubscribeBlockTracker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/eth-block-tracker/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    });\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n__exportStar(__webpack_require__(/*! ./PollingBlockTracker */ \"(ssr)/./node_modules/eth-block-tracker/dist/PollingBlockTracker.js\"), exports);\n__exportStar(__webpack_require__(/*! ./SubscribeBlockTracker */ \"(ssr)/./node_modules/eth-block-tracker/dist/SubscribeBlockTracker.js\"), exports); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBTUMsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDMUYsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JKLE9BQU9PLGNBQWMsQ0FBQ0wsR0FBR0csSUFBSTtRQUFFRyxZQUFZO1FBQU1DLEtBQUs7WUFBYSxPQUFPTixDQUFDLENBQUNDLEVBQUU7UUFBRTtJQUFFO0FBQ3RGLElBQU0sU0FBU0YsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUN0QixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQkYsQ0FBQyxDQUFDRyxHQUFHLEdBQUdGLENBQUMsQ0FBQ0MsRUFBRTtBQUNoQixDQUFDO0FBQ0QsSUFBSU0sZUFBZSxDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLFlBQVksSUFBSyxTQUFTUCxDQUFDLEVBQUVRLFFBQU87SUFDakUsSUFBSyxJQUFJQyxLQUFLVCxFQUFHLElBQUlTLE1BQU0sYUFBYSxDQUFDWixPQUFPYSxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixVQUFTQyxJQUFJYixnQkFBZ0JZLFVBQVNSLEdBQUdTO0FBQzNIO0FBQ0FaLDhDQUE2QztJQUFFZ0IsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RE4sYUFBYU8sbUJBQU9BLENBQUMsaUdBQXVCLEdBQUdOO0FBQy9DRCxhQUFhTyxtQkFBT0EsQ0FBQyxxR0FBeUIsR0FBR04sVUFDakQsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2l0aC1uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9kaXN0L2luZGV4LmpzP2FiYWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9Qb2xsaW5nQmxvY2tUcmFja2VyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9TdWJzY3JpYmVCbG9ja1RyYWNrZXJcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX19leHBvcnRTdGFyIiwiZXhwb3J0cyIsInAiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJ2YWx1ZSIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/dist/logging-utils.js":
/*!**************************************************************!*\
  !*** ./node_modules/eth-block-tracker/dist/logging-utils.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createModuleLogger = exports.projectLogger = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/index.js\");\nObject.defineProperty(exports, \"createModuleLogger\", ({\n    enumerable: true,\n    get: function() {\n        return utils_1.createModuleLogger;\n    }\n}));\nexports.projectLogger = (0, utils_1.createProjectLogger)(\"eth-block-tracker\"); //# sourceMappingURL=logging-utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvZGlzdC9sb2dnaW5nLXV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwwQkFBMEIsR0FBR0EscUJBQXFCLEdBQUcsS0FBSztBQUMxRCxNQUFNSSxVQUFVQyxtQkFBT0EsQ0FBQywwR0FBaUI7QUFDekNQLHNEQUFxRDtJQUFFUSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSCxRQUFRRixrQkFBa0I7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNuSUYscUJBQXFCLEdBQUcsQ0FBQyxHQUFHSSxRQUFRSSxtQkFBbUIsRUFBRSxzQkFDekQseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2l0aC1uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9kaXN0L2xvZ2dpbmctdXRpbHMuanM/ZGExNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlTW9kdWxlTG9nZ2VyID0gZXhwb3J0cy5wcm9qZWN0TG9nZ2VyID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svdXRpbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVNb2R1bGVMb2dnZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEuY3JlYXRlTW9kdWxlTG9nZ2VyOyB9IH0pO1xuZXhwb3J0cy5wcm9qZWN0TG9nZ2VyID0gKDAsIHV0aWxzXzEuY3JlYXRlUHJvamVjdExvZ2dlcikoJ2V0aC1ibG9jay10cmFja2VyJyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnaW5nLXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNyZWF0ZU1vZHVsZUxvZ2dlciIsInByb2plY3RMb2dnZXIiLCJ1dGlsc18xIiwicmVxdWlyZSIsImVudW1lcmFibGUiLCJnZXQiLCJjcmVhdGVQcm9qZWN0TG9nZ2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/dist/logging-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js":
/*!************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.assertExhaustive = exports.assertStruct = exports.assert = exports.AssertionError = void 0;\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\n/**\n * Type guard for determining whether the given value is an error object with a\n * `message` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns True or false, depending on the result.\n */ function isErrorWithMessage(error) {\n    return typeof error === \"object\" && error !== null && \"message\" in error;\n}\n/**\n * Check if a value is a constructor, i.e., a function that can be called with\n * the `new` keyword.\n *\n * @param fn - The value to check.\n * @returns `true` if the value is a constructor, or `false` otherwise.\n */ function isConstructable(fn) {\n    var _a, _b;\n    /* istanbul ignore next */ return Boolean(typeof ((_b = (_a = fn === null || fn === void 0 ? void 0 : fn.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name) === \"string\");\n}\n/**\n * Get the error message from an unknown error object. If the error object has\n * a `message` property, that property is returned. Otherwise, the stringified\n * error object is returned.\n *\n * @param error - The error object to get the message from.\n * @returns The error message.\n */ function getErrorMessage(error) {\n    const message = isErrorWithMessage(error) ? error.message : String(error);\n    // If the error ends with a period, remove it, as we'll add our own period.\n    if (message.endsWith(\".\")) {\n        return message.slice(0, -1);\n    }\n    return message;\n}\n/**\n * Initialise an {@link AssertionErrorConstructor} error.\n *\n * @param ErrorWrapper - The error class to use.\n * @param message - The error message.\n * @returns The error object.\n */ // eslint-disable-next-line @typescript-eslint/naming-convention\nfunction getError(ErrorWrapper, message) {\n    if (isConstructable(ErrorWrapper)) {\n        return new ErrorWrapper({\n            message\n        });\n    }\n    return ErrorWrapper({\n        message\n    });\n}\n/**\n * The default error class that is thrown if an assertion fails.\n */ class AssertionError extends Error {\n    constructor(options){\n        super(options.message);\n        this.code = \"ERR_ASSERTION\";\n    }\n}\nexports.AssertionError = AssertionError;\n/**\n * Same as Node.js assert.\n * If the value is falsy, throws an error, does nothing otherwise.\n *\n * @throws {@link AssertionError} If value is falsy.\n * @param value - The test that should be truthy to pass.\n * @param message - Message to be passed to {@link AssertionError} or an\n * {@link Error} instance to throw.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}. If a custom error class is provided for\n * the `message` argument, this argument is ignored.\n */ function assert(value, message = \"Assertion failed.\", // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper = AssertionError) {\n    if (!value) {\n        if (message instanceof Error) {\n            throw message;\n        }\n        throw getError(ErrorWrapper, message);\n    }\n}\nexports.assert = assert;\n/**\n * Assert a value against a Superstruct struct.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param errorPrefix - A prefix to add to the error message. Defaults to\n * \"Assertion failed\".\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the value is not valid.\n */ function assertStruct(value, struct, errorPrefix = \"Assertion failed\", // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper = AssertionError) {\n    try {\n        (0, superstruct_1.assert)(value, struct);\n    } catch (error) {\n        throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessage(error)}.`);\n    }\n}\nexports.assertStruct = assertStruct;\n/**\n * Use in the default case of a switch that you want to be fully exhaustive.\n * Using this function forces the compiler to enforce exhaustivity during\n * compile-time.\n *\n * @example\n * ```\n * const number = 1;\n * switch (number) {\n *   case 0:\n *     ...\n *   case 1:\n *     ...\n *   default:\n *     assertExhaustive(snapPrefix);\n * }\n * ```\n * @param _object - The object on which the switch is being operated.\n */ function assertExhaustive(_object) {\n    throw new Error(\"Invalid branch reached. Should be detected during compilation.\");\n}\nexports.assertExhaustive = assertExhaustive; //# sourceMappingURL=assert.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2Fzc2VydC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsd0JBQXdCLEdBQUdBLG9CQUFvQixHQUFHQSxjQUFjLEdBQUdBLHNCQUFzQixHQUFHLEtBQUs7QUFDakcsTUFBTU0sZ0JBQWdCQyxtQkFBT0EsQ0FBQyxvRUFBYTtBQUMzQzs7Ozs7O0NBTUMsR0FDRCxTQUFTQyxtQkFBbUJDLEtBQUs7SUFDN0IsT0FBTyxPQUFPQSxVQUFVLFlBQVlBLFVBQVUsUUFBUSxhQUFhQTtBQUN2RTtBQUNBOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLGdCQUFnQkMsRUFBRTtJQUN2QixJQUFJQyxJQUFJQztJQUNSLHdCQUF3QixHQUN4QixPQUFPQyxRQUFRLE9BQVEsRUFBQ0QsS0FBSyxDQUFDRCxLQUFLRCxPQUFPLFFBQVFBLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0ksU0FBUyxNQUFNLFFBQVFILE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0ksV0FBVyxNQUFNLFFBQVFILE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0ksSUFBSSxNQUFNO0FBQ3BNO0FBQ0E7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNDLGdCQUFnQlQsS0FBSztJQUMxQixNQUFNVSxVQUFVWCxtQkFBbUJDLFNBQVNBLE1BQU1VLE9BQU8sR0FBR0MsT0FBT1g7SUFDbkUsMkVBQTJFO0lBQzNFLElBQUlVLFFBQVFFLFFBQVEsQ0FBQyxNQUFNO1FBQ3ZCLE9BQU9GLFFBQVFHLEtBQUssQ0FBQyxHQUFHLENBQUM7SUFDN0I7SUFDQSxPQUFPSDtBQUNYO0FBQ0E7Ozs7OztDQU1DLEdBQ0QsZ0VBQWdFO0FBQ2hFLFNBQVNJLFNBQVNDLFlBQVksRUFBRUwsT0FBTztJQUNuQyxJQUFJVCxnQkFBZ0JjLGVBQWU7UUFDL0IsT0FBTyxJQUFJQSxhQUFhO1lBQ3BCTDtRQUNKO0lBQ0o7SUFDQSxPQUFPSyxhQUFhO1FBQ2hCTDtJQUNKO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELE1BQU1kLHVCQUF1Qm9CO0lBQ3pCVCxZQUFZVSxPQUFPLENBQUU7UUFDakIsS0FBSyxDQUFDQSxRQUFRUCxPQUFPO1FBQ3JCLElBQUksQ0FBQ1EsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFDQTNCLHNCQUFzQixHQUFHSztBQUN6Qjs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELFNBQVNELE9BQU9ILEtBQUssRUFBRWtCLFVBQVUsbUJBQW1CLEVBQ3BELGdFQUFnRTtBQUNoRUssZUFBZW5CLGNBQWM7SUFDekIsSUFBSSxDQUFDSixPQUFPO1FBQ1IsSUFBSWtCLG1CQUFtQk0sT0FBTztZQUMxQixNQUFNTjtRQUNWO1FBQ0EsTUFBTUksU0FBU0MsY0FBY0w7SUFDakM7QUFDSjtBQUNBbkIsY0FBYyxHQUFHSTtBQUNqQjs7Ozs7Ozs7OztDQVVDLEdBQ0QsU0FBU0QsYUFBYUYsS0FBSyxFQUFFMkIsTUFBTSxFQUFFQyxjQUFjLGtCQUFrQixFQUNyRSxnRUFBZ0U7QUFDaEVMLGVBQWVuQixjQUFjO0lBQ3pCLElBQUk7UUFDQyxJQUFHQyxjQUFjRixNQUFNLEVBQUVILE9BQU8yQjtJQUNyQyxFQUNBLE9BQU9uQixPQUFPO1FBQ1YsTUFBTWMsU0FBU0MsY0FBYyxDQUFDLEVBQUVLLFlBQVksRUFBRSxFQUFFWCxnQkFBZ0JULE9BQU8sQ0FBQyxDQUFDO0lBQzdFO0FBQ0o7QUFDQVQsb0JBQW9CLEdBQUdHO0FBQ3ZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FDRCxTQUFTRCxpQkFBaUI0QixPQUFPO0lBQzdCLE1BQU0sSUFBSUwsTUFBTTtBQUNwQjtBQUNBekIsd0JBQXdCLEdBQUdFLGtCQUMzQixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aXRoLW5leHQtYXBwLy4vbm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9hc3NlcnQuanM/YWVjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXNzZXJ0RXhoYXVzdGl2ZSA9IGV4cG9ydHMuYXNzZXJ0U3RydWN0ID0gZXhwb3J0cy5hc3NlcnQgPSBleHBvcnRzLkFzc2VydGlvbkVycm9yID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJzdXBlcnN0cnVjdFwiKTtcbi8qKlxuICogVHlwZSBndWFyZCBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gZXJyb3Igb2JqZWN0IHdpdGggYVxuICogYG1lc3NhZ2VgIHByb3BlcnR5LCBzdWNoIGFzIGFuIGluc3RhbmNlIG9mIEVycm9yLlxuICpcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBUcnVlIG9yIGZhbHNlLCBkZXBlbmRpbmcgb24gdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gaXNFcnJvcldpdGhNZXNzYWdlKGVycm9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ21lc3NhZ2UnIGluIGVycm9yO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgY29uc3RydWN0b3IsIGkuZS4sIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgY2FsbGVkIHdpdGhcbiAqIHRoZSBgbmV3YCBrZXl3b3JkLlxuICpcbiAqIEBwYXJhbSBmbiAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBjb25zdHJ1Y3Rvciwgb3IgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzQ29uc3RydWN0YWJsZShmbikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gQm9vbGVhbih0eXBlb2YgKChfYiA9IChfYSA9IGZuID09PSBudWxsIHx8IGZuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmbi5wcm90b3R5cGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25zdHJ1Y3RvcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm5hbWUpID09PSAnc3RyaW5nJyk7XG59XG4vKipcbiAqIEdldCB0aGUgZXJyb3IgbWVzc2FnZSBmcm9tIGFuIHVua25vd24gZXJyb3Igb2JqZWN0LiBJZiB0aGUgZXJyb3Igb2JqZWN0IGhhc1xuICogYSBgbWVzc2FnZWAgcHJvcGVydHksIHRoYXQgcHJvcGVydHkgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSwgdGhlIHN0cmluZ2lmaWVkXG4gKiBlcnJvciBvYmplY3QgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIG9iamVjdCB0byBnZXQgdGhlIG1lc3NhZ2UgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBlcnJvciBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UoZXJyb3IpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gaXNFcnJvcldpdGhNZXNzYWdlKGVycm9yKSA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgIC8vIElmIHRoZSBlcnJvciBlbmRzIHdpdGggYSBwZXJpb2QsIHJlbW92ZSBpdCwgYXMgd2UnbGwgYWRkIG91ciBvd24gcGVyaW9kLlxuICAgIGlmIChtZXNzYWdlLmVuZHNXaXRoKCcuJykpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2Uuc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbn1cbi8qKlxuICogSW5pdGlhbGlzZSBhbiB7QGxpbmsgQXNzZXJ0aW9uRXJyb3JDb25zdHJ1Y3Rvcn0gZXJyb3IuXG4gKlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB1c2UuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHJldHVybnMgVGhlIGVycm9yIG9iamVjdC5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuZnVuY3Rpb24gZ2V0RXJyb3IoRXJyb3JXcmFwcGVyLCBtZXNzYWdlKSB7XG4gICAgaWYgKGlzQ29uc3RydWN0YWJsZShFcnJvcldyYXBwZXIpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3JXcmFwcGVyKHtcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gRXJyb3JXcmFwcGVyKHtcbiAgICAgICAgbWVzc2FnZSxcbiAgICB9KTtcbn1cbi8qKlxuICogVGhlIGRlZmF1bHQgZXJyb3IgY2xhc3MgdGhhdCBpcyB0aHJvd24gaWYgYW4gYXNzZXJ0aW9uIGZhaWxzLlxuICovXG5jbGFzcyBBc3NlcnRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMubWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9ICdFUlJfQVNTRVJUSU9OJztcbiAgICB9XG59XG5leHBvcnRzLkFzc2VydGlvbkVycm9yID0gQXNzZXJ0aW9uRXJyb3I7XG4vKipcbiAqIFNhbWUgYXMgTm9kZS5qcyBhc3NlcnQuXG4gKiBJZiB0aGUgdmFsdWUgaXMgZmFsc3ksIHRocm93cyBhbiBlcnJvciwgZG9lcyBub3RoaW5nIG90aGVyd2lzZS5cbiAqXG4gKiBAdGhyb3dzIHtAbGluayBBc3NlcnRpb25FcnJvcn0gSWYgdmFsdWUgaXMgZmFsc3kuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdGVzdCB0aGF0IHNob3VsZCBiZSB0cnV0aHkgdG8gcGFzcy5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gTWVzc2FnZSB0byBiZSBwYXNzZWQgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfSBvciBhblxuICoge0BsaW5rIEVycm9yfSBpbnN0YW5jZSB0byB0aHJvdy5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uIElmIGEgY3VzdG9tIGVycm9yIGNsYXNzIGlzIHByb3ZpZGVkIGZvclxuICogdGhlIGBtZXNzYWdlYCBhcmd1bWVudCwgdGhpcyBhcmd1bWVudCBpcyBpZ25vcmVkLlxuICovXG5mdW5jdGlvbiBhc3NlcnQodmFsdWUsIG1lc3NhZ2UgPSAnQXNzZXJ0aW9uIGZhaWxlZC4nLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlciA9IEFzc2VydGlvbkVycm9yKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGdldEVycm9yKEVycm9yV3JhcHBlciwgbWVzc2FnZSk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG4vKipcbiAqIEFzc2VydCBhIHZhbHVlIGFnYWluc3QgYSBTdXBlcnN0cnVjdCBzdHJ1Y3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHZhbGlkYXRlLlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gdmFsaWRhdGUgYWdhaW5zdC5cbiAqIEBwYXJhbSBlcnJvclByZWZpeCAtIEEgcHJlZml4IHRvIGFkZCB0byB0aGUgZXJyb3IgbWVzc2FnZS4gRGVmYXVsdHMgdG9cbiAqIFwiQXNzZXJ0aW9uIGZhaWxlZFwiLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0U3RydWN0KHZhbHVlLCBzdHJ1Y3QsIGVycm9yUHJlZml4ID0gJ0Fzc2VydGlvbiBmYWlsZWQnLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlciA9IEFzc2VydGlvbkVycm9yKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgKDAsIHN1cGVyc3RydWN0XzEuYXNzZXJ0KSh2YWx1ZSwgc3RydWN0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IGdldEVycm9yKEVycm9yV3JhcHBlciwgYCR7ZXJyb3JQcmVmaXh9OiAke2dldEVycm9yTWVzc2FnZShlcnJvcil9LmApO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzZXJ0U3RydWN0ID0gYXNzZXJ0U3RydWN0O1xuLyoqXG4gKiBVc2UgaW4gdGhlIGRlZmF1bHQgY2FzZSBvZiBhIHN3aXRjaCB0aGF0IHlvdSB3YW50IHRvIGJlIGZ1bGx5IGV4aGF1c3RpdmUuXG4gKiBVc2luZyB0aGlzIGZ1bmN0aW9uIGZvcmNlcyB0aGUgY29tcGlsZXIgdG8gZW5mb3JjZSBleGhhdXN0aXZpdHkgZHVyaW5nXG4gKiBjb21waWxlLXRpbWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogY29uc3QgbnVtYmVyID0gMTtcbiAqIHN3aXRjaCAobnVtYmVyKSB7XG4gKiAgIGNhc2UgMDpcbiAqICAgICAuLi5cbiAqICAgY2FzZSAxOlxuICogICAgIC4uLlxuICogICBkZWZhdWx0OlxuICogICAgIGFzc2VydEV4aGF1c3RpdmUoc25hcFByZWZpeCk7XG4gKiB9XG4gKiBgYGBcbiAqIEBwYXJhbSBfb2JqZWN0IC0gVGhlIG9iamVjdCBvbiB3aGljaCB0aGUgc3dpdGNoIGlzIGJlaW5nIG9wZXJhdGVkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRFeGhhdXN0aXZlKF9vYmplY3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnJhbmNoIHJlYWNoZWQuIFNob3VsZCBiZSBkZXRlY3RlZCBkdXJpbmcgY29tcGlsYXRpb24uJyk7XG59XG5leHBvcnRzLmFzc2VydEV4aGF1c3RpdmUgPSBhc3NlcnRFeGhhdXN0aXZlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzZXJ0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImFzc2VydEV4aGF1c3RpdmUiLCJhc3NlcnRTdHJ1Y3QiLCJhc3NlcnQiLCJBc3NlcnRpb25FcnJvciIsInN1cGVyc3RydWN0XzEiLCJyZXF1aXJlIiwiaXNFcnJvcldpdGhNZXNzYWdlIiwiZXJyb3IiLCJpc0NvbnN0cnVjdGFibGUiLCJmbiIsIl9hIiwiX2IiLCJCb29sZWFuIiwicHJvdG90eXBlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiZ2V0RXJyb3JNZXNzYWdlIiwibWVzc2FnZSIsIlN0cmluZyIsImVuZHNXaXRoIiwic2xpY2UiLCJnZXRFcnJvciIsIkVycm9yV3JhcHBlciIsIkVycm9yIiwib3B0aW9ucyIsImNvZGUiLCJzdHJ1Y3QiLCJlcnJvclByZWZpeCIsIl9vYmplY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/base64.js":
/*!************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/base64.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.base64 = void 0;\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js\");\n/**\n * Ensure that a provided string-based struct is valid base64.\n *\n * @param struct - The string based struct.\n * @param options - Optional options to specialize base64 validation. See {@link Base64Options} documentation.\n * @returns A superstruct validating base64.\n */ const base64 = (struct, options = {})=>{\n    var _a, _b;\n    const paddingRequired = (_a = options.paddingRequired) !== null && _a !== void 0 ? _a : false;\n    const characterSet = (_b = options.characterSet) !== null && _b !== void 0 ? _b : \"base64\";\n    let letters;\n    if (characterSet === \"base64\") {\n        letters = String.raw`[A-Za-z0-9+\\/]`;\n    } else {\n        (0, assert_1.assert)(characterSet === \"base64url\");\n        letters = String.raw`[-_A-Za-z0-9]`;\n    }\n    let re;\n    if (paddingRequired) {\n        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`, \"u\");\n    } else {\n        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`, \"u\");\n    }\n    return (0, superstruct_1.pattern)(struct, re);\n};\nexports.base64 = base64; //# sourceMappingURL=base64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2Jhc2U2NC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHLEtBQUs7QUFDdEIsTUFBTUcsZ0JBQWdCQyxtQkFBT0EsQ0FBQyxvRUFBYTtBQUMzQyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQyxvR0FBVTtBQUNuQzs7Ozs7O0NBTUMsR0FDRCxNQUFNRixTQUFTLENBQUNJLFFBQVFDLFVBQVUsQ0FBQyxDQUFDO0lBQ2hDLElBQUlDLElBQUlDO0lBQ1IsTUFBTUMsa0JBQWtCLENBQUNGLEtBQUtELFFBQVFHLGVBQWUsTUFBTSxRQUFRRixPQUFPLEtBQUssSUFBSUEsS0FBSztJQUN4RixNQUFNRyxlQUFlLENBQUNGLEtBQUtGLFFBQVFJLFlBQVksTUFBTSxRQUFRRixPQUFPLEtBQUssSUFBSUEsS0FBSztJQUNsRixJQUFJRztJQUNKLElBQUlELGlCQUFpQixVQUFVO1FBQzNCQyxVQUFVQyxPQUFPQyxHQUFHLENBQUUsY0FBYyxDQUFDO0lBQ3pDLE9BQ0s7UUFDQSxJQUFHVCxTQUFTVSxNQUFNLEVBQUVKLGlCQUFpQjtRQUN0Q0MsVUFBVUMsT0FBT0MsR0FBRyxDQUFFLGFBQWEsQ0FBQztJQUN4QztJQUNBLElBQUlFO0lBQ0osSUFBSU4saUJBQWlCO1FBQ2pCTSxLQUFLLElBQUlDLE9BQU8sQ0FBQyxJQUFJLEVBQUVMLFFBQVEsUUFBUSxFQUFFQSxRQUFRLEtBQUssRUFBRUEsUUFBUSxRQUFRLENBQUMsRUFBRTtJQUMvRSxPQUNLO1FBQ0RJLEtBQUssSUFBSUMsT0FBTyxDQUFDLElBQUksRUFBRUwsUUFBUSxRQUFRLEVBQUVBLFFBQVEsTUFBTSxFQUFFQSxRQUFRLEtBQUssRUFBRUEsUUFBUSxRQUFRLENBQUMsRUFBRTtJQUMvRjtJQUNBLE9BQU8sQ0FBQyxHQUFHVCxjQUFjZSxPQUFPLEVBQUVaLFFBQVFVO0FBQzlDO0FBQ0FoQixjQUFjLEdBQUdFLFFBQ2pCLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dpdGgtbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2Jhc2U2NC5qcz9iZWExIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5iYXNlNjQgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgcHJvdmlkZWQgc3RyaW5nLWJhc2VkIHN0cnVjdCBpcyB2YWxpZCBiYXNlNjQuXG4gKlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJpbmcgYmFzZWQgc3RydWN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBvcHRpb25zIHRvIHNwZWNpYWxpemUgYmFzZTY0IHZhbGlkYXRpb24uIFNlZSB7QGxpbmsgQmFzZTY0T3B0aW9uc30gZG9jdW1lbnRhdGlvbi5cbiAqIEByZXR1cm5zIEEgc3VwZXJzdHJ1Y3QgdmFsaWRhdGluZyBiYXNlNjQuXG4gKi9cbmNvbnN0IGJhc2U2NCA9IChzdHJ1Y3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgcGFkZGluZ1JlcXVpcmVkID0gKF9hID0gb3B0aW9ucy5wYWRkaW5nUmVxdWlyZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgIGNvbnN0IGNoYXJhY3RlclNldCA9IChfYiA9IG9wdGlvbnMuY2hhcmFjdGVyU2V0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnYmFzZTY0JztcbiAgICBsZXQgbGV0dGVycztcbiAgICBpZiAoY2hhcmFjdGVyU2V0ID09PSAnYmFzZTY0Jykge1xuICAgICAgICBsZXR0ZXJzID0gU3RyaW5nLnJhdyBgW0EtWmEtejAtOStcXC9dYDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGNoYXJhY3RlclNldCA9PT0gJ2Jhc2U2NHVybCcpO1xuICAgICAgICBsZXR0ZXJzID0gU3RyaW5nLnJhdyBgWy1fQS1aYS16MC05XWA7XG4gICAgfVxuICAgIGxldCByZTtcbiAgICBpZiAocGFkZGluZ1JlcXVpcmVkKSB7XG4gICAgICAgIHJlID0gbmV3IFJlZ0V4cChgXig/OiR7bGV0dGVyc317NH0pKig/OiR7bGV0dGVyc317M309fCR7bGV0dGVyc317Mn09PSk/JGAsICd1Jyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZSA9IG5ldyBSZWdFeHAoYF4oPzoke2xldHRlcnN9ezR9KSooPzoke2xldHRlcnN9ezIsM318JHtsZXR0ZXJzfXszfT18JHtsZXR0ZXJzfXsyfT09KT8kYCwgJ3UnKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLnBhdHRlcm4pKHN0cnVjdCwgcmUpO1xufTtcbmV4cG9ydHMuYmFzZTY0ID0gYmFzZTY0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTY0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImJhc2U2NCIsInN1cGVyc3RydWN0XzEiLCJyZXF1aXJlIiwiYXNzZXJ0XzEiLCJzdHJ1Y3QiLCJvcHRpb25zIiwiX2EiLCJfYiIsInBhZGRpbmdSZXF1aXJlZCIsImNoYXJhY3RlclNldCIsImxldHRlcnMiLCJTdHJpbmciLCJyYXciLCJhc3NlcnQiLCJyZSIsIlJlZ0V4cCIsInBhdHRlcm4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/base64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/bytes.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/bytes.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createDataView = exports.concatBytes = exports.valueToBytes = exports.stringToBytes = exports.numberToBytes = exports.signedBigIntToBytes = exports.bigIntToBytes = exports.hexToBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToSignedBigInt = exports.bytesToBigInt = exports.bytesToHex = exports.assertIsBytes = exports.isBytes = void 0;\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js\");\nconst hex_1 = __webpack_require__(/*! ./hex */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/hex.js\");\n// '0'.charCodeAt(0) === 48\nconst HEX_MINIMUM_NUMBER_CHARACTER = 48;\n// '9'.charCodeAt(0) === 57\nconst HEX_MAXIMUM_NUMBER_CHARACTER = 58;\nconst HEX_CHARACTER_OFFSET = 87;\n/**\n * Memoized function that returns an array to be used as a lookup table for\n * converting bytes to hexadecimal values.\n *\n * The array is created lazily and then cached for future use. The benefit of\n * this approach is that the performance of converting bytes to hex is much\n * better than if we were to call `toString(16)` on each byte.\n *\n * The downside is that the array is created once and then never garbage\n * collected. This is not a problem in practice because the array is only 256\n * elements long.\n *\n * @returns A function that returns the lookup table.\n */ function getPrecomputedHexValuesBuilder() {\n    // To avoid issues with tree shaking, we need to use a function to return the\n    // array. This is because the array is only used in the `bytesToHex` function\n    // and if we were to use a global variable, the array might be removed by the\n    // tree shaker.\n    const lookupTable = [];\n    return ()=>{\n        if (lookupTable.length === 0) {\n            for(let i = 0; i < 256; i++){\n                lookupTable.push(i.toString(16).padStart(2, \"0\"));\n            }\n        }\n        return lookupTable;\n    };\n}\n/**\n * Function implementation of the {@link getPrecomputedHexValuesBuilder}\n * function.\n */ const getPrecomputedHexValues = getPrecomputedHexValuesBuilder();\n/**\n * Check if a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @returns Whether the value is a `Uint8Array`.\n */ function isBytes(value) {\n    return value instanceof Uint8Array;\n}\nexports.isBytes = isBytes;\n/**\n * Assert that a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @throws If the value is not a `Uint8Array`.\n */ function assertIsBytes(value) {\n    (0, assert_1.assert)(isBytes(value), \"Value must be a Uint8Array.\");\n}\nexports.assertIsBytes = assertIsBytes;\n/**\n * Convert a `Uint8Array` to a hexadecimal string.\n *\n * @param bytes - The bytes to convert to a hexadecimal string.\n * @returns The hexadecimal string.\n */ function bytesToHex(bytes) {\n    assertIsBytes(bytes);\n    if (bytes.length === 0) {\n        return \"0x\";\n    }\n    const lookupTable = getPrecomputedHexValues();\n    const hexadecimal = new Array(bytes.length);\n    for(let i = 0; i < bytes.length; i++){\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        hexadecimal[i] = lookupTable[bytes[i]];\n    }\n    return (0, hex_1.add0x)(hexadecimal.join(\"\"));\n}\nexports.bytesToHex = bytesToHex;\n/**\n * Convert a `Uint8Array` to a `bigint`.\n *\n * To convert a `Uint8Array` to a `number` instead, use {@link bytesToNumber}.\n * To convert a two's complement encoded `Uint8Array` to a `bigint`, use\n * {@link bytesToSignedBigInt}.\n *\n * @param bytes - The bytes to convert to a `bigint`.\n * @returns The `bigint`.\n */ function bytesToBigInt(bytes) {\n    assertIsBytes(bytes);\n    const hexadecimal = bytesToHex(bytes);\n    return BigInt(hexadecimal);\n}\nexports.bytesToBigInt = bytesToBigInt;\n/**\n * Convert a `Uint8Array` to a signed `bigint`. This assumes that the bytes are\n * encoded in two's complement.\n *\n * To convert a `Uint8Array` to an unsigned `bigint` instead, use\n * {@link bytesToBigInt}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param bytes - The bytes to convert to a signed `bigint`.\n * @returns The signed `bigint`.\n */ function bytesToSignedBigInt(bytes) {\n    assertIsBytes(bytes);\n    let value = BigInt(0);\n    for (const byte of bytes){\n        // eslint-disable-next-line no-bitwise\n        value = (value << BigInt(8)) + BigInt(byte);\n    }\n    return BigInt.asIntN(bytes.length * 8, value);\n}\nexports.bytesToSignedBigInt = bytesToSignedBigInt;\n/**\n * Convert a `Uint8Array` to a `number`.\n *\n * To convert a `Uint8Array` to a `bigint` instead, use {@link bytesToBigInt}.\n *\n * @param bytes - The bytes to convert to a number.\n * @returns The number.\n * @throws If the resulting number is not a safe integer.\n */ function bytesToNumber(bytes) {\n    assertIsBytes(bytes);\n    const bigint = bytesToBigInt(bytes);\n    (0, assert_1.assert)(bigint <= BigInt(Number.MAX_SAFE_INTEGER), \"Number is not a safe integer. Use `bytesToBigInt` instead.\");\n    return Number(bigint);\n}\nexports.bytesToNumber = bytesToNumber;\n/**\n * Convert a UTF-8 encoded `Uint8Array` to a `string`.\n *\n * @param bytes - The bytes to convert to a string.\n * @returns The string.\n */ function bytesToString(bytes) {\n    assertIsBytes(bytes);\n    return new TextDecoder().decode(bytes);\n}\nexports.bytesToString = bytesToString;\n/**\n * Convert a hexadecimal string to a `Uint8Array`. The string can optionally be\n * prefixed with `0x`. It accepts even and odd length strings.\n *\n * If the value is \"0x\", an empty `Uint8Array` is returned.\n *\n * @param value - The hexadecimal string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */ function hexToBytes(value) {\n    var _a;\n    // \"0x\" is often used as empty byte array.\n    if (((_a = value === null || value === void 0 ? void 0 : value.toLowerCase) === null || _a === void 0 ? void 0 : _a.call(value)) === \"0x\") {\n        return new Uint8Array();\n    }\n    (0, hex_1.assertIsHexString)(value);\n    // Remove the `0x` prefix if it exists, and pad the string to have an even\n    // number of characters.\n    const strippedValue = (0, hex_1.remove0x)(value).toLowerCase();\n    const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;\n    const bytes = new Uint8Array(normalizedValue.length / 2);\n    for(let i = 0; i < bytes.length; i++){\n        // While this is not the prettiest way to convert a hexadecimal string to a\n        // `Uint8Array`, it is a lot faster than using `parseInt` to convert each\n        // character.\n        const c1 = normalizedValue.charCodeAt(i * 2);\n        const c2 = normalizedValue.charCodeAt(i * 2 + 1);\n        const n1 = c1 - (c1 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);\n        const n2 = c2 - (c2 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);\n        bytes[i] = n1 * 16 + n2;\n    }\n    return bytes;\n}\nexports.hexToBytes = hexToBytes;\n/**\n * Convert a `bigint` to a `Uint8Array`.\n *\n * This assumes that the `bigint` is an unsigned integer. To convert a signed\n * `bigint` instead, use {@link signedBigIntToBytes}.\n *\n * @param value - The bigint to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */ function bigIntToBytes(value) {\n    (0, assert_1.assert)(typeof value === \"bigint\", \"Value must be a bigint.\");\n    (0, assert_1.assert)(value >= BigInt(0), \"Value must be a non-negative bigint.\");\n    const hexadecimal = value.toString(16);\n    return hexToBytes(hexadecimal);\n}\nexports.bigIntToBytes = bigIntToBytes;\n/**\n * Check if a `bigint` fits in a certain number of bytes.\n *\n * @param value - The `bigint` to check.\n * @param bytes - The number of bytes.\n * @returns Whether the `bigint` fits in the number of bytes.\n */ function bigIntFits(value, bytes) {\n    (0, assert_1.assert)(bytes > 0);\n    /* eslint-disable no-bitwise */ const mask = value >> BigInt(31);\n    return !((~value & mask) + (value & ~mask) >> BigInt(bytes * 8 + ~0));\n/* eslint-enable no-bitwise */ }\n/**\n * Convert a signed `bigint` to a `Uint8Array`. This uses two's complement\n * encoding to represent negative numbers.\n *\n * To convert an unsigned `bigint` to a `Uint8Array` instead, use\n * {@link bigIntToBytes}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param value - The number to convert to bytes.\n * @param byteLength - The length of the resulting `Uint8Array`. If the number\n * is larger than the maximum value that can be represented by the given length,\n * an error is thrown.\n * @returns The bytes as `Uint8Array`.\n */ function signedBigIntToBytes(value, byteLength) {\n    (0, assert_1.assert)(typeof value === \"bigint\", \"Value must be a bigint.\");\n    (0, assert_1.assert)(typeof byteLength === \"number\", \"Byte length must be a number.\");\n    (0, assert_1.assert)(byteLength > 0, \"Byte length must be greater than 0.\");\n    (0, assert_1.assert)(bigIntFits(value, byteLength), \"Byte length is too small to represent the given value.\");\n    // ESLint doesn't like mutating function parameters, so to avoid having to\n    // disable the rule, we create a new variable.\n    let numberValue = value;\n    const bytes = new Uint8Array(byteLength);\n    for(let i = 0; i < bytes.length; i++){\n        bytes[i] = Number(BigInt.asUintN(8, numberValue));\n        // eslint-disable-next-line no-bitwise\n        numberValue >>= BigInt(8);\n    }\n    return bytes.reverse();\n}\nexports.signedBigIntToBytes = signedBigIntToBytes;\n/**\n * Convert a `number` to a `Uint8Array`.\n *\n * @param value - The number to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n * @throws If the number is not a safe integer.\n */ function numberToBytes(value) {\n    (0, assert_1.assert)(typeof value === \"number\", \"Value must be a number.\");\n    (0, assert_1.assert)(value >= 0, \"Value must be a non-negative number.\");\n    (0, assert_1.assert)(Number.isSafeInteger(value), \"Value is not a safe integer. Use `bigIntToBytes` instead.\");\n    const hexadecimal = value.toString(16);\n    return hexToBytes(hexadecimal);\n}\nexports.numberToBytes = numberToBytes;\n/**\n * Convert a `string` to a UTF-8 encoded `Uint8Array`.\n *\n * @param value - The string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */ function stringToBytes(value) {\n    (0, assert_1.assert)(typeof value === \"string\", \"Value must be a string.\");\n    return new TextEncoder().encode(value);\n}\nexports.stringToBytes = stringToBytes;\n/**\n * Convert a byte-like value to a `Uint8Array`. The value can be a `Uint8Array`,\n * a `bigint`, a `number`, or a `string`.\n *\n * This will attempt to guess the type of the value based on its type and\n * contents. For more control over the conversion, use the more specific\n * conversion functions, such as {@link hexToBytes} or {@link stringToBytes}.\n *\n * If the value is a `string`, and it is prefixed with `0x`, it will be\n * interpreted as a hexadecimal string. Otherwise, it will be interpreted as a\n * UTF-8 string. To convert a hexadecimal string to bytes without interpreting\n * it as a UTF-8 string, use {@link hexToBytes} instead.\n *\n * If the value is a `bigint`, it is assumed to be unsigned. To convert a signed\n * `bigint` to bytes, use {@link signedBigIntToBytes} instead.\n *\n * If the value is a `Uint8Array`, it will be returned as-is.\n *\n * @param value - The value to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */ function valueToBytes(value) {\n    if (typeof value === \"bigint\") {\n        return bigIntToBytes(value);\n    }\n    if (typeof value === \"number\") {\n        return numberToBytes(value);\n    }\n    if (typeof value === \"string\") {\n        if (value.startsWith(\"0x\")) {\n            return hexToBytes(value);\n        }\n        return stringToBytes(value);\n    }\n    if (isBytes(value)) {\n        return value;\n    }\n    throw new TypeError(`Unsupported value type: \"${typeof value}\".`);\n}\nexports.valueToBytes = valueToBytes;\n/**\n * Concatenate multiple byte-like values into a single `Uint8Array`. The values\n * can be `Uint8Array`, `bigint`, `number`, or `string`. This uses\n * {@link valueToBytes} under the hood to convert each value to bytes. Refer to\n * the documentation of that function for more information.\n *\n * @param values - The values to concatenate.\n * @returns The concatenated bytes as `Uint8Array`.\n */ function concatBytes(values) {\n    const normalizedValues = new Array(values.length);\n    let byteLength = 0;\n    for(let i = 0; i < values.length; i++){\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const value = valueToBytes(values[i]);\n        normalizedValues[i] = value;\n        byteLength += value.length;\n    }\n    const bytes = new Uint8Array(byteLength);\n    for(let i = 0, offset = 0; i < normalizedValues.length; i++){\n        // While we could simply spread the values into an array and use\n        // `Uint8Array.from`, that is a lot slower than using `Uint8Array.set`.\n        bytes.set(normalizedValues[i], offset);\n        offset += normalizedValues[i].length;\n    }\n    return bytes;\n}\nexports.concatBytes = concatBytes;\n/**\n * Create a {@link DataView} from a {@link Uint8Array}. This is a convenience\n * function that avoids having to create a {@link DataView} manually, which\n * requires passing the `byteOffset` and `byteLength` parameters every time.\n *\n * Not passing the `byteOffset` and `byteLength` parameters can result in\n * unexpected behavior when the {@link Uint8Array} is a view of a larger\n * {@link ArrayBuffer}, e.g., when using {@link Uint8Array.subarray}.\n *\n * This function also supports Node.js {@link Buffer}s.\n *\n * @example\n * ```typescript\n * const bytes = new Uint8Array([1, 2, 3]);\n *\n * // This is equivalent to:\n * // const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n * const dataView = createDataView(bytes);\n * ```\n * @param bytes - The bytes to create the {@link DataView} from.\n * @returns The {@link DataView}.\n */ function createDataView(bytes) {\n    // To maintain compatibility with Node.js, we need to check if the bytes are\n    // a Buffer. If so, we need to slice the buffer to get the underlying\n    // ArrayBuffer.\n    // eslint-disable-next-line no-restricted-globals\n    if (typeof Buffer !== \"undefined\" && bytes instanceof Buffer) {\n        const buffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);\n        return new DataView(buffer);\n    }\n    return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n}\nexports.createDataView = createDataView; //# sourceMappingURL=bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2J5dGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxzQkFBc0IsR0FBR0EsbUJBQW1CLEdBQUdBLG9CQUFvQixHQUFHQSxxQkFBcUIsR0FBR0EscUJBQXFCLEdBQUdBLDJCQUEyQixHQUFHQSxxQkFBcUIsR0FBR0Esa0JBQWtCLEdBQUdBLHFCQUFxQixHQUFHQSxxQkFBcUIsR0FBR0EsMkJBQTJCLEdBQUdBLHFCQUFxQixHQUFHQSxrQkFBa0IsR0FBR0EscUJBQXFCLEdBQUdBLGVBQWUsR0FBRyxLQUFLO0FBQzNXLE1BQU1pQixXQUFXQyxtQkFBT0EsQ0FBQyxvR0FBVTtBQUNuQyxNQUFNQyxRQUFRRCxtQkFBT0EsQ0FBQyw4RkFBTztBQUM3QiwyQkFBMkI7QUFDM0IsTUFBTUUsK0JBQStCO0FBQ3JDLDJCQUEyQjtBQUMzQixNQUFNQywrQkFBK0I7QUFDckMsTUFBTUMsdUJBQXVCO0FBQzdCOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDRCxTQUFTQztJQUNMLDZFQUE2RTtJQUM3RSw2RUFBNkU7SUFDN0UsNkVBQTZFO0lBQzdFLGVBQWU7SUFDZixNQUFNQyxjQUFjLEVBQUU7SUFDdEIsT0FBTztRQUNILElBQUlBLFlBQVlDLE1BQU0sS0FBSyxHQUFHO1lBQzFCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJLEtBQUtBLElBQUs7Z0JBQzFCRixZQUFZRyxJQUFJLENBQUNELEVBQUVFLFFBQVEsQ0FBQyxJQUFJQyxRQUFRLENBQUMsR0FBRztZQUNoRDtRQUNKO1FBQ0EsT0FBT0w7SUFDWDtBQUNKO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTU0sMEJBQTBCUDtBQUNoQzs7Ozs7Q0FLQyxHQUNELFNBQVNQLFFBQVFmLEtBQUs7SUFDbEIsT0FBT0EsaUJBQWlCOEI7QUFDNUI7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QUFJLE9BQU93QyxXQUFXLGVBQWV4QyxpQkFBaUJ3QyxRQUFRO1FBQzFELE1BQU1DLFNBQVN6QyxNQUFNeUMsTUFBTSxDQUFDQyxLQUFLLENBQUMxQyxNQUFNMkMsVUFBVSxFQUFFM0MsTUFBTTJDLFVBQVUsR0FBRzNDLE1BQU0yQixVQUFVO1FBQ3ZGLE9BQU8sSUFBSWlCLFNBQVNIO0lBQ3hCO0lBQ0EsT0FBTyxJQUFJRyxTQUFTNUMsTUFBTXlDLE1BQU0sRUFBRXpDLE1BQU0yQyxVQUFVLEVBQUUzQyxNQUFNMkIsVUFBVTtBQUN4RTtBQUNBNUQsc0JBQXNCLEdBQUdFLGdCQUN6QixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aXRoLW5leHQtYXBwLy4vbm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9ieXRlcy5qcz9kMDhjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVEYXRhVmlldyA9IGV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBleHBvcnRzLnZhbHVlVG9CeXRlcyA9IGV4cG9ydHMuc3RyaW5nVG9CeXRlcyA9IGV4cG9ydHMubnVtYmVyVG9CeXRlcyA9IGV4cG9ydHMuc2lnbmVkQmlnSW50VG9CeXRlcyA9IGV4cG9ydHMuYmlnSW50VG9CeXRlcyA9IGV4cG9ydHMuaGV4VG9CeXRlcyA9IGV4cG9ydHMuYnl0ZXNUb1N0cmluZyA9IGV4cG9ydHMuYnl0ZXNUb051bWJlciA9IGV4cG9ydHMuYnl0ZXNUb1NpZ25lZEJpZ0ludCA9IGV4cG9ydHMuYnl0ZXNUb0JpZ0ludCA9IGV4cG9ydHMuYnl0ZXNUb0hleCA9IGV4cG9ydHMuYXNzZXJ0SXNCeXRlcyA9IGV4cG9ydHMuaXNCeXRlcyA9IHZvaWQgMDtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0XCIpO1xuY29uc3QgaGV4XzEgPSByZXF1aXJlKFwiLi9oZXhcIik7XG4vLyAnMCcuY2hhckNvZGVBdCgwKSA9PT0gNDhcbmNvbnN0IEhFWF9NSU5JTVVNX05VTUJFUl9DSEFSQUNURVIgPSA0ODtcbi8vICc5Jy5jaGFyQ29kZUF0KDApID09PSA1N1xuY29uc3QgSEVYX01BWElNVU1fTlVNQkVSX0NIQVJBQ1RFUiA9IDU4O1xuY29uc3QgSEVYX0NIQVJBQ1RFUl9PRkZTRVQgPSA4Nztcbi8qKlxuICogTWVtb2l6ZWQgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGFycmF5IHRvIGJlIHVzZWQgYXMgYSBsb29rdXAgdGFibGUgZm9yXG4gKiBjb252ZXJ0aW5nIGJ5dGVzIHRvIGhleGFkZWNpbWFsIHZhbHVlcy5cbiAqXG4gKiBUaGUgYXJyYXkgaXMgY3JlYXRlZCBsYXppbHkgYW5kIHRoZW4gY2FjaGVkIGZvciBmdXR1cmUgdXNlLiBUaGUgYmVuZWZpdCBvZlxuICogdGhpcyBhcHByb2FjaCBpcyB0aGF0IHRoZSBwZXJmb3JtYW5jZSBvZiBjb252ZXJ0aW5nIGJ5dGVzIHRvIGhleCBpcyBtdWNoXG4gKiBiZXR0ZXIgdGhhbiBpZiB3ZSB3ZXJlIHRvIGNhbGwgYHRvU3RyaW5nKDE2KWAgb24gZWFjaCBieXRlLlxuICpcbiAqIFRoZSBkb3duc2lkZSBpcyB0aGF0IHRoZSBhcnJheSBpcyBjcmVhdGVkIG9uY2UgYW5kIHRoZW4gbmV2ZXIgZ2FyYmFnZVxuICogY29sbGVjdGVkLiBUaGlzIGlzIG5vdCBhIHByb2JsZW0gaW4gcHJhY3RpY2UgYmVjYXVzZSB0aGUgYXJyYXkgaXMgb25seSAyNTZcbiAqIGVsZW1lbnRzIGxvbmcuXG4gKlxuICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGxvb2t1cCB0YWJsZS5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJlY29tcHV0ZWRIZXhWYWx1ZXNCdWlsZGVyKCkge1xuICAgIC8vIFRvIGF2b2lkIGlzc3VlcyB3aXRoIHRyZWUgc2hha2luZywgd2UgbmVlZCB0byB1c2UgYSBmdW5jdGlvbiB0byByZXR1cm4gdGhlXG4gICAgLy8gYXJyYXkuIFRoaXMgaXMgYmVjYXVzZSB0aGUgYXJyYXkgaXMgb25seSB1c2VkIGluIHRoZSBgYnl0ZXNUb0hleGAgZnVuY3Rpb25cbiAgICAvLyBhbmQgaWYgd2Ugd2VyZSB0byB1c2UgYSBnbG9iYWwgdmFyaWFibGUsIHRoZSBhcnJheSBtaWdodCBiZSByZW1vdmVkIGJ5IHRoZVxuICAgIC8vIHRyZWUgc2hha2VyLlxuICAgIGNvbnN0IGxvb2t1cFRhYmxlID0gW107XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKGxvb2t1cFRhYmxlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGxvb2t1cFRhYmxlLnB1c2goaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvb2t1cFRhYmxlO1xuICAgIH07XG59XG4vKipcbiAqIEZ1bmN0aW9uIGltcGxlbWVudGF0aW9uIG9mIHRoZSB7QGxpbmsgZ2V0UHJlY29tcHV0ZWRIZXhWYWx1ZXNCdWlsZGVyfVxuICogZnVuY3Rpb24uXG4gKi9cbmNvbnN0IGdldFByZWNvbXB1dGVkSGV4VmFsdWVzID0gZ2V0UHJlY29tcHV0ZWRIZXhWYWx1ZXNCdWlsZGVyKCk7XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBgVWludDhBcnJheWAuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGlzQnl0ZXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xufVxuZXhwb3J0cy5pc0J5dGVzID0gaXNCeXRlcztcbi8qKlxuICogQXNzZXJ0IHRoYXQgYSB2YWx1ZSBpcyBhIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzQnl0ZXModmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShpc0J5dGVzKHZhbHVlKSwgJ1ZhbHVlIG11c3QgYmUgYSBVaW50OEFycmF5LicpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0J5dGVzID0gYXNzZXJ0SXNCeXRlcztcbi8qKlxuICogQ29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY29udmVydCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnMHgnO1xuICAgIH1cbiAgICBjb25zdCBsb29rdXBUYWJsZSA9IGdldFByZWNvbXB1dGVkSGV4VmFsdWVzKCk7XG4gICAgY29uc3QgaGV4YWRlY2ltYWwgPSBuZXcgQXJyYXkoYnl0ZXMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGhleGFkZWNpbWFsW2ldID0gbG9va3VwVGFibGVbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGhleF8xLmFkZDB4KShoZXhhZGVjaW1hbC5qb2luKCcnKSk7XG59XG5leHBvcnRzLmJ5dGVzVG9IZXggPSBieXRlc1RvSGV4O1xuLyoqXG4gKiBDb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgYGJpZ2ludGAuXG4gKlxuICogVG8gY29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIGBudW1iZXJgIGluc3RlYWQsIHVzZSB7QGxpbmsgYnl0ZXNUb051bWJlcn0uXG4gKiBUbyBjb252ZXJ0IGEgdHdvJ3MgY29tcGxlbWVudCBlbmNvZGVkIGBVaW50OEFycmF5YCB0byBhIGBiaWdpbnRgLCB1c2VcbiAqIHtAbGluayBieXRlc1RvU2lnbmVkQmlnSW50fS5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY29udmVydCB0byBhIGBiaWdpbnRgLlxuICogQHJldHVybnMgVGhlIGBiaWdpbnRgLlxuICovXG5mdW5jdGlvbiBieXRlc1RvQmlnSW50KGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgY29uc3QgaGV4YWRlY2ltYWwgPSBieXRlc1RvSGV4KGJ5dGVzKTtcbiAgICByZXR1cm4gQmlnSW50KGhleGFkZWNpbWFsKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb0JpZ0ludCA9IGJ5dGVzVG9CaWdJbnQ7XG4vKipcbiAqIENvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBzaWduZWQgYGJpZ2ludGAuIFRoaXMgYXNzdW1lcyB0aGF0IHRoZSBieXRlcyBhcmVcbiAqIGVuY29kZWQgaW4gdHdvJ3MgY29tcGxlbWVudC5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGFuIHVuc2lnbmVkIGBiaWdpbnRgIGluc3RlYWQsIHVzZVxuICoge0BsaW5rIGJ5dGVzVG9CaWdJbnR9LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHdvJTI3c19jb21wbGVtZW50XG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY29udmVydCB0byBhIHNpZ25lZCBgYmlnaW50YC5cbiAqIEByZXR1cm5zIFRoZSBzaWduZWQgYGJpZ2ludGAuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9TaWduZWRCaWdJbnQoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICBsZXQgdmFsdWUgPSBCaWdJbnQoMCk7XG4gICAgZm9yIChjb25zdCBieXRlIG9mIGJ5dGVzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgIHZhbHVlID0gKHZhbHVlIDw8IEJpZ0ludCg4KSkgKyBCaWdJbnQoYnl0ZSk7XG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQuYXNJbnROKGJ5dGVzLmxlbmd0aCAqIDgsIHZhbHVlKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb1NpZ25lZEJpZ0ludCA9IGJ5dGVzVG9TaWduZWRCaWdJbnQ7XG4vKipcbiAqIENvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBgbnVtYmVyYC5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgYGJpZ2ludGAgaW5zdGVhZCwgdXNlIHtAbGluayBieXRlc1RvQmlnSW50fS5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY29udmVydCB0byBhIG51bWJlci5cbiAqIEByZXR1cm5zIFRoZSBudW1iZXIuXG4gKiBAdGhyb3dzIElmIHRoZSByZXN1bHRpbmcgbnVtYmVyIGlzIG5vdCBhIHNhZmUgaW50ZWdlci5cbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb051bWJlcihieXRlcykge1xuICAgIGFzc2VydElzQnl0ZXMoYnl0ZXMpO1xuICAgIGNvbnN0IGJpZ2ludCA9IGJ5dGVzVG9CaWdJbnQoYnl0ZXMpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGJpZ2ludCA8PSBCaWdJbnQoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpLCAnTnVtYmVyIGlzIG5vdCBhIHNhZmUgaW50ZWdlci4gVXNlIGBieXRlc1RvQmlnSW50YCBpbnN0ZWFkLicpO1xuICAgIHJldHVybiBOdW1iZXIoYmlnaW50KTtcbn1cbmV4cG9ydHMuYnl0ZXNUb051bWJlciA9IGJ5dGVzVG9OdW1iZXI7XG4vKipcbiAqIENvbnZlcnQgYSBVVEYtOCBlbmNvZGVkIGBVaW50OEFycmF5YCB0byBhIGBzdHJpbmdgLlxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjb252ZXJ0IHRvIGEgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhieXRlcykge1xuICAgIGFzc2VydElzQnl0ZXMoYnl0ZXMpO1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xufVxuZXhwb3J0cy5ieXRlc1RvU3RyaW5nID0gYnl0ZXNUb1N0cmluZztcbi8qKlxuICogQ29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhIGBVaW50OEFycmF5YC4gVGhlIHN0cmluZyBjYW4gb3B0aW9uYWxseSBiZVxuICogcHJlZml4ZWQgd2l0aCBgMHhgLiBJdCBhY2NlcHRzIGV2ZW4gYW5kIG9kZCBsZW5ndGggc3RyaW5ncy5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgXCIweFwiLCBhbiBlbXB0eSBgVWludDhBcnJheWAgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICogQHJldHVybnMgVGhlIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gaGV4VG9CeXRlcyh2YWx1ZSkge1xuICAgIHZhciBfYTtcbiAgICAvLyBcIjB4XCIgaXMgb2Z0ZW4gdXNlZCBhcyBlbXB0eSBieXRlIGFycmF5LlxuICAgIGlmICgoKF9hID0gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLnRvTG93ZXJDYXNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh2YWx1ZSkpID09PSAnMHgnKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICAgIH1cbiAgICAoMCwgaGV4XzEuYXNzZXJ0SXNIZXhTdHJpbmcpKHZhbHVlKTtcbiAgICAvLyBSZW1vdmUgdGhlIGAweGAgcHJlZml4IGlmIGl0IGV4aXN0cywgYW5kIHBhZCB0aGUgc3RyaW5nIHRvIGhhdmUgYW4gZXZlblxuICAgIC8vIG51bWJlciBvZiBjaGFyYWN0ZXJzLlxuICAgIGNvbnN0IHN0cmlwcGVkVmFsdWUgPSAoMCwgaGV4XzEucmVtb3ZlMHgpKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZSA9IHN0cmlwcGVkVmFsdWUubGVuZ3RoICUgMiA9PT0gMCA/IHN0cmlwcGVkVmFsdWUgOiBgMCR7c3RyaXBwZWRWYWx1ZX1gO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobm9ybWFsaXplZFZhbHVlLmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gV2hpbGUgdGhpcyBpcyBub3QgdGhlIHByZXR0aWVzdCB3YXkgdG8gY29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhXG4gICAgICAgIC8vIGBVaW50OEFycmF5YCwgaXQgaXMgYSBsb3QgZmFzdGVyIHRoYW4gdXNpbmcgYHBhcnNlSW50YCB0byBjb252ZXJ0IGVhY2hcbiAgICAgICAgLy8gY2hhcmFjdGVyLlxuICAgICAgICBjb25zdCBjMSA9IG5vcm1hbGl6ZWRWYWx1ZS5jaGFyQ29kZUF0KGkgKiAyKTtcbiAgICAgICAgY29uc3QgYzIgPSBub3JtYWxpemVkVmFsdWUuY2hhckNvZGVBdChpICogMiArIDEpO1xuICAgICAgICBjb25zdCBuMSA9IGMxIC1cbiAgICAgICAgICAgIChjMSA8IEhFWF9NQVhJTVVNX05VTUJFUl9DSEFSQUNURVJcbiAgICAgICAgICAgICAgICA/IEhFWF9NSU5JTVVNX05VTUJFUl9DSEFSQUNURVJcbiAgICAgICAgICAgICAgICA6IEhFWF9DSEFSQUNURVJfT0ZGU0VUKTtcbiAgICAgICAgY29uc3QgbjIgPSBjMiAtXG4gICAgICAgICAgICAoYzIgPCBIRVhfTUFYSU1VTV9OVU1CRVJfQ0hBUkFDVEVSXG4gICAgICAgICAgICAgICAgPyBIRVhfTUlOSU1VTV9OVU1CRVJfQ0hBUkFDVEVSXG4gICAgICAgICAgICAgICAgOiBIRVhfQ0hBUkFDVEVSX09GRlNFVCk7XG4gICAgICAgIGJ5dGVzW2ldID0gbjEgKiAxNiArIG4yO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5leHBvcnRzLmhleFRvQnl0ZXMgPSBoZXhUb0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYGJpZ2ludGAgdG8gYSBgVWludDhBcnJheWAuXG4gKlxuICogVGhpcyBhc3N1bWVzIHRoYXQgdGhlIGBiaWdpbnRgIGlzIGFuIHVuc2lnbmVkIGludGVnZXIuIFRvIGNvbnZlcnQgYSBzaWduZWRcbiAqIGBiaWdpbnRgIGluc3RlYWQsIHVzZSB7QGxpbmsgc2lnbmVkQmlnSW50VG9CeXRlc30uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGJpZ2ludCB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICogQHJldHVybnMgVGhlIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmlnSW50VG9CeXRlcyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcsICdWYWx1ZSBtdXN0IGJlIGEgYmlnaW50LicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHZhbHVlID49IEJpZ0ludCgwKSwgJ1ZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgYmlnaW50LicpO1xuICAgIGNvbnN0IGhleGFkZWNpbWFsID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXhUb0J5dGVzKGhleGFkZWNpbWFsKTtcbn1cbmV4cG9ydHMuYmlnSW50VG9CeXRlcyA9IGJpZ0ludFRvQnl0ZXM7XG4vKipcbiAqIENoZWNrIGlmIGEgYGJpZ2ludGAgZml0cyBpbiBhIGNlcnRhaW4gbnVtYmVyIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBgYmlnaW50YCB0byBjaGVjay5cbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBudW1iZXIgb2YgYnl0ZXMuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBgYmlnaW50YCBmaXRzIGluIHRoZSBudW1iZXIgb2YgYnl0ZXMuXG4gKi9cbmZ1bmN0aW9uIGJpZ0ludEZpdHModmFsdWUsIGJ5dGVzKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoYnl0ZXMgPiAwKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4gICAgY29uc3QgbWFzayA9IHZhbHVlID4+IEJpZ0ludCgzMSk7XG4gICAgcmV0dXJuICEoKCh+dmFsdWUgJiBtYXNrKSArICh2YWx1ZSAmIH5tYXNrKSkgPj4gQmlnSW50KGJ5dGVzICogOCArIH4wKSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1iaXR3aXNlICovXG59XG4vKipcbiAqIENvbnZlcnQgYSBzaWduZWQgYGJpZ2ludGAgdG8gYSBgVWludDhBcnJheWAuIFRoaXMgdXNlcyB0d28ncyBjb21wbGVtZW50XG4gKiBlbmNvZGluZyB0byByZXByZXNlbnQgbmVnYXRpdmUgbnVtYmVycy5cbiAqXG4gKiBUbyBjb252ZXJ0IGFuIHVuc2lnbmVkIGBiaWdpbnRgIHRvIGEgYFVpbnQ4QXJyYXlgIGluc3RlYWQsIHVzZVxuICoge0BsaW5rIGJpZ0ludFRvQnl0ZXN9LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHdvJTI3c19jb21wbGVtZW50XG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcGFyYW0gYnl0ZUxlbmd0aCAtIFRoZSBsZW5ndGggb2YgdGhlIHJlc3VsdGluZyBgVWludDhBcnJheWAuIElmIHRoZSBudW1iZXJcbiAqIGlzIGxhcmdlciB0aGFuIHRoZSBtYXhpbXVtIHZhbHVlIHRoYXQgY2FuIGJlIHJlcHJlc2VudGVkIGJ5IHRoZSBnaXZlbiBsZW5ndGgsXG4gKiBhbiBlcnJvciBpcyB0aHJvd24uXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBzaWduZWRCaWdJbnRUb0J5dGVzKHZhbHVlLCBieXRlTGVuZ3RoKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JywgJ1ZhbHVlIG11c3QgYmUgYSBiaWdpbnQuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIGJ5dGVMZW5ndGggPT09ICdudW1iZXInLCAnQnl0ZSBsZW5ndGggbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShieXRlTGVuZ3RoID4gMCwgJ0J5dGUgbGVuZ3RoIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoYmlnSW50Rml0cyh2YWx1ZSwgYnl0ZUxlbmd0aCksICdCeXRlIGxlbmd0aCBpcyB0b28gc21hbGwgdG8gcmVwcmVzZW50IHRoZSBnaXZlbiB2YWx1ZS4nKTtcbiAgICAvLyBFU0xpbnQgZG9lc24ndCBsaWtlIG11dGF0aW5nIGZ1bmN0aW9uIHBhcmFtZXRlcnMsIHNvIHRvIGF2b2lkIGhhdmluZyB0b1xuICAgIC8vIGRpc2FibGUgdGhlIHJ1bGUsIHdlIGNyZWF0ZSBhIG5ldyB2YXJpYWJsZS5cbiAgICBsZXQgbnVtYmVyVmFsdWUgPSB2YWx1ZTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVMZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYnl0ZXNbaV0gPSBOdW1iZXIoQmlnSW50LmFzVWludE4oOCwgbnVtYmVyVmFsdWUpKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgbnVtYmVyVmFsdWUgPj49IEJpZ0ludCg4KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzLnJldmVyc2UoKTtcbn1cbmV4cG9ydHMuc2lnbmVkQmlnSW50VG9CeXRlcyA9IHNpZ25lZEJpZ0ludFRvQnl0ZXM7XG4vKipcbiAqIENvbnZlcnQgYSBgbnVtYmVyYCB0byBhIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICogQHRocm93cyBJZiB0aGUgbnVtYmVyIGlzIG5vdCBhIHNhZmUgaW50ZWdlci5cbiAqL1xuZnVuY3Rpb24gbnVtYmVyVG9CeXRlcyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdWYWx1ZSBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHZhbHVlID49IDAsICdWYWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSksICdWYWx1ZSBpcyBub3QgYSBzYWZlIGludGVnZXIuIFVzZSBgYmlnSW50VG9CeXRlc2AgaW5zdGVhZC4nKTtcbiAgICBjb25zdCBoZXhhZGVjaW1hbCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhoZXhhZGVjaW1hbCk7XG59XG5leHBvcnRzLm51bWJlclRvQnl0ZXMgPSBudW1iZXJUb0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYHN0cmluZ2AgdG8gYSBVVEYtOCBlbmNvZGVkIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJywgJ1ZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XG59XG5leHBvcnRzLnN0cmluZ1RvQnl0ZXMgPSBzdHJpbmdUb0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYnl0ZS1saWtlIHZhbHVlIHRvIGEgYFVpbnQ4QXJyYXlgLiBUaGUgdmFsdWUgY2FuIGJlIGEgYFVpbnQ4QXJyYXlgLFxuICogYSBgYmlnaW50YCwgYSBgbnVtYmVyYCwgb3IgYSBgc3RyaW5nYC5cbiAqXG4gKiBUaGlzIHdpbGwgYXR0ZW1wdCB0byBndWVzcyB0aGUgdHlwZSBvZiB0aGUgdmFsdWUgYmFzZWQgb24gaXRzIHR5cGUgYW5kXG4gKiBjb250ZW50cy4gRm9yIG1vcmUgY29udHJvbCBvdmVyIHRoZSBjb252ZXJzaW9uLCB1c2UgdGhlIG1vcmUgc3BlY2lmaWNcbiAqIGNvbnZlcnNpb24gZnVuY3Rpb25zLCBzdWNoIGFzIHtAbGluayBoZXhUb0J5dGVzfSBvciB7QGxpbmsgc3RyaW5nVG9CeXRlc30uXG4gKlxuICogSWYgdGhlIHZhbHVlIGlzIGEgYHN0cmluZ2AsIGFuZCBpdCBpcyBwcmVmaXhlZCB3aXRoIGAweGAsIGl0IHdpbGwgYmVcbiAqIGludGVycHJldGVkIGFzIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBPdGhlcndpc2UsIGl0IHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgYVxuICogVVRGLTggc3RyaW5nLiBUbyBjb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGJ5dGVzIHdpdGhvdXQgaW50ZXJwcmV0aW5nXG4gKiBpdCBhcyBhIFVURi04IHN0cmluZywgdXNlIHtAbGluayBoZXhUb0J5dGVzfSBpbnN0ZWFkLlxuICpcbiAqIElmIHRoZSB2YWx1ZSBpcyBhIGBiaWdpbnRgLCBpdCBpcyBhc3N1bWVkIHRvIGJlIHVuc2lnbmVkLiBUbyBjb252ZXJ0IGEgc2lnbmVkXG4gKiBgYmlnaW50YCB0byBieXRlcywgdXNlIHtAbGluayBzaWduZWRCaWdJbnRUb0J5dGVzfSBpbnN0ZWFkLlxuICpcbiAqIElmIHRoZSB2YWx1ZSBpcyBhIGBVaW50OEFycmF5YCwgaXQgd2lsbCBiZSByZXR1cm5lZCBhcy1pcy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIHZhbHVlVG9CeXRlcyh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHJldHVybiBiaWdJbnRUb0J5dGVzKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlclRvQnl0ZXModmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXModmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdUb0J5dGVzKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGlzQnl0ZXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdmFsdWUgdHlwZTogXCIke3R5cGVvZiB2YWx1ZX1cIi5gKTtcbn1cbmV4cG9ydHMudmFsdWVUb0J5dGVzID0gdmFsdWVUb0J5dGVzO1xuLyoqXG4gKiBDb25jYXRlbmF0ZSBtdWx0aXBsZSBieXRlLWxpa2UgdmFsdWVzIGludG8gYSBzaW5nbGUgYFVpbnQ4QXJyYXlgLiBUaGUgdmFsdWVzXG4gKiBjYW4gYmUgYFVpbnQ4QXJyYXlgLCBgYmlnaW50YCwgYG51bWJlcmAsIG9yIGBzdHJpbmdgLiBUaGlzIHVzZXNcbiAqIHtAbGluayB2YWx1ZVRvQnl0ZXN9IHVuZGVyIHRoZSBob29kIHRvIGNvbnZlcnQgZWFjaCB2YWx1ZSB0byBieXRlcy4gUmVmZXIgdG9cbiAqIHRoZSBkb2N1bWVudGF0aW9uIG9mIHRoYXQgZnVuY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgdG8gY29uY2F0ZW5hdGUuXG4gKiBAcmV0dXJucyBUaGUgY29uY2F0ZW5hdGVkIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29uY2F0Qnl0ZXModmFsdWVzKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZFZhbHVlcyA9IG5ldyBBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICBsZXQgYnl0ZUxlbmd0aCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZVRvQnl0ZXModmFsdWVzW2ldKTtcbiAgICAgICAgbm9ybWFsaXplZFZhbHVlc1tpXSA9IHZhbHVlO1xuICAgICAgICBieXRlTGVuZ3RoICs9IHZhbHVlLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShieXRlTGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IG5vcm1hbGl6ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gV2hpbGUgd2UgY291bGQgc2ltcGx5IHNwcmVhZCB0aGUgdmFsdWVzIGludG8gYW4gYXJyYXkgYW5kIHVzZVxuICAgICAgICAvLyBgVWludDhBcnJheS5mcm9tYCwgdGhhdCBpcyBhIGxvdCBzbG93ZXIgdGhhbiB1c2luZyBgVWludDhBcnJheS5zZXRgLlxuICAgICAgICBieXRlcy5zZXQobm9ybWFsaXplZFZhbHVlc1tpXSwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IG5vcm1hbGl6ZWRWYWx1ZXNbaV0ubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5leHBvcnRzLmNvbmNhdEJ5dGVzID0gY29uY2F0Qnl0ZXM7XG4vKipcbiAqIENyZWF0ZSBhIHtAbGluayBEYXRhVmlld30gZnJvbSBhIHtAbGluayBVaW50OEFycmF5fS4gVGhpcyBpcyBhIGNvbnZlbmllbmNlXG4gKiBmdW5jdGlvbiB0aGF0IGF2b2lkcyBoYXZpbmcgdG8gY3JlYXRlIGEge0BsaW5rIERhdGFWaWV3fSBtYW51YWxseSwgd2hpY2hcbiAqIHJlcXVpcmVzIHBhc3NpbmcgdGhlIGBieXRlT2Zmc2V0YCBhbmQgYGJ5dGVMZW5ndGhgIHBhcmFtZXRlcnMgZXZlcnkgdGltZS5cbiAqXG4gKiBOb3QgcGFzc2luZyB0aGUgYGJ5dGVPZmZzZXRgIGFuZCBgYnl0ZUxlbmd0aGAgcGFyYW1ldGVycyBjYW4gcmVzdWx0IGluXG4gKiB1bmV4cGVjdGVkIGJlaGF2aW9yIHdoZW4gdGhlIHtAbGluayBVaW50OEFycmF5fSBpcyBhIHZpZXcgb2YgYSBsYXJnZXJcbiAqIHtAbGluayBBcnJheUJ1ZmZlcn0sIGUuZy4sIHdoZW4gdXNpbmcge0BsaW5rIFVpbnQ4QXJyYXkuc3ViYXJyYXl9LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYWxzbyBzdXBwb3J0cyBOb2RlLmpzIHtAbGluayBCdWZmZXJ9cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShbMSwgMiwgM10pO1xuICpcbiAqIC8vIFRoaXMgaXMgZXF1aXZhbGVudCB0bzpcbiAqIC8vIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ5dGVzLmJ1ZmZlciwgYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZUxlbmd0aCk7XG4gKiBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZURhdGFWaWV3KGJ5dGVzKTtcbiAqIGBgYFxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNyZWF0ZSB0aGUge0BsaW5rIERhdGFWaWV3fSBmcm9tLlxuICogQHJldHVybnMgVGhlIHtAbGluayBEYXRhVmlld30uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURhdGFWaWV3KGJ5dGVzKSB7XG4gICAgLy8gVG8gbWFpbnRhaW4gY29tcGF0aWJpbGl0eSB3aXRoIE5vZGUuanMsIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIGJ5dGVzIGFyZVxuICAgIC8vIGEgQnVmZmVyLiBJZiBzbywgd2UgbmVlZCB0byBzbGljZSB0aGUgYnVmZmVyIHRvIGdldCB0aGUgdW5kZXJseWluZ1xuICAgIC8vIEFycmF5QnVmZmVyLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgYnl0ZXMgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gYnl0ZXMuYnVmZmVyLnNsaWNlKGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVPZmZzZXQgKyBieXRlcy5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGFWaWV3KGJ5dGVzLmJ1ZmZlciwgYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZUxlbmd0aCk7XG59XG5leHBvcnRzLmNyZWF0ZURhdGFWaWV3ID0gY3JlYXRlRGF0YVZpZXc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjcmVhdGVEYXRhVmlldyIsImNvbmNhdEJ5dGVzIiwidmFsdWVUb0J5dGVzIiwic3RyaW5nVG9CeXRlcyIsIm51bWJlclRvQnl0ZXMiLCJzaWduZWRCaWdJbnRUb0J5dGVzIiwiYmlnSW50VG9CeXRlcyIsImhleFRvQnl0ZXMiLCJieXRlc1RvU3RyaW5nIiwiYnl0ZXNUb051bWJlciIsImJ5dGVzVG9TaWduZWRCaWdJbnQiLCJieXRlc1RvQmlnSW50IiwiYnl0ZXNUb0hleCIsImFzc2VydElzQnl0ZXMiLCJpc0J5dGVzIiwiYXNzZXJ0XzEiLCJyZXF1aXJlIiwiaGV4XzEiLCJIRVhfTUlOSU1VTV9OVU1CRVJfQ0hBUkFDVEVSIiwiSEVYX01BWElNVU1fTlVNQkVSX0NIQVJBQ1RFUiIsIkhFWF9DSEFSQUNURVJfT0ZGU0VUIiwiZ2V0UHJlY29tcHV0ZWRIZXhWYWx1ZXNCdWlsZGVyIiwibG9va3VwVGFibGUiLCJsZW5ndGgiLCJpIiwicHVzaCIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJnZXRQcmVjb21wdXRlZEhleFZhbHVlcyIsIlVpbnQ4QXJyYXkiLCJhc3NlcnQiLCJieXRlcyIsImhleGFkZWNpbWFsIiwiQXJyYXkiLCJhZGQweCIsImpvaW4iLCJCaWdJbnQiLCJieXRlIiwiYXNJbnROIiwiYmlnaW50IiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsIlRleHREZWNvZGVyIiwiZGVjb2RlIiwiX2EiLCJ0b0xvd2VyQ2FzZSIsImNhbGwiLCJhc3NlcnRJc0hleFN0cmluZyIsInN0cmlwcGVkVmFsdWUiLCJyZW1vdmUweCIsIm5vcm1hbGl6ZWRWYWx1ZSIsImMxIiwiY2hhckNvZGVBdCIsImMyIiwibjEiLCJuMiIsImJpZ0ludEZpdHMiLCJtYXNrIiwiYnl0ZUxlbmd0aCIsIm51bWJlclZhbHVlIiwiYXNVaW50TiIsInJldmVyc2UiLCJpc1NhZmVJbnRlZ2VyIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJzdGFydHNXaXRoIiwiVHlwZUVycm9yIiwidmFsdWVzIiwibm9ybWFsaXplZFZhbHVlcyIsIm9mZnNldCIsInNldCIsIkJ1ZmZlciIsImJ1ZmZlciIsInNsaWNlIiwiYnl0ZU9mZnNldCIsIkRhdGFWaWV3Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/checksum.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/checksum.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ChecksumStruct = void 0;\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\nconst base64_1 = __webpack_require__(/*! ./base64 */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/base64.js\");\nexports.ChecksumStruct = (0, superstruct_1.size)((0, base64_1.base64)((0, superstruct_1.string)(), {\n    paddingRequired: true\n}), 44, 44); //# sourceMappingURL=checksum.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NoZWNrc3VtLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxzQkFBc0IsR0FBRyxLQUFLO0FBQzlCLE1BQU1HLGdCQUFnQkMsbUJBQU9BLENBQUMsb0VBQWE7QUFDM0MsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsb0dBQVU7QUFDbkNKLHNCQUFzQixHQUFHLENBQUMsR0FBR0csY0FBY0csSUFBSSxFQUFFLENBQUMsR0FBR0QsU0FBU0UsTUFBTSxFQUFFLENBQUMsR0FBR0osY0FBY0ssTUFBTSxLQUFLO0lBQUVDLGlCQUFpQjtBQUFLLElBQUksSUFBSSxLQUNuSSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aXRoLW5leHQtYXBwLy4vbm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9jaGVja3N1bS5qcz9kODliIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaGVja3N1bVN0cnVjdCA9IHZvaWQgMDtcbmNvbnN0IHN1cGVyc3RydWN0XzEgPSByZXF1aXJlKFwic3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBiYXNlNjRfMSA9IHJlcXVpcmUoXCIuL2Jhc2U2NFwiKTtcbmV4cG9ydHMuQ2hlY2tzdW1TdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5zaXplKSgoMCwgYmFzZTY0XzEuYmFzZTY0KSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIHsgcGFkZGluZ1JlcXVpcmVkOiB0cnVlIH0pLCA0NCwgNDQpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tzdW0uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ2hlY2tzdW1TdHJ1Y3QiLCJzdXBlcnN0cnVjdF8xIiwicmVxdWlyZSIsImJhc2U2NF8xIiwic2l6ZSIsImJhc2U2NCIsInN0cmluZyIsInBhZGRpbmdSZXF1aXJlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/checksum.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/coercers.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/coercers.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createHex = exports.createBytes = exports.createBigInt = exports.createNumber = void 0;\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/bytes.js\");\nconst hex_1 = __webpack_require__(/*! ./hex */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/hex.js\");\nconst NumberLikeStruct = (0, superstruct_1.union)([\n    (0, superstruct_1.number)(),\n    (0, superstruct_1.bigint)(),\n    (0, superstruct_1.string)(),\n    hex_1.StrictHexStruct\n]);\nconst NumberCoercer = (0, superstruct_1.coerce)((0, superstruct_1.number)(), NumberLikeStruct, Number);\nconst BigIntCoercer = (0, superstruct_1.coerce)((0, superstruct_1.bigint)(), NumberLikeStruct, BigInt);\nconst BytesLikeStruct = (0, superstruct_1.union)([\n    hex_1.StrictHexStruct,\n    (0, superstruct_1.instance)(Uint8Array)\n]);\nconst BytesCoercer = (0, superstruct_1.coerce)((0, superstruct_1.instance)(Uint8Array), (0, superstruct_1.union)([\n    hex_1.StrictHexStruct\n]), bytes_1.hexToBytes);\nconst HexCoercer = (0, superstruct_1.coerce)(hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array), bytes_1.bytesToHex);\n/**\n * Create a number from a number-like value.\n *\n * - If the value is a number, it is returned as-is.\n * - If the value is a `bigint`, it is converted to a number.\n * - If the value is a string, it is interpreted as a decimal number.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is\n * interpreted as a hexadecimal number.\n *\n * This validates that the value is a number-like value, and that the resulting\n * number is not `NaN` or `Infinity`.\n *\n * @example\n * ```typescript\n * const value = createNumber('0x010203');\n * console.log(value); // 66051\n *\n * const otherValue = createNumber(123n);\n * console.log(otherValue); // 123\n * ```\n * @param value - The value to create the number from.\n * @returns The created number.\n * @throws If the value is not a number-like value, or if the resulting number\n * is `NaN` or `Infinity`.\n */ function createNumber(value) {\n    try {\n        const result = (0, superstruct_1.create)(value, NumberCoercer);\n        (0, assert_1.assert)(Number.isFinite(result), `Expected a number-like value, got \"${value}\".`);\n        return result;\n    } catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a number-like value, got \"${value}\".`);\n        }\n        /* istanbul ignore next */ throw error;\n    }\n}\nexports.createNumber = createNumber;\n/**\n * Create a `bigint` from a number-like value.\n *\n * - If the value is a number, it is converted to a `bigint`.\n * - If the value is a `bigint`, it is returned as-is.\n * - If the value is a string, it is interpreted as a decimal number and\n * converted to a `bigint`.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is\n * interpreted as a hexadecimal number and converted to a `bigint`.\n *\n * @example\n * ```typescript\n * const value = createBigInt('0x010203');\n * console.log(value); // 16909060n\n *\n * const otherValue = createBigInt(123);\n * console.log(otherValue); // 123n\n * ```\n * @param value - The value to create the bigint from.\n * @returns The created bigint.\n * @throws If the value is not a number-like value.\n */ function createBigInt(value) {\n    try {\n        // The `BigInt` constructor throws if the value is not a number-like value.\n        // There is no need to validate the value manually.\n        return (0, superstruct_1.create)(value, BigIntCoercer);\n    } catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a number-like value, got \"${String(error.value)}\".`);\n        }\n        /* istanbul ignore next */ throw error;\n    }\n}\nexports.createBigInt = createBigInt;\n/**\n * Create a byte array from a bytes-like value.\n *\n * - If the value is a byte array, it is returned as-is.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is interpreted\n * as a hexadecimal number and converted to a byte array.\n *\n * @example\n * ```typescript\n * const value = createBytes('0x010203');\n * console.log(value); // Uint8Array [ 1, 2, 3 ]\n *\n * const otherValue = createBytes('0x010203');\n * console.log(otherValue); // Uint8Array [ 1, 2, 3 ]\n * ```\n * @param value - The value to create the byte array from.\n * @returns The created byte array.\n * @throws If the value is not a bytes-like value.\n */ function createBytes(value) {\n    if (typeof value === \"string\" && value.toLowerCase() === \"0x\") {\n        return new Uint8Array();\n    }\n    try {\n        return (0, superstruct_1.create)(value, BytesCoercer);\n    } catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a bytes-like value, got \"${String(error.value)}\".`);\n        }\n        /* istanbul ignore next */ throw error;\n    }\n}\nexports.createBytes = createBytes;\n/**\n * Create a hexadecimal string from a bytes-like value.\n *\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is returned\n * as-is.\n * - If the value is a `Uint8Array`, it is converted to a hex string.\n *\n * @example\n * ```typescript\n * const value = createHex(new Uint8Array([1, 2, 3]));\n * console.log(value); // '0x010203'\n *\n * const otherValue = createHex('0x010203');\n * console.log(otherValue); // '0x010203'\n * ```\n * @param value - The value to create the hex string from.\n * @returns The created hex string.\n * @throws If the value is not a bytes-like value.\n */ function createHex(value) {\n    if (value instanceof Uint8Array && value.length === 0 || typeof value === \"string\" && value.toLowerCase() === \"0x\") {\n        return \"0x\";\n    }\n    try {\n        return (0, superstruct_1.create)(value, HexCoercer);\n    } catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a bytes-like value, got \"${String(error.value)}\".`);\n        }\n        /* istanbul ignore next */ throw error;\n    }\n}\nexports.createHex = createHex; //# sourceMappingURL=coercers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NvZXJjZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBR0EsbUJBQW1CLEdBQUdBLG9CQUFvQixHQUFHQSxvQkFBb0IsR0FBRyxLQUFLO0FBQzdGLE1BQU1NLGdCQUFnQkMsbUJBQU9BLENBQUMsb0VBQWE7QUFDM0MsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsb0dBQVU7QUFDbkMsTUFBTUUsVUFBVUYsbUJBQU9BLENBQUMsa0dBQVM7QUFDakMsTUFBTUcsUUFBUUgsbUJBQU9BLENBQUMsOEZBQU87QUFDN0IsTUFBTUksbUJBQW1CLENBQUMsR0FBR0wsY0FBY00sS0FBSyxFQUFFO0lBQUUsSUFBR04sY0FBY08sTUFBTTtJQUFNLElBQUdQLGNBQWNRLE1BQU07SUFBTSxJQUFHUixjQUFjUyxNQUFNO0lBQUtMLE1BQU1NLGVBQWU7Q0FBQztBQUNoSyxNQUFNQyxnQkFBZ0IsQ0FBQyxHQUFHWCxjQUFjWSxNQUFNLEVBQUUsQ0FBQyxHQUFHWixjQUFjTyxNQUFNLEtBQUtGLGtCQUFrQlE7QUFDL0YsTUFBTUMsZ0JBQWdCLENBQUMsR0FBR2QsY0FBY1ksTUFBTSxFQUFFLENBQUMsR0FBR1osY0FBY1EsTUFBTSxLQUFLSCxrQkFBa0JVO0FBQy9GLE1BQU1DLGtCQUFrQixDQUFDLEdBQUdoQixjQUFjTSxLQUFLLEVBQUU7SUFBQ0YsTUFBTU0sZUFBZTtJQUFHLElBQUdWLGNBQWNpQixRQUFRLEVBQUVDO0NBQVk7QUFDakgsTUFBTUMsZUFBZSxDQUFDLEdBQUduQixjQUFjWSxNQUFNLEVBQUUsQ0FBQyxHQUFHWixjQUFjaUIsUUFBUSxFQUFFQyxhQUFhLENBQUMsR0FBR2xCLGNBQWNNLEtBQUssRUFBRTtJQUFDRixNQUFNTSxlQUFlO0NBQUMsR0FBR1AsUUFBUWlCLFVBQVU7QUFDN0osTUFBTUMsYUFBYSxDQUFDLEdBQUdyQixjQUFjWSxNQUFNLEVBQUVSLE1BQU1NLGVBQWUsRUFBRSxDQUFDLEdBQUdWLGNBQWNpQixRQUFRLEVBQUVDLGFBQWFmLFFBQVFtQixVQUFVO0FBQy9IOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F3QkMsR0FDRCxTQUFTdkIsYUFBYUosS0FBSztJQUN2QixJQUFJO1FBQ0EsTUFBTTRCLFNBQVMsQ0FBQyxHQUFHdkIsY0FBY3dCLE1BQU0sRUFBRTdCLE9BQU9nQjtRQUMvQyxJQUFHVCxTQUFTdUIsTUFBTSxFQUFFWixPQUFPYSxRQUFRLENBQUNILFNBQVMsQ0FBQyxtQ0FBbUMsRUFBRTVCLE1BQU0sRUFBRSxDQUFDO1FBQzdGLE9BQU80QjtJQUNYLEVBQ0EsT0FBT0ksT0FBTztRQUNWLElBQUlBLGlCQUFpQjNCLGNBQWM0QixXQUFXLEVBQUU7WUFDNUMsTUFBTSxJQUFJQyxNQUFNLENBQUMsbUNBQW1DLEVBQUVsQyxNQUFNLEVBQUUsQ0FBQztRQUNuRTtRQUNBLHdCQUF3QixHQUN4QixNQUFNZ0M7SUFDVjtBQUNKO0FBQ0FqQyxvQkFBb0IsR0FBR0s7QUFDdkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFCQyxHQUNELFNBQVNELGFBQWFILEtBQUs7SUFDdkIsSUFBSTtRQUNBLDJFQUEyRTtRQUMzRSxtREFBbUQ7UUFDbkQsT0FBTyxDQUFDLEdBQUdLLGNBQWN3QixNQUFNLEVBQUU3QixPQUFPbUI7SUFDNUMsRUFDQSxPQUFPYSxPQUFPO1FBQ1YsSUFBSUEsaUJBQWlCM0IsY0FBYzRCLFdBQVcsRUFBRTtZQUM1QyxNQUFNLElBQUlDLE1BQU0sQ0FBQyxtQ0FBbUMsRUFBRUMsT0FBT0gsTUFBTWhDLEtBQUssRUFBRSxFQUFFLENBQUM7UUFDakY7UUFDQSx3QkFBd0IsR0FDeEIsTUFBTWdDO0lBQ1Y7QUFDSjtBQUNBakMsb0JBQW9CLEdBQUdJO0FBQ3ZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FDRCxTQUFTRCxZQUFZRixLQUFLO0lBQ3RCLElBQUksT0FBT0EsVUFBVSxZQUFZQSxNQUFNb0MsV0FBVyxPQUFPLE1BQU07UUFDM0QsT0FBTyxJQUFJYjtJQUNmO0lBQ0EsSUFBSTtRQUNBLE9BQU8sQ0FBQyxHQUFHbEIsY0FBY3dCLE1BQU0sRUFBRTdCLE9BQU93QjtJQUM1QyxFQUNBLE9BQU9RLE9BQU87UUFDVixJQUFJQSxpQkFBaUIzQixjQUFjNEIsV0FBVyxFQUFFO1lBQzVDLE1BQU0sSUFBSUMsTUFBTSxDQUFDLGtDQUFrQyxFQUFFQyxPQUFPSCxNQUFNaEMsS0FBSyxFQUFFLEVBQUUsQ0FBQztRQUNoRjtRQUNBLHdCQUF3QixHQUN4QixNQUFNZ0M7SUFDVjtBQUNKO0FBQ0FqQyxtQkFBbUIsR0FBR0c7QUFDdEI7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNELFNBQVNELFVBQVVELEtBQUs7SUFDcEIsSUFBSSxpQkFBa0J1QixjQUFjdkIsTUFBTXFDLE1BQU0sS0FBSyxLQUNoRCxPQUFPckMsVUFBVSxZQUFZQSxNQUFNb0MsV0FBVyxPQUFPLE1BQU87UUFDN0QsT0FBTztJQUNYO0lBQ0EsSUFBSTtRQUNBLE9BQU8sQ0FBQyxHQUFHL0IsY0FBY3dCLE1BQU0sRUFBRTdCLE9BQU8wQjtJQUM1QyxFQUNBLE9BQU9NLE9BQU87UUFDVixJQUFJQSxpQkFBaUIzQixjQUFjNEIsV0FBVyxFQUFFO1lBQzVDLE1BQU0sSUFBSUMsTUFBTSxDQUFDLGtDQUFrQyxFQUFFQyxPQUFPSCxNQUFNaEMsS0FBSyxFQUFFLEVBQUUsQ0FBQztRQUNoRjtRQUNBLHdCQUF3QixHQUN4QixNQUFNZ0M7SUFDVjtBQUNKO0FBQ0FqQyxpQkFBaUIsR0FBR0UsV0FDcEIsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2l0aC1uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY29lcmNlcnMuanM/MTVmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlSGV4ID0gZXhwb3J0cy5jcmVhdGVCeXRlcyA9IGV4cG9ydHMuY3JlYXRlQmlnSW50ID0gZXhwb3J0cy5jcmVhdGVOdW1iZXIgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG5jb25zdCBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG5jb25zdCBoZXhfMSA9IHJlcXVpcmUoXCIuL2hleFwiKTtcbmNvbnN0IE51bWJlckxpa2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoWygwLCBzdXBlcnN0cnVjdF8xLm51bWJlcikoKSwgKDAsIHN1cGVyc3RydWN0XzEuYmlnaW50KSgpLCAoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIGhleF8xLlN0cmljdEhleFN0cnVjdF0pO1xuY29uc3QgTnVtYmVyQ29lcmNlciA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoKDAsIHN1cGVyc3RydWN0XzEubnVtYmVyKSgpLCBOdW1iZXJMaWtlU3RydWN0LCBOdW1iZXIpO1xuY29uc3QgQmlnSW50Q29lcmNlciA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoKDAsIHN1cGVyc3RydWN0XzEuYmlnaW50KSgpLCBOdW1iZXJMaWtlU3RydWN0LCBCaWdJbnQpO1xuY29uc3QgQnl0ZXNMaWtlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFtoZXhfMS5TdHJpY3RIZXhTdHJ1Y3QsICgwLCBzdXBlcnN0cnVjdF8xLmluc3RhbmNlKShVaW50OEFycmF5KV0pO1xuY29uc3QgQnl0ZXNDb2VyY2VyID0gKDAsIHN1cGVyc3RydWN0XzEuY29lcmNlKSgoMCwgc3VwZXJzdHJ1Y3RfMS5pbnN0YW5jZSkoVWludDhBcnJheSksICgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbaGV4XzEuU3RyaWN0SGV4U3RydWN0XSksIGJ5dGVzXzEuaGV4VG9CeXRlcyk7XG5jb25zdCBIZXhDb2VyY2VyID0gKDAsIHN1cGVyc3RydWN0XzEuY29lcmNlKShoZXhfMS5TdHJpY3RIZXhTdHJ1Y3QsICgwLCBzdXBlcnN0cnVjdF8xLmluc3RhbmNlKShVaW50OEFycmF5KSwgYnl0ZXNfMS5ieXRlc1RvSGV4KTtcbi8qKlxuICogQ3JlYXRlIGEgbnVtYmVyIGZyb20gYSBudW1iZXItbGlrZSB2YWx1ZS5cbiAqXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIG51bWJlciwgaXQgaXMgcmV0dXJuZWQgYXMtaXMuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGBiaWdpbnRgLCBpdCBpcyBjb252ZXJ0ZWQgdG8gYSBudW1iZXIuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgaXQgaXMgaW50ZXJwcmV0ZWQgYXMgYSBkZWNpbWFsIG51bWJlci5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgaGV4IHN0cmluZyAoaS5lLiwgaXQgc3RhcnRzIHdpdGggXCIweFwiKSwgaXQgaXNcbiAqIGludGVycHJldGVkIGFzIGEgaGV4YWRlY2ltYWwgbnVtYmVyLlxuICpcbiAqIFRoaXMgdmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGlzIGEgbnVtYmVyLWxpa2UgdmFsdWUsIGFuZCB0aGF0IHRoZSByZXN1bHRpbmdcbiAqIG51bWJlciBpcyBub3QgYE5hTmAgb3IgYEluZmluaXR5YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgdmFsdWUgPSBjcmVhdGVOdW1iZXIoJzB4MDEwMjAzJyk7XG4gKiBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vIDY2MDUxXG4gKlxuICogY29uc3Qgb3RoZXJWYWx1ZSA9IGNyZWF0ZU51bWJlcigxMjNuKTtcbiAqIGNvbnNvbGUubG9nKG90aGVyVmFsdWUpOyAvLyAxMjNcbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNyZWF0ZSB0aGUgbnVtYmVyIGZyb20uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBudW1iZXIuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBudW1iZXItbGlrZSB2YWx1ZSwgb3IgaWYgdGhlIHJlc3VsdGluZyBudW1iZXJcbiAqIGlzIGBOYU5gIG9yIGBJbmZpbml0eWAuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU51bWJlcih2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICgwLCBzdXBlcnN0cnVjdF8xLmNyZWF0ZSkodmFsdWUsIE51bWJlckNvZXJjZXIpO1xuICAgICAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShOdW1iZXIuaXNGaW5pdGUocmVzdWx0KSwgYEV4cGVjdGVkIGEgbnVtYmVyLWxpa2UgdmFsdWUsIGdvdCBcIiR7dmFsdWV9XCIuYCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBzdXBlcnN0cnVjdF8xLlN0cnVjdEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgbnVtYmVyLWxpa2UgdmFsdWUsIGdvdCBcIiR7dmFsdWV9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVOdW1iZXIgPSBjcmVhdGVOdW1iZXI7XG4vKipcbiAqIENyZWF0ZSBhIGBiaWdpbnRgIGZyb20gYSBudW1iZXItbGlrZSB2YWx1ZS5cbiAqXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIG51bWJlciwgaXQgaXMgY29udmVydGVkIHRvIGEgYGJpZ2ludGAuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGBiaWdpbnRgLCBpdCBpcyByZXR1cm5lZCBhcy1pcy5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nLCBpdCBpcyBpbnRlcnByZXRlZCBhcyBhIGRlY2ltYWwgbnVtYmVyIGFuZFxuICogY29udmVydGVkIHRvIGEgYGJpZ2ludGAuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGhleCBzdHJpbmcgKGkuZS4sIGl0IHN0YXJ0cyB3aXRoIFwiMHhcIiksIGl0IGlzXG4gKiBpbnRlcnByZXRlZCBhcyBhIGhleGFkZWNpbWFsIG51bWJlciBhbmQgY29udmVydGVkIHRvIGEgYGJpZ2ludGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHZhbHVlID0gY3JlYXRlQmlnSW50KCcweDAxMDIwMycpO1xuICogY29uc29sZS5sb2codmFsdWUpOyAvLyAxNjkwOTA2MG5cbiAqXG4gKiBjb25zdCBvdGhlclZhbHVlID0gY3JlYXRlQmlnSW50KDEyMyk7XG4gKiBjb25zb2xlLmxvZyhvdGhlclZhbHVlKTsgLy8gMTIzblxuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY3JlYXRlIHRoZSBiaWdpbnQgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGJpZ2ludC5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIG51bWJlci1saWtlIHZhbHVlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCaWdJbnQodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBUaGUgYEJpZ0ludGAgY29uc3RydWN0b3IgdGhyb3dzIGlmIHRoZSB2YWx1ZSBpcyBub3QgYSBudW1iZXItbGlrZSB2YWx1ZS5cbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmVlZCB0byB2YWxpZGF0ZSB0aGUgdmFsdWUgbWFudWFsbHkuXG4gICAgICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5jcmVhdGUpKHZhbHVlLCBCaWdJbnRDb2VyY2VyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHN1cGVyc3RydWN0XzEuU3RydWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBudW1iZXItbGlrZSB2YWx1ZSwgZ290IFwiJHtTdHJpbmcoZXJyb3IudmFsdWUpfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlQmlnSW50ID0gY3JlYXRlQmlnSW50O1xuLyoqXG4gKiBDcmVhdGUgYSBieXRlIGFycmF5IGZyb20gYSBieXRlcy1saWtlIHZhbHVlLlxuICpcbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgYnl0ZSBhcnJheSwgaXQgaXMgcmV0dXJuZWQgYXMtaXMuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGhleCBzdHJpbmcgKGkuZS4sIGl0IHN0YXJ0cyB3aXRoIFwiMHhcIiksIGl0IGlzIGludGVycHJldGVkXG4gKiBhcyBhIGhleGFkZWNpbWFsIG51bWJlciBhbmQgY29udmVydGVkIHRvIGEgYnl0ZSBhcnJheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgdmFsdWUgPSBjcmVhdGVCeXRlcygnMHgwMTAyMDMnKTtcbiAqIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gVWludDhBcnJheSBbIDEsIDIsIDMgXVxuICpcbiAqIGNvbnN0IG90aGVyVmFsdWUgPSBjcmVhdGVCeXRlcygnMHgwMTAyMDMnKTtcbiAqIGNvbnNvbGUubG9nKG90aGVyVmFsdWUpOyAvLyBVaW50OEFycmF5IFsgMSwgMiwgMyBdXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjcmVhdGUgdGhlIGJ5dGUgYXJyYXkgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGJ5dGUgYXJyYXkuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBieXRlcy1saWtlIHZhbHVlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCeXRlcyh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICcweCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5jcmVhdGUpKHZhbHVlLCBCeXRlc0NvZXJjZXIpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2Ygc3VwZXJzdHJ1Y3RfMS5TdHJ1Y3RFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIGJ5dGVzLWxpa2UgdmFsdWUsIGdvdCBcIiR7U3RyaW5nKGVycm9yLnZhbHVlKX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZUJ5dGVzID0gY3JlYXRlQnl0ZXM7XG4vKipcbiAqIENyZWF0ZSBhIGhleGFkZWNpbWFsIHN0cmluZyBmcm9tIGEgYnl0ZXMtbGlrZSB2YWx1ZS5cbiAqXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGhleCBzdHJpbmcgKGkuZS4sIGl0IHN0YXJ0cyB3aXRoIFwiMHhcIiksIGl0IGlzIHJldHVybmVkXG4gKiBhcy1pcy5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLCBpdCBpcyBjb252ZXJ0ZWQgdG8gYSBoZXggc3RyaW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCB2YWx1ZSA9IGNyZWF0ZUhleChuZXcgVWludDhBcnJheShbMSwgMiwgM10pKTtcbiAqIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gJzB4MDEwMjAzJ1xuICpcbiAqIGNvbnN0IG90aGVyVmFsdWUgPSBjcmVhdGVIZXgoJzB4MDEwMjAzJyk7XG4gKiBjb25zb2xlLmxvZyhvdGhlclZhbHVlKTsgLy8gJzB4MDEwMjAzJ1xuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY3JlYXRlIHRoZSBoZXggc3RyaW5nIGZyb20uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBoZXggc3RyaW5nLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgYnl0ZXMtbGlrZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSGV4KHZhbHVlKSB7XG4gICAgaWYgKCh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSB8fFxuICAgICAgICAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnMHgnKSkge1xuICAgICAgICByZXR1cm4gJzB4JztcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmNyZWF0ZSkodmFsdWUsIEhleENvZXJjZXIpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2Ygc3VwZXJzdHJ1Y3RfMS5TdHJ1Y3RFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIGJ5dGVzLWxpa2UgdmFsdWUsIGdvdCBcIiR7U3RyaW5nKGVycm9yLnZhbHVlKX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZUhleCA9IGNyZWF0ZUhleDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZXJjZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNyZWF0ZUhleCIsImNyZWF0ZUJ5dGVzIiwiY3JlYXRlQmlnSW50IiwiY3JlYXRlTnVtYmVyIiwic3VwZXJzdHJ1Y3RfMSIsInJlcXVpcmUiLCJhc3NlcnRfMSIsImJ5dGVzXzEiLCJoZXhfMSIsIk51bWJlckxpa2VTdHJ1Y3QiLCJ1bmlvbiIsIm51bWJlciIsImJpZ2ludCIsInN0cmluZyIsIlN0cmljdEhleFN0cnVjdCIsIk51bWJlckNvZXJjZXIiLCJjb2VyY2UiLCJOdW1iZXIiLCJCaWdJbnRDb2VyY2VyIiwiQmlnSW50IiwiQnl0ZXNMaWtlU3RydWN0IiwiaW5zdGFuY2UiLCJVaW50OEFycmF5IiwiQnl0ZXNDb2VyY2VyIiwiaGV4VG9CeXRlcyIsIkhleENvZXJjZXIiLCJieXRlc1RvSGV4IiwicmVzdWx0IiwiY3JlYXRlIiwiYXNzZXJ0IiwiaXNGaW5pdGUiLCJlcnJvciIsIlN0cnVjdEVycm9yIiwiRXJyb3IiLCJTdHJpbmciLCJ0b0xvd2VyQ2FzZSIsImxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/coercers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/collections.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/collections.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nvar __classPrivateFieldSet = (void 0) && (void 0).__classPrivateFieldSet || function(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = (void 0) && (void 0).__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _FrozenMap_map, _FrozenSet_set;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FrozenSet = exports.FrozenMap = void 0;\n/**\n * A {@link ReadonlyMap} that cannot be modified after instantiation.\n * The implementation uses an inner map hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this map.\n */ class FrozenMap {\n    constructor(entries){\n        _FrozenMap_map.set(this, void 0);\n        __classPrivateFieldSet(this, _FrozenMap_map, new Map(entries), \"f\");\n        Object.freeze(this);\n    }\n    get size() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").size;\n    }\n    [(_FrozenMap_map = new WeakMap(), Symbol.iterator)]() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\")[Symbol.iterator]();\n    }\n    entries() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").entries();\n    }\n    forEach(callbackfn, thisArg) {\n        // We have to wrap the specified callback in order to prevent it from\n        // receiving a reference to the inner map.\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").forEach((value, key, _map)=>callbackfn.call(thisArg, value, key, this));\n    }\n    get(key) {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").get(key);\n    }\n    has(key) {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").has(key);\n    }\n    keys() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").keys();\n    }\n    values() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").values();\n    }\n    toString() {\n        return `FrozenMap(${this.size}) {${this.size > 0 ? ` ${[\n            ...this.entries()\n        ].map(([key, value])=>`${String(key)} => ${String(value)}`).join(\", \")} ` : \"\"}}`;\n    }\n}\nexports.FrozenMap = FrozenMap;\n/**\n * A {@link ReadonlySet} that cannot be modified after instantiation.\n * The implementation uses an inner set hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this set.\n */ class FrozenSet {\n    constructor(values){\n        _FrozenSet_set.set(this, void 0);\n        __classPrivateFieldSet(this, _FrozenSet_set, new Set(values), \"f\");\n        Object.freeze(this);\n    }\n    get size() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").size;\n    }\n    [(_FrozenSet_set = new WeakMap(), Symbol.iterator)]() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\")[Symbol.iterator]();\n    }\n    entries() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").entries();\n    }\n    forEach(callbackfn, thisArg) {\n        // We have to wrap the specified callback in order to prevent it from\n        // receiving a reference to the inner set.\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").forEach((value, value2, _set)=>callbackfn.call(thisArg, value, value2, this));\n    }\n    has(value) {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").has(value);\n    }\n    keys() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").keys();\n    }\n    values() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").values();\n    }\n    toString() {\n        return `FrozenSet(${this.size}) {${this.size > 0 ? ` ${[\n            ...this.values()\n        ].map((member)=>String(member)).join(\", \")} ` : \"\"}}`;\n    }\n}\nexports.FrozenSet = FrozenSet;\nObject.freeze(FrozenMap);\nObject.freeze(FrozenMap.prototype);\nObject.freeze(FrozenSet);\nObject.freeze(FrozenSet.prototype); //# sourceMappingURL=collections.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NvbGxlY3Rpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEseUJBQXlCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsc0JBQXNCLElBQUssU0FBVUMsUUFBUSxFQUFFQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxDQUFDO0lBQzNHLElBQUlELFNBQVMsS0FBSyxNQUFNLElBQUlFLFVBQVU7SUFDdEMsSUFBSUYsU0FBUyxPQUFPLENBQUNDLEdBQUcsTUFBTSxJQUFJQyxVQUFVO0lBQzVDLElBQUksT0FBT0osVUFBVSxhQUFhRCxhQUFhQyxTQUFTLENBQUNHLElBQUksQ0FBQ0gsTUFBTUssR0FBRyxDQUFDTixXQUFXLE1BQU0sSUFBSUssVUFBVTtJQUN2RyxPQUFPLFNBQVUsTUFBTUQsRUFBRUcsSUFBSSxDQUFDUCxVQUFVRSxTQUFTRSxJQUFJQSxFQUFFRixLQUFLLEdBQUdBLFFBQVFELE1BQU1PLEdBQUcsQ0FBQ1IsVUFBVUUsUUFBU0E7QUFDeEc7QUFDQSxJQUFJTyx5QkFBeUIsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxzQkFBc0IsSUFBSyxTQUFVVCxRQUFRLEVBQUVDLEtBQUssRUFBRUUsSUFBSSxFQUFFQyxDQUFDO0lBQ3BHLElBQUlELFNBQVMsT0FBTyxDQUFDQyxHQUFHLE1BQU0sSUFBSUMsVUFBVTtJQUM1QyxJQUFJLE9BQU9KLFVBQVUsYUFBYUQsYUFBYUMsU0FBUyxDQUFDRyxJQUFJLENBQUNILE1BQU1LLEdBQUcsQ0FBQ04sV0FBVyxNQUFNLElBQUlLLFVBQVU7SUFDdkcsT0FBT0YsU0FBUyxNQUFNQyxJQUFJRCxTQUFTLE1BQU1DLEVBQUVHLElBQUksQ0FBQ1AsWUFBWUksSUFBSUEsRUFBRUYsS0FBSyxHQUFHRCxNQUFNUyxHQUFHLENBQUNWO0FBQ3hGO0FBQ0EsSUFBSVcsZ0JB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RSwwQ0FBMEM7UUFDMUMsT0FBT25CLHVCQUF1QixJQUFJLEVBQUVHLGdCQUFnQixLQUFLYyxPQUFPLENBQUMsQ0FBQ3hCLE9BQU9vQyxRQUFRQyxPQUFTWixXQUFXcEIsSUFBSSxDQUFDcUIsU0FBUzFCLE9BQU9vQyxRQUFRLElBQUk7SUFDMUk7SUFDQWhDLElBQUlKLEtBQUssRUFBRTtRQUNQLE9BQU9PLHVCQUF1QixJQUFJLEVBQUVHLGdCQUFnQixLQUFLTixHQUFHLENBQUNKO0lBQ2pFO0lBQ0E2QixPQUFPO1FBQ0gsT0FBT3RCLHVCQUF1QixJQUFJLEVBQUVHLGdCQUFnQixLQUFLbUIsSUFBSTtJQUNqRTtJQUNBQyxTQUFTO1FBQ0wsT0FBT3ZCLHVCQUF1QixJQUFJLEVBQUVHLGdCQUFnQixLQUFLb0IsTUFBTTtJQUNuRTtJQUNBQyxXQUFXO1FBQ1AsT0FBTyxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUNYLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDQSxJQUFJLEdBQUcsSUFDekMsQ0FBQyxDQUFDLEVBQUU7ZUFBSSxJQUFJLENBQUNVLE1BQU07U0FBRyxDQUFDRSxHQUFHLENBQUMsQ0FBQ00sU0FBV0wsT0FBT0ssU0FBU0osSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQ3BFLEdBQUcsQ0FBQyxDQUFDO0lBQ2Y7QUFDSjtBQUNBckIsaUJBQWlCLEdBQUdDO0FBQ3BCSCxPQUFPUSxNQUFNLENBQUNKO0FBQ2RKLE9BQU9RLE1BQU0sQ0FBQ0osVUFBVXdCLFNBQVM7QUFDakM1QixPQUFPUSxNQUFNLENBQUNMO0FBQ2RILE9BQU9RLE1BQU0sQ0FBQ0wsVUFBVXlCLFNBQVMsR0FDakMsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2l0aC1uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY29sbGVjdGlvbnMuanM/OTdkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfRnJvemVuTWFwX21hcCwgX0Zyb3plblNldF9zZXQ7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZyb3plblNldCA9IGV4cG9ydHMuRnJvemVuTWFwID0gdm9pZCAwO1xuLyoqXG4gKiBBIHtAbGluayBSZWFkb25seU1hcH0gdGhhdCBjYW5ub3QgYmUgbW9kaWZpZWQgYWZ0ZXIgaW5zdGFudGlhdGlvbi5cbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiB1c2VzIGFuIGlubmVyIG1hcCBoaWRkZW4gdmlhIGEgcHJpdmF0ZSBmaWVsZCwgYW5kIHRoZVxuICogaW1tdXRhYmlsaXR5IGd1YXJhbnRlZSByZWxpZXMgb24gaXQgYmVpbmcgaW1wb3NzaWJsZSB0byBnZXQgYSByZWZlcmVuY2VcbiAqIHRvIHRoaXMgbWFwLlxuICovXG5jbGFzcyBGcm96ZW5NYXAge1xuICAgIGNvbnN0cnVjdG9yKGVudHJpZXMpIHtcbiAgICAgICAgX0Zyb3plbk1hcF9tYXAuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIG5ldyBNYXAoZW50cmllcyksIFwiZlwiKTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuc2l6ZTtcbiAgICB9XG4gICAgWyhfRnJvemVuTWFwX21hcCA9IG5ldyBXZWFrTWFwKCksIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9XG4gICAgZW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5lbnRyaWVzKCk7XG4gICAgfVxuICAgIGZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZykge1xuICAgICAgICAvLyBXZSBoYXZlIHRvIHdyYXAgdGhlIHNwZWNpZmllZCBjYWxsYmFjayBpbiBvcmRlciB0byBwcmV2ZW50IGl0IGZyb21cbiAgICAgICAgLy8gcmVjZWl2aW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBpbm5lciBtYXAuXG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuZm9yRWFjaCgodmFsdWUsIGtleSwgX21hcCkgPT4gY2FsbGJhY2tmbi5jYWxsKHRoaXNBcmcsIHZhbHVlLCBrZXksIHRoaXMpKTtcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpLmdldChrZXkpO1xuICAgIH1cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuaGFzKGtleSk7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikua2V5cygpO1xuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikudmFsdWVzKCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYEZyb3plbk1hcCgke3RoaXMuc2l6ZX0pIHske3RoaXMuc2l6ZSA+IDBcbiAgICAgICAgICAgID8gYCAke1suLi50aGlzLmVudHJpZXMoKV1cbiAgICAgICAgICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IGAke1N0cmluZyhrZXkpfSA9PiAke1N0cmluZyh2YWx1ZSl9YClcbiAgICAgICAgICAgICAgICAuam9pbignLCAnKX0gYFxuICAgICAgICAgICAgOiAnJ319YDtcbiAgICB9XG59XG5leHBvcnRzLkZyb3plbk1hcCA9IEZyb3plbk1hcDtcbi8qKlxuICogQSB7QGxpbmsgUmVhZG9ubHlTZXR9IHRoYXQgY2Fubm90IGJlIG1vZGlmaWVkIGFmdGVyIGluc3RhbnRpYXRpb24uXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gdXNlcyBhbiBpbm5lciBzZXQgaGlkZGVuIHZpYSBhIHByaXZhdGUgZmllbGQsIGFuZCB0aGVcbiAqIGltbXV0YWJpbGl0eSBndWFyYW50ZWUgcmVsaWVzIG9uIGl0IGJlaW5nIGltcG9zc2libGUgdG8gZ2V0IGEgcmVmZXJlbmNlXG4gKiB0byB0aGlzIHNldC5cbiAqL1xuY2xhc3MgRnJvemVuU2V0IHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZXMpIHtcbiAgICAgICAgX0Zyb3plblNldF9zZXQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0Zyb3plblNldF9zZXQsIG5ldyBTZXQodmFsdWVzKSwgXCJmXCIpO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKS5zaXplO1xuICAgIH1cbiAgICBbKF9Gcm96ZW5TZXRfc2V0ID0gbmV3IFdlYWtNYXAoKSwgU3ltYm9sLml0ZXJhdG9yKV0oKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIilbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIH1cbiAgICBlbnRyaWVzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLmVudHJpZXMoKTtcbiAgICB9XG4gICAgZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgdG8gd3JhcCB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrIGluIG9yZGVyIHRvIHByZXZlbnQgaXQgZnJvbVxuICAgICAgICAvLyByZWNlaXZpbmcgYSByZWZlcmVuY2UgdG8gdGhlIGlubmVyIHNldC5cbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKS5mb3JFYWNoKCh2YWx1ZSwgdmFsdWUyLCBfc2V0KSA9PiBjYWxsYmFja2ZuLmNhbGwodGhpc0FyZywgdmFsdWUsIHZhbHVlMiwgdGhpcykpO1xuICAgIH1cbiAgICBoYXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKS5oYXModmFsdWUpO1xuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLmtleXMoKTtcbiAgICB9XG4gICAgdmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLnZhbHVlcygpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBGcm96ZW5TZXQoJHt0aGlzLnNpemV9KSB7JHt0aGlzLnNpemUgPiAwXG4gICAgICAgICAgICA/IGAgJHtbLi4udGhpcy52YWx1ZXMoKV0ubWFwKChtZW1iZXIpID0+IFN0cmluZyhtZW1iZXIpKS5qb2luKCcsICcpfSBgXG4gICAgICAgICAgICA6ICcnfX1gO1xuICAgIH1cbn1cbmV4cG9ydHMuRnJvemVuU2V0ID0gRnJvemVuU2V0O1xuT2JqZWN0LmZyZWV6ZShGcm96ZW5NYXApO1xuT2JqZWN0LmZyZWV6ZShGcm96ZW5NYXAucHJvdG90eXBlKTtcbk9iamVjdC5mcmVlemUoRnJvemVuU2V0KTtcbk9iamVjdC5mcmVlemUoRnJvemVuU2V0LnByb3RvdHlwZSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xsZWN0aW9ucy5qcy5tYXAiXSwibmFtZXMiOlsiX19jbGFzc1ByaXZhdGVGaWVsZFNldCIsInJlY2VpdmVyIiwic3RhdGUiLCJ2YWx1ZSIsImtpbmQiLCJmIiwiVHlwZUVycm9yIiwiaGFzIiwiY2FsbCIsInNldCIsIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCJnZXQiLCJfRnJvemVuTWFwX21hcCIsIl9Gcm96ZW5TZXRfc2V0IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwiRnJvemVuU2V0IiwiRnJvemVuTWFwIiwiY29uc3RydWN0b3IiLCJlbnRyaWVzIiwiTWFwIiwiZnJlZXplIiwic2l6ZSIsIldlYWtNYXAiLCJTeW1ib2wiLCJpdGVyYXRvciIsImZvckVhY2giLCJjYWxsYmFja2ZuIiwidGhpc0FyZyIsImtleSIsIl9tYXAiLCJrZXlzIiwidmFsdWVzIiwidG9TdHJpbmciLCJtYXAiLCJTdHJpbmciLCJqb2luIiwiU2V0IiwidmFsdWUyIiwiX3NldCIsIm1lbWJlciIsInByb3RvdHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/collections.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/encryption-types.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/encryption-types.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n})); //# sourceMappingURL=encryption-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2VuY3J5cHRpb24tdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUMsRUFDN0QsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2l0aC1uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvZW5jcnlwdGlvbi10eXBlcy5qcz8xM2M5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5jcnlwdGlvbi10eXBlcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/encryption-types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/hex.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/hex.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.remove0x = exports.add0x = exports.assertIsStrictHexString = exports.assertIsHexString = exports.isStrictHexString = exports.isHexString = exports.StrictHexStruct = exports.HexStruct = void 0;\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js\");\nexports.HexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^(?:0x)?[0-9a-f]+$/iu);\nexports.StrictHexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^0x[0-9a-f]+$/iu);\n/**\n * Check if a string is a valid hex string.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */ function isHexString(value) {\n    return (0, superstruct_1.is)(value, exports.HexStruct);\n}\nexports.isHexString = isHexString;\n/**\n * Strictly check if a string is a valid hex string. A valid hex string must\n * start with the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */ function isStrictHexString(value) {\n    return (0, superstruct_1.is)(value, exports.StrictHexStruct);\n}\nexports.isStrictHexString = isStrictHexString;\n/**\n * Assert that a value is a valid hex string.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */ function assertIsHexString(value) {\n    (0, assert_1.assert)(isHexString(value), \"Value must be a hexadecimal string.\");\n}\nexports.assertIsHexString = assertIsHexString;\n/**\n * Assert that a value is a valid hex string. A valid hex string must start with\n * the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */ function assertIsStrictHexString(value) {\n    (0, assert_1.assert)(isStrictHexString(value), 'Value must be a hexadecimal string, starting with \"0x\".');\n}\nexports.assertIsStrictHexString = assertIsStrictHexString;\n/**\n * Add the `0x`-prefix to a hexadecimal string. If the string already has the\n * prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to add the prefix to.\n * @returns The prefixed hexadecimal string.\n */ function add0x(hexadecimal) {\n    if (hexadecimal.startsWith(\"0x\")) {\n        return hexadecimal;\n    }\n    if (hexadecimal.startsWith(\"0X\")) {\n        return `0x${hexadecimal.substring(2)}`;\n    }\n    return `0x${hexadecimal}`;\n}\nexports.add0x = add0x;\n/**\n * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have\n * the prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to remove the prefix from.\n * @returns The un-prefixed hexadecimal string.\n */ function remove0x(hexadecimal) {\n    if (hexadecimal.startsWith(\"0x\") || hexadecimal.startsWith(\"0X\")) {\n        return hexadecimal.substring(2);\n    }\n    return hexadecimal;\n}\nexports.remove0x = remove0x; //# sourceMappingURL=hex.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2hleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZ0JBQWdCLEdBQUdBLGFBQWEsR0FBR0EsK0JBQStCLEdBQUdBLHlCQUF5QixHQUFHQSx5QkFBeUIsR0FBR0EsbUJBQW1CLEdBQUdBLHVCQUF1QixHQUFHQSxpQkFBaUIsR0FBRyxLQUFLO0FBQ3RNLE1BQU1VLGdCQUFnQkMsbUJBQU9BLENBQUMsb0VBQWE7QUFDM0MsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsb0dBQVU7QUFDbkNYLGlCQUFpQixHQUFHLENBQUMsR0FBR1UsY0FBY0csT0FBTyxFQUFFLENBQUMsR0FBR0gsY0FBY0ksTUFBTSxLQUFLO0FBQzVFZCx1QkFBdUIsR0FBRyxDQUFDLEdBQUdVLGNBQWNHLE9BQU8sRUFBRSxDQUFDLEdBQUdILGNBQWNJLE1BQU0sS0FBSztBQUNsRjs7Ozs7Q0FLQyxHQUNELFNBQVNQLFlBQVlOLEtBQUs7SUFDdEIsT0FBTyxDQUFDLEdBQUdTLGNBQWNLLEVBQUUsRUFBRWQsT0FBT0QsUUFBUVMsU0FBUztBQUN6RDtBQUNBVCxtQkFBbUIsR0FBR087QUFDdEI7Ozs7OztDQU1DLEdBQ0QsU0FBU0Qsa0JBQWtCTCxLQUFLO0lBQzVCLE9BQU8sQ0FBQyxHQUFHUyxjQUFjSyxFQUFFLEVBQUVkLE9BQU9ELFFBQVFRLGVBQWU7QUFDL0Q7QUFDQVIseUJBQXlCLEdBQUdNO0FBQzVCOzs7OztDQUtDLEdBQ0QsU0FBU0Qsa0JBQWtCSixLQUFLO0lBQzNCLElBQUdXLFNBQVNJLE1BQU0sRUFBRVQsWUFBWU4sUUFBUTtBQUM3QztBQUNBRCx5QkFBeUIsR0FBR0s7QUFDNUI7Ozs7OztDQU1DLEdBQ0QsU0FBU0Qsd0JBQXdCSCxLQUFLO0lBQ2pDLElBQUdXLFNBQVNJLE1BQU0sRUFBRVYsa0JBQWtCTCxRQUFRO0FBQ25EO0FBQ0FELCtCQUErQixHQUFHSTtBQUNsQzs7Ozs7O0NBTUMsR0FDRCxTQUFTRCxNQUFNYyxXQUFXO0lBQ3RCLElBQUlBLFlBQVlDLFVBQVUsQ0FBQyxPQUFPO1FBQzlCLE9BQU9EO0lBQ1g7SUFDQSxJQUFJQSxZQUFZQyxVQUFVLENBQUMsT0FBTztRQUM5QixPQUFPLENBQUMsRUFBRSxFQUFFRCxZQUFZRSxTQUFTLENBQUMsR0FBRyxDQUFDO0lBQzFDO0lBQ0EsT0FBTyxDQUFDLEVBQUUsRUFBRUYsWUFBWSxDQUFDO0FBQzdCO0FBQ0FqQixhQUFhLEdBQUdHO0FBQ2hCOzs7Ozs7Q0FNQyxHQUNELFNBQVNELFNBQVNlLFdBQVc7SUFDekIsSUFBSUEsWUFBWUMsVUFBVSxDQUFDLFNBQVNELFlBQVlDLFVBQVUsQ0FBQyxPQUFPO1FBQzlELE9BQU9ELFlBQVlFLFNBQVMsQ0FBQztJQUNqQztJQUNBLE9BQU9GO0FBQ1g7QUFDQWpCLGdCQUFnQixHQUFHRSxVQUNuQiwrQkFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aXRoLW5leHQtYXBwLy4vbm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9oZXguanM/YzUyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVtb3ZlMHggPSBleHBvcnRzLmFkZDB4ID0gZXhwb3J0cy5hc3NlcnRJc1N0cmljdEhleFN0cmluZyA9IGV4cG9ydHMuYXNzZXJ0SXNIZXhTdHJpbmcgPSBleHBvcnRzLmlzU3RyaWN0SGV4U3RyaW5nID0gZXhwb3J0cy5pc0hleFN0cmluZyA9IGV4cG9ydHMuU3RyaWN0SGV4U3RydWN0ID0gZXhwb3J0cy5IZXhTdHJ1Y3QgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG5leHBvcnRzLkhleFN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnBhdHRlcm4pKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgL14oPzoweCk/WzAtOWEtZl0rJC9pdSk7XG5leHBvcnRzLlN0cmljdEhleFN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnBhdHRlcm4pKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgL14weFswLTlhLWZdKyQvaXUpO1xuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBpcyBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB2YWxpZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBpc0hleFN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSGV4U3RydWN0KTtcbn1cbmV4cG9ydHMuaXNIZXhTdHJpbmcgPSBpc0hleFN0cmluZztcbi8qKlxuICogU3RyaWN0bHkgY2hlY2sgaWYgYSBzdHJpbmcgaXMgYSB2YWxpZCBoZXggc3RyaW5nLiBBIHZhbGlkIGhleCBzdHJpbmcgbXVzdFxuICogc3RhcnQgd2l0aCB0aGUgXCIweFwiLXByZWZpeC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0SGV4U3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5TdHJpY3RIZXhTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1N0cmljdEhleFN0cmluZyA9IGlzU3RyaWN0SGV4U3RyaW5nO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0hleFN0cmluZyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGlzSGV4U3RyaW5nKHZhbHVlKSwgJ1ZhbHVlIG11c3QgYmUgYSBoZXhhZGVjaW1hbCBzdHJpbmcuJyk7XG59XG5leHBvcnRzLmFzc2VydElzSGV4U3RyaW5nID0gYXNzZXJ0SXNIZXhTdHJpbmc7XG4vKipcbiAqIEFzc2VydCB0aGF0IGEgdmFsdWUgaXMgYSB2YWxpZCBoZXggc3RyaW5nLiBBIHZhbGlkIGhleCBzdHJpbmcgbXVzdCBzdGFydCB3aXRoXG4gKiB0aGUgXCIweFwiLXByZWZpeC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc1N0cmljdEhleFN0cmluZyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGlzU3RyaWN0SGV4U3RyaW5nKHZhbHVlKSwgJ1ZhbHVlIG11c3QgYmUgYSBoZXhhZGVjaW1hbCBzdHJpbmcsIHN0YXJ0aW5nIHdpdGggXCIweFwiLicpO1xufVxuZXhwb3J0cy5hc3NlcnRJc1N0cmljdEhleFN0cmluZyA9IGFzc2VydElzU3RyaWN0SGV4U3RyaW5nO1xuLyoqXG4gKiBBZGQgdGhlIGAweGAtcHJlZml4IHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBJZiB0aGUgc3RyaW5nIGFscmVhZHkgaGFzIHRoZVxuICogcHJlZml4LCBpdCBpcyByZXR1cm5lZCBhcy1pcy5cbiAqXG4gKiBAcGFyYW0gaGV4YWRlY2ltYWwgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGFkZCB0aGUgcHJlZml4IHRvLlxuICogQHJldHVybnMgVGhlIHByZWZpeGVkIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYWRkMHgoaGV4YWRlY2ltYWwpIHtcbiAgICBpZiAoaGV4YWRlY2ltYWwuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICByZXR1cm4gaGV4YWRlY2ltYWw7XG4gICAgfVxuICAgIGlmIChoZXhhZGVjaW1hbC5zdGFydHNXaXRoKCcwWCcpKSB7XG4gICAgICAgIHJldHVybiBgMHgke2hleGFkZWNpbWFsLnN1YnN0cmluZygyKX1gO1xuICAgIH1cbiAgICByZXR1cm4gYDB4JHtoZXhhZGVjaW1hbH1gO1xufVxuZXhwb3J0cy5hZGQweCA9IGFkZDB4O1xuLyoqXG4gKiBSZW1vdmUgdGhlIGAweGAtcHJlZml4IGZyb20gYSBoZXhhZGVjaW1hbCBzdHJpbmcuIElmIHRoZSBzdHJpbmcgZG9lc24ndCBoYXZlXG4gKiB0aGUgcHJlZml4LCBpdCBpcyByZXR1cm5lZCBhcy1pcy5cbiAqXG4gKiBAcGFyYW0gaGV4YWRlY2ltYWwgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIHJlbW92ZSB0aGUgcHJlZml4IGZyb20uXG4gKiBAcmV0dXJucyBUaGUgdW4tcHJlZml4ZWQgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiByZW1vdmUweChoZXhhZGVjaW1hbCkge1xuICAgIGlmIChoZXhhZGVjaW1hbC5zdGFydHNXaXRoKCcweCcpIHx8IGhleGFkZWNpbWFsLnN0YXJ0c1dpdGgoJzBYJykpIHtcbiAgICAgICAgcmV0dXJuIGhleGFkZWNpbWFsLnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleGFkZWNpbWFsO1xufVxuZXhwb3J0cy5yZW1vdmUweCA9IHJlbW92ZTB4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJlbW92ZTB4IiwiYWRkMHgiLCJhc3NlcnRJc1N0cmljdEhleFN0cmluZyIsImFzc2VydElzSGV4U3RyaW5nIiwiaXNTdHJpY3RIZXhTdHJpbmciLCJpc0hleFN0cmluZyIsIlN0cmljdEhleFN0cnVjdCIsIkhleFN0cnVjdCIsInN1cGVyc3RydWN0XzEiLCJyZXF1aXJlIiwiYXNzZXJ0XzEiLCJwYXR0ZXJuIiwic3RyaW5nIiwiaXMiLCJhc3NlcnQiLCJoZXhhZGVjaW1hbCIsInN0YXJ0c1dpdGgiLCJzdWJzdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/hex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/index.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n__exportStar(__webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js\"), exports);\n__exportStar(__webpack_require__(/*! ./base64 */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/base64.js\"), exports);\n__exportStar(__webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/bytes.js\"), exports);\n__exportStar(__webpack_require__(/*! ./checksum */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/checksum.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coercers */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/coercers.js\"), exports);\n__exportStar(__webpack_require__(/*! ./collections */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/collections.js\"), exports);\n__exportStar(__webpack_require__(/*! ./encryption-types */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/encryption-types.js\"), exports);\n__exportStar(__webpack_require__(/*! ./hex */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/hex.js\"), exports);\n__exportStar(__webpack_require__(/*! ./json */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/json.js\"), exports);\n__exportStar(__webpack_require__(/*! ./keyring */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/keyring.js\"), exports);\n__exportStar(__webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/logging.js\"), exports);\n__exportStar(__webpack_require__(/*! ./misc */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/misc.js\"), exports);\n__exportStar(__webpack_require__(/*! ./number */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/number.js\"), exports);\n__exportStar(__webpack_require__(/*! ./opaque */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/opaque.js\"), exports);\n__exportStar(__webpack_require__(/*! ./time */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/time.js\"), exports);\n__exportStar(__webpack_require__(/*! ./transaction-types */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/transaction-types.js\"), exports);\n__exportStar(__webpack_require__(/*! ./versions */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/versions.js\"), exports); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFNQyxDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUMxRixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQixJQUFJRyxPQUFPUCxPQUFPUSx3QkFBd0IsQ0FBQ0wsR0FBR0M7SUFDOUMsSUFBSSxDQUFDRyxRQUFTLFVBQVNBLE9BQU8sQ0FBQ0osRUFBRU0sVUFBVSxHQUFHRixLQUFLRyxRQUFRLElBQUlILEtBQUtJLFlBQVksR0FBRztRQUNqRkosT0FBTztZQUFFSyxZQUFZO1lBQU1DLEtBQUs7Z0JBQWEsT0FBT1YsQ0FBQyxDQUFDQyxFQUFFO1lBQUU7UUFBRTtJQUM5RDtJQUNBSixPQUFPYyxjQUFjLENBQUNaLEdBQUdHLElBQUlFO0FBQ2pDLElBQU0sU0FBU0wsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUN0QixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQkYsQ0FBQyxDQUFDRyxHQUFHLEdBQUdGLENBQUMsQ0FBQ0MsRUFBRTtBQUNoQixDQUFDO0FBQ0QsSUFBSVcsZUFBZSxDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLFlBQVksSUFBSyxTQUFTWixDQUFDLEVBQUVhLFFBQU87SUFDakUsSUFBSyxJQUFJQyxLQUFLZCxFQUFHLElBQUljLE1BQU0sYUFBYSxDQUFDakIsT0FBT2tCLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLFVBQVNDLElBQUlsQixnQkFBZ0JpQixVQUFTYixHQUFHYztBQUMzSDtBQUNBakIsOENBQTZDO0lBQUVxQixPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdETixhQUFhTyxtQkFBT0EsQ0FBQyxvR0FBVSxHQUFHTjtBQUNsQ0QsYUFBYU8sbUJBQU9BLENBQUMsb0dBQVUsR0FBR047QUFDbENELGFBQWFPLG1CQUFPQSxDQUFDLGtHQUFTLEdBQUdOO0FBQ2pDRCxhQUFhTyxtQkFBT0EsQ0FBQyx3R0FBWSxHQUFHTjtBQUNwQ0QsYUFBYU8sbUJBQU9BLENBQUMsd0dBQVksR0FBR047QUFDcENELGFBQWFPLG1CQUFPQSxDQUFDLDhHQUFlLEdBQUdOO0FBQ3ZDRCxhQUFhTyxtQkFBT0EsQ0FBQyx3SEFBb0IsR0FBR047QUFDNUNELGFBQWFPLG1CQUFPQSxDQUFDLDhGQUFPLEdBQUdOO0FBQy9CRCxhQUFhTyxtQkFBT0EsQ0FBQyxnR0FBUSxHQUFHTjtBQUNoQ0QsYUFBYU8sbUJBQU9BLENBQUMsc0dBQVcsR0FBR047QUFDbkNELGFBQWFPLG1CQUFPQSxDQUFDLHNHQUFXLEdBQUdOO0FBQ25DRCxhQUFhTyxtQkFBT0EsQ0FBQyxnR0FBUSxHQUFHTjtBQUNoQ0QsYUFBYU8sbUJBQU9BLENBQUMsb0dBQVUsR0FBR047QUFDbENELGFBQWFPLG1CQUFPQSxDQUFDLG9HQUFVLEdBQUdOO0FBQ2xDRCxhQUFhTyxtQkFBT0EsQ0FBQyxnR0FBUSxHQUFHTjtBQUNoQ0QsYUFBYU8sbUJBQU9BLENBQUMsMEhBQXFCLEdBQUdOO0FBQzdDRCxhQUFhTyxtQkFBT0EsQ0FBQyx3R0FBWSxHQUFHTixVQUNwQyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aXRoLW5leHQtYXBwLy4vbm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9pbmRleC5qcz8wY2UwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzZXJ0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlNjRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2J5dGVzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jaGVja3N1bVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29lcmNlcnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbGxlY3Rpb25zXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lbmNyeXB0aW9uLXR5cGVzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9oZXhcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2pzb25cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2tleXJpbmdcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xvZ2dpbmdcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21pc2NcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL251bWJlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vb3BhcXVlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90aW1lXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90cmFuc2FjdGlvbi10eXBlc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmVyc2lvbnNcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZXhwb3J0U3RhciIsImV4cG9ydHMiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidmFsdWUiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/json.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/json.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getJsonRpcIdValidator = exports.assertIsJsonRpcError = exports.isJsonRpcError = exports.assertIsJsonRpcFailure = exports.isJsonRpcFailure = exports.assertIsJsonRpcSuccess = exports.isJsonRpcSuccess = exports.assertIsJsonRpcResponse = exports.isJsonRpcResponse = exports.assertIsPendingJsonRpcResponse = exports.isPendingJsonRpcResponse = exports.JsonRpcResponseStruct = exports.JsonRpcFailureStruct = exports.JsonRpcSuccessStruct = exports.PendingJsonRpcResponseStruct = exports.assertIsJsonRpcRequest = exports.isJsonRpcRequest = exports.assertIsJsonRpcNotification = exports.isJsonRpcNotification = exports.JsonRpcNotificationStruct = exports.JsonRpcRequestStruct = exports.JsonRpcParamsStruct = exports.JsonRpcErrorStruct = exports.JsonRpcIdStruct = exports.JsonRpcVersionStruct = exports.jsonrpc2 = exports.getJsonSize = exports.isValidJson = exports.JsonStruct = exports.UnsafeJsonStruct = void 0;\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js\");\n/**\n * A struct to check if the given value is finite number. Superstruct's\n * `number()` struct does not check if the value is finite.\n *\n * @returns A struct to check if the given value is finite number.\n */ const finiteNumber = ()=>(0, superstruct_1.define)(\"finite number\", (value)=>{\n        return (0, superstruct_1.is)(value, (0, superstruct_1.number)()) && Number.isFinite(value);\n    });\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * Note that this struct is unsafe. For safe validation, use {@link JsonStruct}.\n */ // We cannot infer the type of the struct, because it is recursive.\nexports.UnsafeJsonStruct = (0, superstruct_1.union)([\n    (0, superstruct_1.literal)(null),\n    (0, superstruct_1.boolean)(),\n    finiteNumber(),\n    (0, superstruct_1.string)(),\n    (0, superstruct_1.array)((0, superstruct_1.lazy)(()=>exports.UnsafeJsonStruct)),\n    (0, superstruct_1.record)((0, superstruct_1.string)(), (0, superstruct_1.lazy)(()=>exports.UnsafeJsonStruct))\n]);\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * This struct sanitizes the value before validating it, so that it is safe to\n * use with untrusted input.\n */ exports.JsonStruct = (0, superstruct_1.define)(\"Json\", (value, context)=>{\n    /**\n     * Helper function that runs the given struct validator and returns the\n     * validation errors, if any. If the value is valid, it returns `true`.\n     *\n     * @param innerValue - The value to validate.\n     * @param struct - The struct to use for validation.\n     * @returns The validation errors, or `true` if the value is valid.\n     */ function checkStruct(innerValue, struct) {\n        const iterator = struct.validator(innerValue, context);\n        const errors = [\n            ...iterator\n        ];\n        if (errors.length > 0) {\n            return errors;\n        }\n        return true;\n    }\n    try {\n        // The plain value must be a valid JSON value, but it may be altered in the\n        // process of JSON serialization, so we need to validate it again after\n        // serialization. This has the added benefit that the returned error messages\n        // will be more helpful, as they will point to the exact location of the\n        // invalid value.\n        //\n        // This seems overcomplicated, but without checking the plain value first,\n        // there are some cases where the validation passes, even though the value is\n        // not valid JSON. For example, `undefined` is not valid JSON, but serializing\n        // it will remove it from the object, so the validation will pass.\n        const unsafeResult = checkStruct(value, exports.UnsafeJsonStruct);\n        if (unsafeResult !== true) {\n            return unsafeResult;\n        }\n        // JavaScript engines are highly optimized for this specific use case of\n        // JSON parsing and stringifying, so there should be no performance impact.\n        return checkStruct(JSON.parse(JSON.stringify(value)), exports.UnsafeJsonStruct);\n    } catch (error) {\n        if (error instanceof RangeError) {\n            return \"Circular reference detected\";\n        }\n        return false;\n    }\n});\n/**\n * Check if the given value is a valid {@link Json} value, i.e., a value that is\n * serializable to JSON.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link Json} value.\n */ function isValidJson(value) {\n    return (0, superstruct_1.is)(value, exports.JsonStruct);\n}\nexports.isValidJson = isValidJson;\n/**\n * Get the size of a JSON value in bytes. This also validates the value.\n *\n * @param value - The JSON value to get the size of.\n * @returns The size of the JSON value in bytes.\n */ function getJsonSize(value) {\n    (0, assert_1.assertStruct)(value, exports.JsonStruct, \"Invalid JSON value\");\n    const json = JSON.stringify(value);\n    return new TextEncoder().encode(json).byteLength;\n}\nexports.getJsonSize = getJsonSize;\n/**\n * The string '2.0'.\n */ exports.jsonrpc2 = \"2.0\";\nexports.JsonRpcVersionStruct = (0, superstruct_1.literal)(exports.jsonrpc2);\nexports.JsonRpcIdStruct = (0, superstruct_1.nullable)((0, superstruct_1.union)([\n    (0, superstruct_1.number)(),\n    (0, superstruct_1.string)()\n]));\nexports.JsonRpcErrorStruct = (0, superstruct_1.object)({\n    code: (0, superstruct_1.integer)(),\n    message: (0, superstruct_1.string)(),\n    data: (0, superstruct_1.optional)(exports.JsonStruct),\n    stack: (0, superstruct_1.optional)((0, superstruct_1.string)())\n});\nexports.JsonRpcParamsStruct = (0, superstruct_1.optional)((0, superstruct_1.union)([\n    (0, superstruct_1.record)((0, superstruct_1.string)(), exports.JsonStruct),\n    (0, superstruct_1.array)(exports.JsonStruct)\n]));\nexports.JsonRpcRequestStruct = (0, superstruct_1.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    method: (0, superstruct_1.string)(),\n    params: exports.JsonRpcParamsStruct\n});\nexports.JsonRpcNotificationStruct = (0, superstruct_1.omit)(exports.JsonRpcRequestStruct, [\n    \"id\"\n]);\n/**\n * Check if the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcNotification}\n * object.\n */ function isJsonRpcNotification(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcNotificationStruct);\n}\nexports.isJsonRpcNotification = isJsonRpcNotification;\n/**\n * Assert that the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcNotification} object.\n */ function assertIsJsonRpcNotification(value, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcNotificationStruct, \"Invalid JSON-RPC notification\", ErrorWrapper);\n}\nexports.assertIsJsonRpcNotification = assertIsJsonRpcNotification;\n/**\n * Check if the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcRequest} object.\n */ function isJsonRpcRequest(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcRequestStruct);\n}\nexports.isJsonRpcRequest = isJsonRpcRequest;\n/**\n * Assert that the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The JSON-RPC request or notification to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcRequest} object.\n */ function assertIsJsonRpcRequest(value, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcRequestStruct, \"Invalid JSON-RPC request\", ErrorWrapper);\n}\nexports.assertIsJsonRpcRequest = assertIsJsonRpcRequest;\nexports.PendingJsonRpcResponseStruct = (0, superstruct_1.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    result: (0, superstruct_1.optional)((0, superstruct_1.unknown)()),\n    error: (0, superstruct_1.optional)(exports.JsonRpcErrorStruct)\n});\nexports.JsonRpcSuccessStruct = (0, superstruct_1.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    result: exports.JsonStruct\n});\nexports.JsonRpcFailureStruct = (0, superstruct_1.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    error: exports.JsonRpcErrorStruct\n});\nexports.JsonRpcResponseStruct = (0, superstruct_1.union)([\n    exports.JsonRpcSuccessStruct,\n    exports.JsonRpcFailureStruct\n]);\n/**\n * Type guard to check whether specified JSON-RPC response is a\n * {@link PendingJsonRpcResponse}.\n *\n * @param response - The JSON-RPC response to check.\n * @returns Whether the specified JSON-RPC response is pending.\n */ function isPendingJsonRpcResponse(response) {\n    return (0, superstruct_1.is)(response, exports.PendingJsonRpcResponseStruct);\n}\nexports.isPendingJsonRpcResponse = isPendingJsonRpcResponse;\n/**\n * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.\n *\n * @param response - The JSON-RPC response to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link PendingJsonRpcResponse}\n * object.\n */ function assertIsPendingJsonRpcResponse(response, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(response, exports.PendingJsonRpcResponseStruct, \"Invalid pending JSON-RPC response\", ErrorWrapper);\n}\nexports.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse;\n/**\n * Type guard to check if a value is a {@link JsonRpcResponse}.\n *\n * @param response - The object to check.\n * @returns Whether the object is a JsonRpcResponse.\n */ function isJsonRpcResponse(response) {\n    return (0, superstruct_1.is)(response, exports.JsonRpcResponseStruct);\n}\nexports.isJsonRpcResponse = isJsonRpcResponse;\n/**\n * Assert that the given value is a valid {@link JsonRpcResponse} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcResponse} object.\n */ function assertIsJsonRpcResponse(value, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcResponseStruct, \"Invalid JSON-RPC response\", ErrorWrapper);\n}\nexports.assertIsJsonRpcResponse = assertIsJsonRpcResponse;\n/**\n * Check if the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.\n */ function isJsonRpcSuccess(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcSuccessStruct);\n}\nexports.isJsonRpcSuccess = isJsonRpcSuccess;\n/**\n * Assert that the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcSuccess} object.\n */ function assertIsJsonRpcSuccess(value, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcSuccessStruct, \"Invalid JSON-RPC success response\", ErrorWrapper);\n}\nexports.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess;\n/**\n * Check if the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcFailure} object.\n */ function isJsonRpcFailure(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcFailureStruct);\n}\nexports.isJsonRpcFailure = isJsonRpcFailure;\n/**\n * Assert that the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcFailure} object.\n */ function assertIsJsonRpcFailure(value, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcFailureStruct, \"Invalid JSON-RPC failure response\", ErrorWrapper);\n}\nexports.assertIsJsonRpcFailure = assertIsJsonRpcFailure;\n/**\n * Check if the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcError} object.\n */ function isJsonRpcError(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcErrorStruct);\n}\nexports.isJsonRpcError = isJsonRpcError;\n/**\n * Assert that the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcError} object.\n */ function assertIsJsonRpcError(value, // eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcErrorStruct, \"Invalid JSON-RPC error\", ErrorWrapper);\n}\nexports.assertIsJsonRpcError = assertIsJsonRpcError;\n/**\n * Gets a function for validating JSON-RPC request / response `id` values.\n *\n * By manipulating the options of this factory, you can control the behavior\n * of the resulting validator for some edge cases. This is useful because e.g.\n * `null` should sometimes but not always be permitted.\n *\n * Note that the empty string (`''`) is always permitted by the JSON-RPC\n * specification, but that kind of sucks and you may want to forbid it in some\n * instances anyway.\n *\n * For more details, see the\n * [JSON-RPC Specification](https://www.jsonrpc.org/specification).\n *\n * @param options - An options object.\n * @param options.permitEmptyString - Whether the empty string (i.e. `''`)\n * should be treated as a valid ID. Default: `true`\n * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)\n * should be treated as valid IDs. Default: `false`\n * @param options.permitNull - Whether `null` should be treated as a valid ID.\n * Default: `true`\n * @returns The JSON-RPC ID validator function.\n */ function getJsonRpcIdValidator(options) {\n    const { permitEmptyString, permitFractions, permitNull } = Object.assign({\n        permitEmptyString: true,\n        permitFractions: false,\n        permitNull: true\n    }, options);\n    /**\n     * Type guard for {@link JsonRpcId}.\n     *\n     * @param id - The JSON-RPC ID value to check.\n     * @returns Whether the given ID is valid per the options given to the\n     * factory.\n     */ const isValidJsonRpcId = (id)=>{\n        return Boolean(typeof id === \"number\" && (permitFractions || Number.isInteger(id)) || typeof id === \"string\" && (permitEmptyString || id.length > 0) || permitNull && id === null);\n    };\n    return isValidJsonRpcId;\n}\nexports.getJsonRpcIdValidator = getJsonRpcIdValidator; //# sourceMappingURL=json.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2pzb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHQSw0QkFBNEIsR0FBR0Esc0JBQXNCLEdBQUdBLDhCQUE4QixHQUFHQSx3QkFBd0IsR0FBR0EsOEJBQThCLEdBQUdBLHdCQUF3QixHQUFHQSwrQkFBK0IsR0FBR0EseUJBQXlCLEdBQUdBLHNDQUFzQyxHQUFHQSxnQ0FBZ0MsR0FBR0EsNkJBQTZCLEdBQUdBLDRCQUE0QixHQUFHQSw0QkFBNEIsR0FBR0Esb0NBQW9DLEdBQUdBLDhCQUE4QixHQUFHQSx3QkFBd0IsR0FBR0EsbUNBQW1DLEdBQUdBLDZCQUE2QixHQUFHQSxpQ0FBaUMsR0FBR0EsNEJBQTRCLEdBQUdBLDJCQUEyQixHQUFHQSwwQkFBMEIsR0FBR0EsdUJBQXVCLEdBQUdBLDRCQUE0QixHQUFHQSxnQkFBZ0IsR0FBR0EsbUJBQW1CLEdBQUdBLG1CQUFtQixHQUFHQSxrQkFBa0IsR0FBR0Esd0JBQXdCLEdBQUcsS0FBSztBQUM1NEIsTUFBTWdDLGdCQUFnQkMsbUJBQU9BLENBQUMsb0VBQWE7QUFDM0MsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsb0dBQVU7QUFDbkM7Ozs7O0NBS0MsR0FDRCxNQUFNRSxlQUFlLElBQU0sQ0FBQyxHQUFHSCxjQUFjSSxNQUFNLEVBQUUsaUJBQWlCLENBQUNuQztRQUNuRSxPQUFPLENBQUMsR0FBRytCLGNBQWNLLEVBQUUsRUFBRXBDLE9BQU8sQ0FBQyxHQUFHK0IsY0FBY00sTUFBTSxRQUFRQyxPQUFPQyxRQUFRLENBQUN2QztJQUN4RjtBQUNBOzs7O0NBSUMsR0FDRCxtRUFBbUU7QUFDbkVELHdCQUF3QixHQUFHLENBQUMsR0FBR2dDLGNBQWNTLEtBQUssRUFBRTtJQUMvQyxJQUFHVCxjQUFj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QUs7SUFDekIsT0FBTyxDQUFDLEdBQUcrQixjQUFjSyxFQUFFLEVBQUVwQyxPQUFPRCxRQUFRd0Isa0JBQWtCO0FBQ2xFO0FBQ0F4QixzQkFBc0IsR0FBR0k7QUFDekI7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNELHFCQUFxQkYsS0FBSyxFQUNuQyxnRUFBZ0U7QUFDaEUrRSxZQUFZO0lBQ1AsSUFBRzlDLFNBQVM0QixZQUFZLEVBQUU3RCxPQUFPRCxRQUFRd0Isa0JBQWtCLEVBQUUsMEJBQTBCd0Q7QUFDNUY7QUFDQWhGLDRCQUE0QixHQUFHRztBQUMvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNCQyxHQUNELFNBQVNELHNCQUFzQmtGLE9BQU87SUFDbEMsTUFBTSxFQUFFQyxpQkFBaUIsRUFBRUMsZUFBZSxFQUFFQyxVQUFVLEVBQUUsR0FBR3pGLE9BQU8wRixNQUFNLENBQUM7UUFBRUgsbUJBQW1CO1FBQU1DLGlCQUFpQjtRQUFPQyxZQUFZO0lBQUssR0FBR0g7SUFDaEo7Ozs7OztLQU1DLEdBQ0QsTUFBTUssbUJBQW1CLENBQUNkO1FBQ3RCLE9BQU9lLFFBQVEsT0FBUWYsT0FBTyxZQUFhVyxDQUFBQSxtQkFBbUIvQyxPQUFPb0QsU0FBUyxDQUFDaEIsR0FBRSxLQUM1RSxPQUFPQSxPQUFPLFlBQWFVLENBQUFBLHFCQUFxQlYsR0FBR3BCLE1BQU0sR0FBRyxNQUM1RGdDLGNBQWNaLE9BQU87SUFDOUI7SUFDQSxPQUFPYztBQUNYO0FBQ0F6Riw2QkFBNkIsR0FBR0UsdUJBQ2hDLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dpdGgtbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2pzb24uanM/YjczYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0SnNvblJwY0lkVmFsaWRhdG9yID0gZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNFcnJvciA9IGV4cG9ydHMuaXNKc29uUnBjRXJyb3IgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY0ZhaWx1cmUgPSBleHBvcnRzLmlzSnNvblJwY0ZhaWx1cmUgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY1N1Y2Nlc3MgPSBleHBvcnRzLmlzSnNvblJwY1N1Y2Nlc3MgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY1Jlc3BvbnNlID0gZXhwb3J0cy5pc0pzb25ScGNSZXNwb25zZSA9IGV4cG9ydHMuYXNzZXJ0SXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlID0gZXhwb3J0cy5pc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UgPSBleHBvcnRzLkpzb25ScGNSZXNwb25zZVN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY0ZhaWx1cmVTdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNTdWNjZXNzU3RydWN0ID0gZXhwb3J0cy5QZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0ID0gZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNSZXF1ZXN0ID0gZXhwb3J0cy5pc0pzb25ScGNSZXF1ZXN0ID0gZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNOb3RpZmljYXRpb24gPSBleHBvcnRzLmlzSnNvblJwY05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY1JlcXVlc3RTdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNQYXJhbXNTdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY0lkU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCA9IGV4cG9ydHMuanNvbnJwYzIgPSBleHBvcnRzLmdldEpzb25TaXplID0gZXhwb3J0cy5pc1ZhbGlkSnNvbiA9IGV4cG9ydHMuSnNvblN0cnVjdCA9IGV4cG9ydHMuVW5zYWZlSnNvblN0cnVjdCA9IHZvaWQgMDtcbmNvbnN0IHN1cGVyc3RydWN0XzEgPSByZXF1aXJlKFwic3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydFwiKTtcbi8qKlxuICogQSBzdHJ1Y3QgdG8gY2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGZpbml0ZSBudW1iZXIuIFN1cGVyc3RydWN0J3NcbiAqIGBudW1iZXIoKWAgc3RydWN0IGRvZXMgbm90IGNoZWNrIGlmIHRoZSB2YWx1ZSBpcyBmaW5pdGUuXG4gKlxuICogQHJldHVybnMgQSBzdHJ1Y3QgdG8gY2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGZpbml0ZSBudW1iZXIuXG4gKi9cbmNvbnN0IGZpbml0ZU51bWJlciA9ICgpID0+ICgwLCBzdXBlcnN0cnVjdF8xLmRlZmluZSkoJ2Zpbml0ZSBudW1iZXInLCAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCAoMCwgc3VwZXJzdHJ1Y3RfMS5udW1iZXIpKCkpICYmIE51bWJlci5pc0Zpbml0ZSh2YWx1ZSk7XG59KTtcbi8qKlxuICogQSBzdHJ1Y3QgdG8gY2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQgSlNPTi1zZXJpYWxpemFibGUgdmFsdWUuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgc3RydWN0IGlzIHVuc2FmZS4gRm9yIHNhZmUgdmFsaWRhdGlvbiwgdXNlIHtAbGluayBKc29uU3RydWN0fS5cbiAqL1xuLy8gV2UgY2Fubm90IGluZmVyIHRoZSB0eXBlIG9mIHRoZSBzdHJ1Y3QsIGJlY2F1c2UgaXQgaXMgcmVjdXJzaXZlLlxuZXhwb3J0cy5VbnNhZmVKc29uU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFtcbiAgICAoMCwgc3VwZXJzdHJ1Y3RfMS5saXRlcmFsKShudWxsKSxcbiAgICAoMCwgc3VwZXJzdHJ1Y3RfMS5ib29sZWFuKSgpLFxuICAgIGZpbml0ZU51bWJlcigpLFxuICAgICgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSxcbiAgICAoMCwgc3VwZXJzdHJ1Y3RfMS5hcnJheSkoKDAsIHN1cGVyc3RydWN0XzEubGF6eSkoKCkgPT4gZXhwb3J0cy5VbnNhZmVKc29uU3RydWN0KSksXG4gICAgKDAsIHN1cGVyc3RydWN0XzEucmVjb3JkKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksICgwLCBzdXBlcnN0cnVjdF8xLmxhenkpKCgpID0+IGV4cG9ydHMuVW5zYWZlSnNvblN0cnVjdCkpLFxuXSk7XG4vKipcbiAqIEEgc3RydWN0IHRvIGNoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIEpTT04tc2VyaWFsaXphYmxlIHZhbHVlLlxuICpcbiAqIFRoaXMgc3RydWN0IHNhbml0aXplcyB0aGUgdmFsdWUgYmVmb3JlIHZhbGlkYXRpbmcgaXQsIHNvIHRoYXQgaXQgaXMgc2FmZSB0b1xuICogdXNlIHdpdGggdW50cnVzdGVkIGlucHV0LlxuICovXG5leHBvcnRzLkpzb25TdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5kZWZpbmUpKCdKc29uJywgKHZhbHVlLCBjb250ZXh0KSA9PiB7XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgcnVucyB0aGUgZ2l2ZW4gc3RydWN0IHZhbGlkYXRvciBhbmQgcmV0dXJucyB0aGVcbiAgICAgKiB2YWxpZGF0aW9uIGVycm9ycywgaWYgYW55LiBJZiB0aGUgdmFsdWUgaXMgdmFsaWQsIGl0IHJldHVybnMgYHRydWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlubmVyVmFsdWUgLSBUaGUgdmFsdWUgdG8gdmFsaWRhdGUuXG4gICAgICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gdXNlIGZvciB2YWxpZGF0aW9uLlxuICAgICAqIEByZXR1cm5zIFRoZSB2YWxpZGF0aW9uIGVycm9ycywgb3IgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyB2YWxpZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGVja1N0cnVjdChpbm5lclZhbHVlLCBzdHJ1Y3QpIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSBzdHJ1Y3QudmFsaWRhdG9yKGlubmVyVmFsdWUsIGNvbnRleHQpO1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBbLi4uaXRlcmF0b3JdO1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIFRoZSBwbGFpbiB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgSlNPTiB2YWx1ZSwgYnV0IGl0IG1heSBiZSBhbHRlcmVkIGluIHRoZVxuICAgICAgICAvLyBwcm9jZXNzIG9mIEpTT04gc2VyaWFsaXphdGlvbiwgc28gd2UgbmVlZCB0byB2YWxpZGF0ZSBpdCBhZ2FpbiBhZnRlclxuICAgICAgICAvLyBzZXJpYWxpemF0aW9uLiBUaGlzIGhhcyB0aGUgYWRkZWQgYmVuZWZpdCB0aGF0IHRoZSByZXR1cm5lZCBlcnJvciBtZXNzYWdlc1xuICAgICAgICAvLyB3aWxsIGJlIG1vcmUgaGVscGZ1bCwgYXMgdGhleSB3aWxsIHBvaW50IHRvIHRoZSBleGFjdCBsb2NhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gaW52YWxpZCB2YWx1ZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhpcyBzZWVtcyBvdmVyY29tcGxpY2F0ZWQsIGJ1dCB3aXRob3V0IGNoZWNraW5nIHRoZSBwbGFpbiB2YWx1ZSBmaXJzdCxcbiAgICAgICAgLy8gdGhlcmUgYXJlIHNvbWUgY2FzZXMgd2hlcmUgdGhlIHZhbGlkYXRpb24gcGFzc2VzLCBldmVuIHRob3VnaCB0aGUgdmFsdWUgaXNcbiAgICAgICAgLy8gbm90IHZhbGlkIEpTT04uIEZvciBleGFtcGxlLCBgdW5kZWZpbmVkYCBpcyBub3QgdmFsaWQgSlNPTiwgYnV0IHNlcmlhbGl6aW5nXG4gICAgICAgIC8vIGl0IHdpbGwgcmVtb3ZlIGl0IGZyb20gdGhlIG9iamVjdCwgc28gdGhlIHZhbGlkYXRpb24gd2lsbCBwYXNzLlxuICAgICAgICBjb25zdCB1bnNhZmVSZXN1bHQgPSBjaGVja1N0cnVjdCh2YWx1ZSwgZXhwb3J0cy5VbnNhZmVKc29uU3RydWN0KTtcbiAgICAgICAgaWYgKHVuc2FmZVJlc3VsdCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuc2FmZVJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBKYXZhU2NyaXB0IGVuZ2luZXMgYXJlIGhpZ2hseSBvcHRpbWl6ZWQgZm9yIHRoaXMgc3BlY2lmaWMgdXNlIGNhc2Ugb2ZcbiAgICAgICAgLy8gSlNPTiBwYXJzaW5nIGFuZCBzdHJpbmdpZnlpbmcsIHNvIHRoZXJlIHNob3VsZCBiZSBubyBwZXJmb3JtYW5jZSBpbXBhY3QuXG4gICAgICAgIHJldHVybiBjaGVja1N0cnVjdChKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSksIGV4cG9ydHMuVW5zYWZlSnNvblN0cnVjdCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBSYW5nZUVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0NpcmN1bGFyIHJlZmVyZW5jZSBkZXRlY3RlZCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0pO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvbn0gdmFsdWUsIGkuZS4sIGEgdmFsdWUgdGhhdCBpc1xuICogc2VyaWFsaXphYmxlIHRvIEpTT04uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvbn0gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRKc29uKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5Kc29uU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNWYWxpZEpzb24gPSBpc1ZhbGlkSnNvbjtcbi8qKlxuICogR2V0IHRoZSBzaXplIG9mIGEgSlNPTiB2YWx1ZSBpbiBieXRlcy4gVGhpcyBhbHNvIHZhbGlkYXRlcyB0aGUgdmFsdWUuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIEpTT04gdmFsdWUgdG8gZ2V0IHRoZSBzaXplIG9mLlxuICogQHJldHVybnMgVGhlIHNpemUgb2YgdGhlIEpTT04gdmFsdWUgaW4gYnl0ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldEpzb25TaXplKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblN0cnVjdCwgJ0ludmFsaWQgSlNPTiB2YWx1ZScpO1xuICAgIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShqc29uKS5ieXRlTGVuZ3RoO1xufVxuZXhwb3J0cy5nZXRKc29uU2l6ZSA9IGdldEpzb25TaXplO1xuLyoqXG4gKiBUaGUgc3RyaW5nICcyLjAnLlxuICovXG5leHBvcnRzLmpzb25ycGMyID0gJzIuMCc7XG5leHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEubGl0ZXJhbCkoZXhwb3J0cy5qc29ucnBjMik7XG5leHBvcnRzLkpzb25ScGNJZFN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm51bGxhYmxlKSgoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoWygwLCBzdXBlcnN0cnVjdF8xLm51bWJlcikoKSwgKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpXSkpO1xuZXhwb3J0cy5Kc29uUnBjRXJyb3JTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5vYmplY3QpKHtcbiAgICBjb2RlOiAoMCwgc3VwZXJzdHJ1Y3RfMS5pbnRlZ2VyKSgpLFxuICAgIG1lc3NhZ2U6ICgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSxcbiAgICBkYXRhOiAoMCwgc3VwZXJzdHJ1Y3RfMS5vcHRpb25hbCkoZXhwb3J0cy5Kc29uU3RydWN0KSxcbiAgICBzdGFjazogKDAsIHN1cGVyc3RydWN0XzEub3B0aW9uYWwpKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSksXG59KTtcbmV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm9wdGlvbmFsKSgoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoWygwLCBzdXBlcnN0cnVjdF8xLnJlY29yZCkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCBleHBvcnRzLkpzb25TdHJ1Y3QpLCAoMCwgc3VwZXJzdHJ1Y3RfMS5hcnJheSkoZXhwb3J0cy5Kc29uU3RydWN0KV0pKTtcbmV4cG9ydHMuSnNvblJwY1JlcXVlc3RTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5vYmplY3QpKHtcbiAgICBpZDogZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QsXG4gICAganNvbnJwYzogZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCxcbiAgICBtZXRob2Q6ICgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSxcbiAgICBwYXJhbXM6IGV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjTm90aWZpY2F0aW9uU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub21pdCkoZXhwb3J0cy5Kc29uUnBjUmVxdWVzdFN0cnVjdCwgWydpZCddKTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNOb3RpZmljYXRpb259IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufVxuICogb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNOb3RpZmljYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNOb3RpZmljYXRpb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNOb3RpZmljYXRpb24gPSBpc0pzb25ScGNOb3RpZmljYXRpb247XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY05vdGlmaWNhdGlvbih2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjTm90aWZpY2F0aW9uU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyBub3RpZmljYXRpb24nLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNOb3RpZmljYXRpb24gPSBhc3NlcnRJc0pzb25ScGNOb3RpZmljYXRpb247XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVxdWVzdH0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXF1ZXN0fSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY1JlcXVlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjUmVxdWVzdCA9IGlzSnNvblJwY1JlcXVlc3Q7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVxdWVzdH0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBKU09OLVJQQyByZXF1ZXN0IG9yIG5vdGlmaWNhdGlvbiB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1JlcXVlc3R9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjUmVxdWVzdCh2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjUmVxdWVzdFN0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgcmVxdWVzdCcsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY1JlcXVlc3QgPSBhc3NlcnRJc0pzb25ScGNSZXF1ZXN0O1xuZXhwb3J0cy5QZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub2JqZWN0KSh7XG4gICAgaWQ6IGV4cG9ydHMuSnNvblJwY0lkU3RydWN0LFxuICAgIGpzb25ycGM6IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gICAgcmVzdWx0OiAoMCwgc3VwZXJzdHJ1Y3RfMS5vcHRpb25hbCkoKDAsIHN1cGVyc3RydWN0XzEudW5rbm93bikoKSksXG4gICAgZXJyb3I6ICgwLCBzdXBlcnN0cnVjdF8xLm9wdGlvbmFsKShleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCksXG59KTtcbmV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5vYmplY3QpKHtcbiAgICBpZDogZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QsXG4gICAganNvbnJwYzogZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCxcbiAgICByZXN1bHQ6IGV4cG9ydHMuSnNvblN0cnVjdCxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm9iamVjdCkoe1xuICAgIGlkOiBleHBvcnRzLkpzb25ScGNJZFN0cnVjdCxcbiAgICBqc29ucnBjOiBleHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0LFxuICAgIGVycm9yOiBleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoW1xuICAgIGV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QsXG4gICAgZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCxcbl0pO1xuLyoqXG4gKiBUeXBlIGd1YXJkIHRvIGNoZWNrIHdoZXRoZXIgc3BlY2lmaWVkIEpTT04tUlBDIHJlc3BvbnNlIGlzIGFcbiAqIHtAbGluayBQZW5kaW5nSnNvblJwY1Jlc3BvbnNlfS5cbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2UgLSBUaGUgSlNPTi1SUEMgcmVzcG9uc2UgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzcGVjaWZpZWQgSlNPTi1SUEMgcmVzcG9uc2UgaXMgcGVuZGluZy5cbiAqL1xuZnVuY3Rpb24gaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKShyZXNwb25zZSwgZXhwb3J0cy5QZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlID0gaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgUGVuZGluZ0pzb25ScGNSZXNwb25zZX0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBKU09OLVJQQyByZXNwb25zZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgUGVuZGluZ0pzb25ScGNSZXNwb25zZX1cbiAqIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlKHJlc3BvbnNlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHJlc3BvbnNlLCBleHBvcnRzLlBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QsICdJbnZhbGlkIHBlbmRpbmcgSlNPTi1SUEMgcmVzcG9uc2UnLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UgPSBhc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2U7XG4vKipcbiAqIFR5cGUgZ3VhcmQgdG8gY2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHtAbGluayBKc29uUnBjUmVzcG9uc2V9LlxuICpcbiAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBvYmplY3QgaXMgYSBKc29uUnBjUmVzcG9uc2UuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY1Jlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKShyZXNwb25zZSwgZXhwb3J0cy5Kc29uUnBjUmVzcG9uc2VTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNSZXNwb25zZSA9IGlzSnNvblJwY1Jlc3BvbnNlO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1Jlc3BvbnNlfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVzcG9uc2V9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2UodmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY1Jlc3BvbnNlU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyByZXNwb25zZScsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY1Jlc3BvbnNlID0gYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2U7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjU3VjY2Vzc30gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNTdWNjZXNzfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY1N1Y2Nlc3ModmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNTdWNjZXNzU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjU3VjY2VzcyA9IGlzSnNvblJwY1N1Y2Nlc3M7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjU3VjY2Vzc30gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1N1Y2Nlc3N9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjU3VjY2Vzcyh2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjU3VjY2Vzc1N0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgc3VjY2VzcyByZXNwb25zZScsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY1N1Y2Nlc3MgPSBhc3NlcnRJc0pzb25ScGNTdWNjZXNzO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0ZhaWx1cmV9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjRmFpbHVyZX0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNGYWlsdXJlKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCk7XG59XG5leHBvcnRzLmlzSnNvblJwY0ZhaWx1cmUgPSBpc0pzb25ScGNGYWlsdXJlO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0ZhaWx1cmV9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNGYWlsdXJlfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY0ZhaWx1cmUodmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY0ZhaWx1cmVTdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIGZhaWx1cmUgcmVzcG9uc2UnLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNGYWlsdXJlID0gYXNzZXJ0SXNKc29uUnBjRmFpbHVyZTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNFcnJvcih2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjRXJyb3IgPSBpc0pzb25ScGNFcnJvcjtcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0Vycm9yfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY0Vycm9yKHZhbHVlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgZXJyb3InLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNFcnJvciA9IGFzc2VydElzSnNvblJwY0Vycm9yO1xuLyoqXG4gKiBHZXRzIGEgZnVuY3Rpb24gZm9yIHZhbGlkYXRpbmcgSlNPTi1SUEMgcmVxdWVzdCAvIHJlc3BvbnNlIGBpZGAgdmFsdWVzLlxuICpcbiAqIEJ5IG1hbmlwdWxhdGluZyB0aGUgb3B0aW9ucyBvZiB0aGlzIGZhY3RvcnksIHlvdSBjYW4gY29udHJvbCB0aGUgYmVoYXZpb3JcbiAqIG9mIHRoZSByZXN1bHRpbmcgdmFsaWRhdG9yIGZvciBzb21lIGVkZ2UgY2FzZXMuIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2UgZS5nLlxuICogYG51bGxgIHNob3VsZCBzb21ldGltZXMgYnV0IG5vdCBhbHdheXMgYmUgcGVybWl0dGVkLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgZW1wdHkgc3RyaW5nIChgJydgKSBpcyBhbHdheXMgcGVybWl0dGVkIGJ5IHRoZSBKU09OLVJQQ1xuICogc3BlY2lmaWNhdGlvbiwgYnV0IHRoYXQga2luZCBvZiBzdWNrcyBhbmQgeW91IG1heSB3YW50IHRvIGZvcmJpZCBpdCBpbiBzb21lXG4gKiBpbnN0YW5jZXMgYW55d2F5LlxuICpcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB0aGVcbiAqIFtKU09OLVJQQyBTcGVjaWZpY2F0aW9uXShodHRwczovL3d3dy5qc29ucnBjLm9yZy9zcGVjaWZpY2F0aW9uKS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIG9wdGlvbnMucGVybWl0RW1wdHlTdHJpbmcgLSBXaGV0aGVyIHRoZSBlbXB0eSBzdHJpbmcgKGkuZS4gYCcnYClcbiAqIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgdmFsaWQgSUQuIERlZmF1bHQ6IGB0cnVlYFxuICogQHBhcmFtIG9wdGlvbnMucGVybWl0RnJhY3Rpb25zIC0gV2hldGhlciBmcmFjdGlvbmFsIG51bWJlcnMgKGUuZy4gYDEuMmApXG4gKiBzaG91bGQgYmUgdHJlYXRlZCBhcyB2YWxpZCBJRHMuIERlZmF1bHQ6IGBmYWxzZWBcbiAqIEBwYXJhbSBvcHRpb25zLnBlcm1pdE51bGwgLSBXaGV0aGVyIGBudWxsYCBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIHZhbGlkIElELlxuICogRGVmYXVsdDogYHRydWVgXG4gKiBAcmV0dXJucyBUaGUgSlNPTi1SUEMgSUQgdmFsaWRhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBnZXRKc29uUnBjSWRWYWxpZGF0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IHsgcGVybWl0RW1wdHlTdHJpbmcsIHBlcm1pdEZyYWN0aW9ucywgcGVybWl0TnVsbCB9ID0gT2JqZWN0LmFzc2lnbih7IHBlcm1pdEVtcHR5U3RyaW5nOiB0cnVlLCBwZXJtaXRGcmFjdGlvbnM6IGZhbHNlLCBwZXJtaXROdWxsOiB0cnVlIH0sIG9wdGlvbnMpO1xuICAgIC8qKlxuICAgICAqIFR5cGUgZ3VhcmQgZm9yIHtAbGluayBKc29uUnBjSWR9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIEpTT04tUlBDIElEIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIElEIGlzIHZhbGlkIHBlciB0aGUgb3B0aW9ucyBnaXZlbiB0byB0aGVcbiAgICAgKiBmYWN0b3J5LlxuICAgICAqL1xuICAgIGNvbnN0IGlzVmFsaWRKc29uUnBjSWQgPSAoaWQpID0+IHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oKHR5cGVvZiBpZCA9PT0gJ251bWJlcicgJiYgKHBlcm1pdEZyYWN0aW9ucyB8fCBOdW1iZXIuaXNJbnRlZ2VyKGlkKSkpIHx8XG4gICAgICAgICAgICAodHlwZW9mIGlkID09PSAnc3RyaW5nJyAmJiAocGVybWl0RW1wdHlTdHJpbmcgfHwgaWQubGVuZ3RoID4gMCkpIHx8XG4gICAgICAgICAgICAocGVybWl0TnVsbCAmJiBpZCA9PT0gbnVsbCkpO1xuICAgIH07XG4gICAgcmV0dXJuIGlzVmFsaWRKc29uUnBjSWQ7XG59XG5leHBvcnRzLmdldEpzb25ScGNJZFZhbGlkYXRvciA9IGdldEpzb25ScGNJZFZhbGlkYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzb24uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0SnNvblJwY0lkVmFsaWRhdG9yIiwiYXNzZXJ0SXNKc29uUnBjRXJyb3IiLCJpc0pzb25ScGNFcnJvciIsImFzc2VydElzSnNvblJwY0ZhaWx1cmUiLCJpc0pzb25ScGNGYWlsdXJlIiwiYXNzZXJ0SXNKc29uUnBjU3VjY2VzcyIsImlzSnNvblJwY1N1Y2Nlc3MiLCJhc3NlcnRJc0pzb25ScGNSZXNwb25zZSIsImlzSnNvblJwY1Jlc3BvbnNlIiwiYXNzZXJ0SXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlIiwiaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlIiwiSnNvblJwY1Jlc3BvbnNlU3RydWN0IiwiSnNvblJwY0ZhaWx1cmVTdHJ1Y3QiLCJKc29uUnBjU3VjY2Vzc1N0cnVjdCIsIlBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QiLCJhc3NlcnRJc0pzb25ScGNSZXF1ZXN0IiwiaXNKc29uUnBjUmVxdWVzdCIsImFzc2VydElzSnNvblJwY05vdGlmaWNhdGlvbiIsImlzSnNvblJwY05vdGlmaWNhdGlvbiIsIkpzb25ScGNOb3RpZmljYXRpb25TdHJ1Y3QiLCJKc29uUnBjUmVxdWVzdFN0cnVjdCIsIkpzb25ScGNQYXJhbXNTdHJ1Y3QiLCJKc29uUnBjRXJyb3JTdHJ1Y3QiLCJKc29uUnBjSWRTdHJ1Y3QiLCJKc29uUnBjVmVyc2lvblN0cnVjdCIsImpzb25ycGMyIiwiZ2V0SnNvblNpemUiLCJpc1ZhbGlkSnNvbiIsIkpzb25TdHJ1Y3QiLCJVbnNhZmVKc29uU3RydWN0Iiwic3VwZXJzdHJ1Y3RfMSIsInJlcXVpcmUiLCJhc3NlcnRfMSIsImZpbml0ZU51bWJlciIsImRlZmluZSIsImlzIiwibnVtYmVyIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJ1bmlvbiIsImxpdGVyYWwiLCJib29sZWFuIiwic3RyaW5nIiwiYXJyYXkiLCJsYXp5IiwicmVjb3JkIiwiY29udGV4dCIsImNoZWNrU3RydWN0IiwiaW5uZXJWYWx1ZSIsInN0cnVjdCIsIml0ZXJhdG9yIiwidmFsaWRhdG9yIiwiZXJyb3JzIiwibGVuZ3RoIiwidW5zYWZlUmVzdWx0IiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiZXJyb3IiLCJSYW5nZUVycm9yIiwiYXNzZXJ0U3RydWN0IiwianNvbiIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiYnl0ZUxlbmd0aCIsIm51bGxhYmxlIiwib2JqZWN0IiwiY29kZSIsImludGVnZXIiLCJtZXNzYWdlIiwiZGF0YSIsIm9wdGlvbmFsIiwic3RhY2siLCJpZCIsImpzb25ycGMiLCJtZXRob2QiLCJwYXJhbXMiLCJvbWl0IiwiRXJyb3JXcmFwcGVyIiwicmVzdWx0IiwidW5rbm93biIsInJlc3BvbnNlIiwib3B0aW9ucyIsInBlcm1pdEVtcHR5U3RyaW5nIiwicGVybWl0RnJhY3Rpb25zIiwicGVybWl0TnVsbCIsImFzc2lnbiIsImlzVmFsaWRKc29uUnBjSWQiLCJCb29sZWFuIiwiaXNJbnRlZ2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/keyring.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/keyring.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n})); //# sourceMappingURL=keyring.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2tleXJpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUMsRUFDN0QsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2l0aC1uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3Qva2V5cmluZy5qcz9hYjA0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5cmluZy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/keyring.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/logging.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/logging.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createModuleLogger = exports.createProjectLogger = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\"));\nconst globalLogger = (0, debug_1.default)(\"metamask\");\n/**\n * Creates a logger via the `debug` library whose log messages will be tagged\n * using the name of your project. By default, such messages will be\n * suppressed, but you can reveal them by setting the `DEBUG` environment\n * variable to `metamask:<projectName>`. You can also set this variable to\n * `metamask:*` if you want to see log messages from all MetaMask projects that\n * are also using this function to create their loggers.\n *\n * @param projectName - The name of your project. This should be the name of\n * your NPM package if you're developing one.\n * @returns An instance of `debug`.\n */ function createProjectLogger(projectName) {\n    return globalLogger.extend(projectName);\n}\nexports.createProjectLogger = createProjectLogger;\n/**\n * Creates a logger via the `debug` library which is derived from the logger for\n * the whole project whose log messages will be tagged using the name of your\n * module. By default, such messages will be suppressed, but you can reveal them\n * by setting the `DEBUG` environment variable to\n * `metamask:<projectName>:<moduleName>`. You can also set this variable to\n * `metamask:<projectName>:*` if you want to see log messages from the project,\n * or `metamask:*` if you want to see log messages from all MetaMask projects.\n *\n * @param projectLogger - The logger created via {@link createProjectLogger}.\n * @param moduleName - The name of your module. You could use the name of the\n * file where you're using this logger or some other name.\n * @returns An instance of `debug`.\n */ function createModuleLogger(projectLogger, moduleName) {\n    return projectLogger.extend(moduleName);\n}\nexports.createModuleLogger = createModuleLogger; //# sourceMappingURL=logging.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2xvZ2dpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQUssU0FBVUMsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQUUsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDBCQUEwQixHQUFHQSwyQkFBMkIsR0FBRyxLQUFLO0FBQ2hFLE1BQU1JLFVBQVVULGdCQUFnQlUsbUJBQU9BLENBQUMsc0RBQU87QUFDL0MsTUFBTUMsZUFBZSxDQUFDLEdBQUdGLFFBQVFHLE9BQU8sRUFBRTtBQUMxQzs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELFNBQVNKLG9CQUFvQkssV0FBVztJQUNwQyxPQUFPRixhQUFhRyxNQUFNLENBQUNEO0FBQy9CO0FBQ0FSLDJCQUEyQixHQUFHRztBQUM5Qjs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ0QsU0FBU0QsbUJBQW1CUSxhQUFhLEVBQUVDLFVBQVU7SUFDakQsT0FBT0QsY0FBY0QsTUFBTSxDQUFDRTtBQUNoQztBQUNBWCwwQkFBMEIsR0FBR0Usb0JBQzdCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dpdGgtbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2xvZ2dpbmcuanM/ZGEwYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlTW9kdWxlTG9nZ2VyID0gZXhwb3J0cy5jcmVhdGVQcm9qZWN0TG9nZ2VyID0gdm9pZCAwO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgZ2xvYmFsTG9nZ2VyID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoJ21ldGFtYXNrJyk7XG4vKipcbiAqIENyZWF0ZXMgYSBsb2dnZXIgdmlhIHRoZSBgZGVidWdgIGxpYnJhcnkgd2hvc2UgbG9nIG1lc3NhZ2VzIHdpbGwgYmUgdGFnZ2VkXG4gKiB1c2luZyB0aGUgbmFtZSBvZiB5b3VyIHByb2plY3QuIEJ5IGRlZmF1bHQsIHN1Y2ggbWVzc2FnZXMgd2lsbCBiZVxuICogc3VwcHJlc3NlZCwgYnV0IHlvdSBjYW4gcmV2ZWFsIHRoZW0gYnkgc2V0dGluZyB0aGUgYERFQlVHYCBlbnZpcm9ubWVudFxuICogdmFyaWFibGUgdG8gYG1ldGFtYXNrOjxwcm9qZWN0TmFtZT5gLiBZb3UgY2FuIGFsc28gc2V0IHRoaXMgdmFyaWFibGUgdG9cbiAqIGBtZXRhbWFzazoqYCBpZiB5b3Ugd2FudCB0byBzZWUgbG9nIG1lc3NhZ2VzIGZyb20gYWxsIE1ldGFNYXNrIHByb2plY3RzIHRoYXRcbiAqIGFyZSBhbHNvIHVzaW5nIHRoaXMgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZWlyIGxvZ2dlcnMuXG4gKlxuICogQHBhcmFtIHByb2plY3ROYW1lIC0gVGhlIG5hbWUgb2YgeW91ciBwcm9qZWN0LiBUaGlzIHNob3VsZCBiZSB0aGUgbmFtZSBvZlxuICogeW91ciBOUE0gcGFja2FnZSBpZiB5b3UncmUgZGV2ZWxvcGluZyBvbmUuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBgZGVidWdgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVQcm9qZWN0TG9nZ2VyKHByb2plY3ROYW1lKSB7XG4gICAgcmV0dXJuIGdsb2JhbExvZ2dlci5leHRlbmQocHJvamVjdE5hbWUpO1xufVxuZXhwb3J0cy5jcmVhdGVQcm9qZWN0TG9nZ2VyID0gY3JlYXRlUHJvamVjdExvZ2dlcjtcbi8qKlxuICogQ3JlYXRlcyBhIGxvZ2dlciB2aWEgdGhlIGBkZWJ1Z2AgbGlicmFyeSB3aGljaCBpcyBkZXJpdmVkIGZyb20gdGhlIGxvZ2dlciBmb3JcbiAqIHRoZSB3aG9sZSBwcm9qZWN0IHdob3NlIGxvZyBtZXNzYWdlcyB3aWxsIGJlIHRhZ2dlZCB1c2luZyB0aGUgbmFtZSBvZiB5b3VyXG4gKiBtb2R1bGUuIEJ5IGRlZmF1bHQsIHN1Y2ggbWVzc2FnZXMgd2lsbCBiZSBzdXBwcmVzc2VkLCBidXQgeW91IGNhbiByZXZlYWwgdGhlbVxuICogYnkgc2V0dGluZyB0aGUgYERFQlVHYCBlbnZpcm9ubWVudCB2YXJpYWJsZSB0b1xuICogYG1ldGFtYXNrOjxwcm9qZWN0TmFtZT46PG1vZHVsZU5hbWU+YC4gWW91IGNhbiBhbHNvIHNldCB0aGlzIHZhcmlhYmxlIHRvXG4gKiBgbWV0YW1hc2s6PHByb2plY3ROYW1lPjoqYCBpZiB5b3Ugd2FudCB0byBzZWUgbG9nIG1lc3NhZ2VzIGZyb20gdGhlIHByb2plY3QsXG4gKiBvciBgbWV0YW1hc2s6KmAgaWYgeW91IHdhbnQgdG8gc2VlIGxvZyBtZXNzYWdlcyBmcm9tIGFsbCBNZXRhTWFzayBwcm9qZWN0cy5cbiAqXG4gKiBAcGFyYW0gcHJvamVjdExvZ2dlciAtIFRoZSBsb2dnZXIgY3JlYXRlZCB2aWEge0BsaW5rIGNyZWF0ZVByb2plY3RMb2dnZXJ9LlxuICogQHBhcmFtIG1vZHVsZU5hbWUgLSBUaGUgbmFtZSBvZiB5b3VyIG1vZHVsZS4gWW91IGNvdWxkIHVzZSB0aGUgbmFtZSBvZiB0aGVcbiAqIGZpbGUgd2hlcmUgeW91J3JlIHVzaW5nIHRoaXMgbG9nZ2VyIG9yIHNvbWUgb3RoZXIgbmFtZS5cbiAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIGBkZWJ1Z2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1vZHVsZUxvZ2dlcihwcm9qZWN0TG9nZ2VyLCBtb2R1bGVOYW1lKSB7XG4gICAgcmV0dXJuIHByb2plY3RMb2dnZXIuZXh0ZW5kKG1vZHVsZU5hbWUpO1xufVxuZXhwb3J0cy5jcmVhdGVNb2R1bGVMb2dnZXIgPSBjcmVhdGVNb2R1bGVMb2dnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnaW5nLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjcmVhdGVNb2R1bGVMb2dnZXIiLCJjcmVhdGVQcm9qZWN0TG9nZ2VyIiwiZGVidWdfMSIsInJlcXVpcmUiLCJnbG9iYWxMb2dnZXIiLCJkZWZhdWx0IiwicHJvamVjdE5hbWUiLCJleHRlbmQiLCJwcm9qZWN0TG9nZ2VyIiwibW9kdWxlTmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/logging.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/misc.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/misc.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n//\n// Types\n//\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.calculateNumberSize = exports.calculateStringSize = exports.isASCII = exports.isPlainObject = exports.ESCAPE_CHARACTERS_REGEXP = exports.JsonSize = exports.hasProperty = exports.isObject = exports.isNullOrUndefined = exports.isNonEmptyArray = void 0;\n//\n// Type Guards\n//\n/**\n * A {@link NonEmptyArray} type guard.\n *\n * @template Element - The non-empty array member type.\n * @param value - The value to check.\n * @returns Whether the value is a non-empty array.\n */ function isNonEmptyArray(value) {\n    return Array.isArray(value) && value.length > 0;\n}\nexports.isNonEmptyArray = isNonEmptyArray;\n/**\n * Type guard for \"nullishness\".\n *\n * @param value - Any value.\n * @returns `true` if the value is null or undefined, `false` otherwise.\n */ function isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n/**\n * A type guard for {@link RuntimeObject}.\n *\n * @param value - The value to check.\n * @returns Whether the specified value has a runtime type of `object` and is\n * neither `null` nor an `Array`.\n */ function isObject(value) {\n    return Boolean(value) && typeof value === \"object\" && !Array.isArray(value);\n}\nexports.isObject = isObject;\n//\n// Other utility functions\n//\n/**\n * A type guard for ensuring an object has a property.\n *\n * @param objectToCheck - The object to check.\n * @param name - The property name to check for.\n * @returns Whether the specified object has an own property with the specified\n * name, regardless of whether it is enumerable or not.\n */ const hasProperty = (objectToCheck, name)=>Object.hasOwnProperty.call(objectToCheck, name);\nexports.hasProperty = hasProperty;\n/**\n * Predefined sizes (in Bytes) of specific parts of JSON structure.\n */ var JsonSize;\n(function(JsonSize) {\n    JsonSize[JsonSize[\"Null\"] = 4] = \"Null\";\n    JsonSize[JsonSize[\"Comma\"] = 1] = \"Comma\";\n    JsonSize[JsonSize[\"Wrapper\"] = 1] = \"Wrapper\";\n    JsonSize[JsonSize[\"True\"] = 4] = \"True\";\n    JsonSize[JsonSize[\"False\"] = 5] = \"False\";\n    JsonSize[JsonSize[\"Quote\"] = 1] = \"Quote\";\n    JsonSize[JsonSize[\"Colon\"] = 1] = \"Colon\";\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    JsonSize[JsonSize[\"Date\"] = 24] = \"Date\";\n})(JsonSize = exports.JsonSize || (exports.JsonSize = {}));\n/**\n * Regular expression with pattern matching for (special) escaped characters.\n */ exports.ESCAPE_CHARACTERS_REGEXP = /\"|\\\\|\\n|\\r|\\t/gu;\n/**\n * Check if the value is plain object.\n *\n * @param value - Value to be checked.\n * @returns True if an object is the plain JavaScript object,\n * false if the object is not plain (e.g. function).\n */ function isPlainObject(value) {\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    try {\n        let proto = value;\n        while(Object.getPrototypeOf(proto) !== null){\n            proto = Object.getPrototypeOf(proto);\n        }\n        return Object.getPrototypeOf(value) === proto;\n    } catch (_) {\n        return false;\n    }\n}\nexports.isPlainObject = isPlainObject;\n/**\n * Check if character is ASCII.\n *\n * @param character - Character.\n * @returns True if a character code is ASCII, false if not.\n */ function isASCII(character) {\n    return character.charCodeAt(0) <= 127;\n}\nexports.isASCII = isASCII;\n/**\n * Calculate string size.\n *\n * @param value - String value to calculate size.\n * @returns Number of bytes used to store whole string value.\n */ function calculateStringSize(value) {\n    var _a;\n    const size = value.split(\"\").reduce((total, character)=>{\n        if (isASCII(character)) {\n            return total + 1;\n        }\n        return total + 2;\n    }, 0);\n    // Also detect characters that need backslash escape\n    return size + ((_a = value.match(exports.ESCAPE_CHARACTERS_REGEXP)) !== null && _a !== void 0 ? _a : []).length;\n}\nexports.calculateStringSize = calculateStringSize;\n/**\n * Calculate size of a number ofter JSON serialization.\n *\n * @param value - Number value to calculate size.\n * @returns Number of bytes used to store whole number in JSON.\n */ function calculateNumberSize(value) {\n    return value.toString().length;\n}\nexports.calculateNumberSize = calculateNumberSize; //# sourceMappingURL=misc.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L21pc2MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixFQUFFO0FBQ0YsUUFBUTtBQUNSLEVBQUU7QUFDRkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDJCQUEyQixHQUFHQSwyQkFBMkIsR0FBR0EsZUFBZSxHQUFHQSxxQkFBcUIsR0FBR0EsZ0NBQWdDLEdBQUdBLGdCQUFnQixHQUFHQSxtQkFBbUIsR0FBR0EsZ0JBQWdCLEdBQUdBLHlCQUF5QixHQUFHQSx1QkFBdUIsR0FBRyxLQUFLO0FBQ2hRLEVBQUU7QUFDRixjQUFjO0FBQ2QsRUFBRTtBQUNGOzs7Ozs7Q0FNQyxHQUNELFNBQVNXLGdCQUFnQlYsS0FBSztJQUMxQixPQUFPVyxNQUFNQyxPQUFPLENBQUNaLFVBQVVBLE1BQU1hLE1BQU0sR0FBRztBQUNsRDtBQUNBZCx1QkFBdUIsR0FBR1c7QUFDMUI7Ozs7O0NBS0MsR0FDRCxTQUFTRCxrQkFBa0JULEtBQUs7SUFDNUIsT0FBT0EsVUFBVSxRQUFRQSxVQUFVYztBQUN2QztBQUNBZix5QkFBeUIsR0FBR1U7QUFDNUI7Ozs7OztDQU1DLEdBQ0QsU0FBU0QsU0FBU1IsS0FBSztJQUNuQixPQUFPZSxRQUFRZixVQUFVLE9BQU9BLFVBQVUsWUFBWSxDQUFDVyxNQUFNQyxPQUFPLENBQUNaO0FBQ3pFO0FBQ0FELGdCQUFnQixHQUFHUztBQUNuQixFQUFFO0FBQ0YsMEJBQTBCO0FBQzFCLEVBQUU7QUFDRjs7Ozs7OztDQU9DLEdBQ0QsTUFBTUQsY0FBYyxDQUFDUyxlQUFlQyxPQUFTcEIsT0FBT3FCLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSCxlQUFlQztBQUN2RmxCLG1CQUFtQixHQUFHUTtBQUN0Qjs7Q0FFQyxHQUNELElBQUlEO0FBQ0gsVUFBVUEsUUFBUTtJQUNmQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0lBQ2pDQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQ2xDQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQ3BDQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0lBQ2pDQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQ2xDQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQ2xDQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQ2xDLHdEQUF3RDtJQUN4REEsUUFBUSxDQUFDQSxRQUFRLENBQUMsT0FBTyxHQUFHLEdBQUcsR0FBRztBQUN0QyxHQUFHQSxXQUFXUCxRQUFRTyxRQUFRLElBQUtQLENBQUFBLGdCQUFnQixHQUFHLENBQUM7QUFDdkQ7O0NBRUMsR0FDREEsZ0NBQWdDLEdBQUc7QUFDbkM7Ozs7OztDQU1DLEdBQ0QsU0FBU0ssY0FBY0osS0FBSztJQUN4QixJQUFJLE9BQU9BLFVBQVUsWUFBWUEsVUFBVSxNQUFNO1FBQzdDLE9BQU87SUFDWDtJQUNBLElBQUk7UUFDQSxJQUFJb0IsUUFBUXBCO1FBQ1osTUFBT0gsT0FBT3dCLGNBQWMsQ0FBQ0QsV0FBVyxLQUFNO1lBQzFDQSxRQUFRdkIsT0FBT3dCLGNBQWMsQ0FBQ0Q7UUFDbEM7UUFDQSxPQUFPdkIsT0FBT3dCLGNBQWMsQ0FBQ3JCLFdBQVdvQjtJQUM1QyxFQUNBLE9BQU9FLEdBQUc7UUFDTixPQUFPO0lBQ1g7QUFDSjtBQUNBdkIscUJBQXFCLEdBQUdLO0FBQ3hCOzs7OztDQUtDLEdBQ0QsU0FBU0QsUUFBUW9CLFNBQVM7SUFDdEIsT0FBT0EsVUFBVUMsVUFBVSxDQUFDLE1BQU07QUFDdEM7QUFDQXpCLGVBQWUsR0FBR0k7QUFDbEI7Ozs7O0NBS0MsR0FDRCxTQUFTRCxvQkFBb0JGLEtBQUs7SUFDOUIsSUFBSXlCO0lBQ0osTUFBTUMsT0FBTzFCLE1BQU0yQixLQUFLLENBQUMsSUFBSUMsTUFBTSxDQUFDLENBQUNDLE9BQU9OO1FBQ3hDLElBQUlwQixRQUFRb0IsWUFBWTtZQUNwQixPQUFPTSxRQUFRO1FBQ25CO1FBQ0EsT0FBT0EsUUFBUTtJQUNuQixHQUFHO0lBQ0gsb0RBQW9EO0lBQ3BELE9BQU9ILE9BQU8sQ0FBQyxDQUFDRCxLQUFLekIsTUFBTThCLEtBQUssQ0FBQy9CLFFBQVFNLHdCQUF3QixPQUFPLFFBQVFvQixPQUFPLEtBQUssSUFBSUEsS0FBSyxFQUFFLEVBQUVaLE1BQU07QUFDbkg7QUFDQWQsMkJBQTJCLEdBQUdHO0FBQzlCOzs7OztDQUtDLEdBQ0QsU0FBU0Qsb0JBQW9CRCxLQUFLO0lBQzlCLE9BQU9BLE1BQU0rQixRQUFRLEdBQUdsQixNQUFNO0FBQ2xDO0FBQ0FkLDJCQUEyQixHQUFHRSxxQkFDOUIsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2l0aC1uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbWlzYy5qcz9kMjU5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy9cbi8vIFR5cGVzXG4vL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYWxjdWxhdGVOdW1iZXJTaXplID0gZXhwb3J0cy5jYWxjdWxhdGVTdHJpbmdTaXplID0gZXhwb3J0cy5pc0FTQ0lJID0gZXhwb3J0cy5pc1BsYWluT2JqZWN0ID0gZXhwb3J0cy5FU0NBUEVfQ0hBUkFDVEVSU19SRUdFWFAgPSBleHBvcnRzLkpzb25TaXplID0gZXhwb3J0cy5oYXNQcm9wZXJ0eSA9IGV4cG9ydHMuaXNPYmplY3QgPSBleHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gZXhwb3J0cy5pc05vbkVtcHR5QXJyYXkgPSB2b2lkIDA7XG4vL1xuLy8gVHlwZSBHdWFyZHNcbi8vXG4vKipcbiAqIEEge0BsaW5rIE5vbkVtcHR5QXJyYXl9IHR5cGUgZ3VhcmQuXG4gKlxuICogQHRlbXBsYXRlIEVsZW1lbnQgLSBUaGUgbm9uLWVtcHR5IGFycmF5IG1lbWJlciB0eXBlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSBub24tZW1wdHkgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGlzTm9uRW1wdHlBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwO1xufVxuZXhwb3J0cy5pc05vbkVtcHR5QXJyYXkgPSBpc05vbkVtcHR5QXJyYXk7XG4vKipcbiAqIFR5cGUgZ3VhcmQgZm9yIFwibnVsbGlzaG5lc3NcIi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcbi8qKlxuICogQSB0eXBlIGd1YXJkIGZvciB7QGxpbmsgUnVudGltZU9iamVjdH0uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgc3BlY2lmaWVkIHZhbHVlIGhhcyBhIHJ1bnRpbWUgdHlwZSBvZiBgb2JqZWN0YCBhbmQgaXNcbiAqIG5laXRoZXIgYG51bGxgIG5vciBhbiBgQXJyYXlgLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiBCb29sZWFuKHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbi8vXG4vLyBPdGhlciB1dGlsaXR5IGZ1bmN0aW9uc1xuLy9cbi8qKlxuICogQSB0eXBlIGd1YXJkIGZvciBlbnN1cmluZyBhbiBvYmplY3QgaGFzIGEgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIG9iamVjdFRvQ2hlY2sgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHBhcmFtIG5hbWUgLSBUaGUgcHJvcGVydHkgbmFtZSB0byBjaGVjayBmb3IuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGhhcyBhbiBvd24gcHJvcGVydHkgd2l0aCB0aGUgc3BlY2lmaWVkXG4gKiBuYW1lLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgaXQgaXMgZW51bWVyYWJsZSBvciBub3QuXG4gKi9cbmNvbnN0IGhhc1Byb3BlcnR5ID0gKG9iamVjdFRvQ2hlY2ssIG5hbWUpID0+IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdFRvQ2hlY2ssIG5hbWUpO1xuZXhwb3J0cy5oYXNQcm9wZXJ0eSA9IGhhc1Byb3BlcnR5O1xuLyoqXG4gKiBQcmVkZWZpbmVkIHNpemVzIChpbiBCeXRlcykgb2Ygc3BlY2lmaWMgcGFydHMgb2YgSlNPTiBzdHJ1Y3R1cmUuXG4gKi9cbnZhciBKc29uU2l6ZTtcbihmdW5jdGlvbiAoSnNvblNpemUpIHtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIk51bGxcIl0gPSA0XSA9IFwiTnVsbFwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiQ29tbWFcIl0gPSAxXSA9IFwiQ29tbWFcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIldyYXBwZXJcIl0gPSAxXSA9IFwiV3JhcHBlclwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiVHJ1ZVwiXSA9IDRdID0gXCJUcnVlXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJGYWxzZVwiXSA9IDVdID0gXCJGYWxzZVwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiUXVvdGVcIl0gPSAxXSA9IFwiUXVvdGVcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIkNvbG9uXCJdID0gMV0gPSBcIkNvbG9uXCI7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1zaGFkb3dcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIkRhdGVcIl0gPSAyNF0gPSBcIkRhdGVcIjtcbn0pKEpzb25TaXplID0gZXhwb3J0cy5Kc29uU2l6ZSB8fCAoZXhwb3J0cy5Kc29uU2l6ZSA9IHt9KSk7XG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB3aXRoIHBhdHRlcm4gbWF0Y2hpbmcgZm9yIChzcGVjaWFsKSBlc2NhcGVkIGNoYXJhY3RlcnMuXG4gKi9cbmV4cG9ydHMuRVNDQVBFX0NIQVJBQ1RFUlNfUkVHRVhQID0gL1wifFxcXFx8XFxufFxccnxcXHQvZ3U7XG4vKipcbiAqIENoZWNrIGlmIHRoZSB2YWx1ZSBpcyBwbGFpbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIFRydWUgaWYgYW4gb2JqZWN0IGlzIHRoZSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCxcbiAqIGZhbHNlIGlmIHRoZSBvYmplY3QgaXMgbm90IHBsYWluIChlLmcuIGZ1bmN0aW9uKS5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IHByb3RvID0gdmFsdWU7XG4gICAgICAgIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IHByb3RvO1xuICAgIH1cbiAgICBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbi8qKlxuICogQ2hlY2sgaWYgY2hhcmFjdGVyIGlzIEFTQ0lJLlxuICpcbiAqIEBwYXJhbSBjaGFyYWN0ZXIgLSBDaGFyYWN0ZXIuXG4gKiBAcmV0dXJucyBUcnVlIGlmIGEgY2hhcmFjdGVyIGNvZGUgaXMgQVNDSUksIGZhbHNlIGlmIG5vdC5cbiAqL1xuZnVuY3Rpb24gaXNBU0NJSShjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gY2hhcmFjdGVyLmNoYXJDb2RlQXQoMCkgPD0gMTI3O1xufVxuZXhwb3J0cy5pc0FTQ0lJID0gaXNBU0NJSTtcbi8qKlxuICogQ2FsY3VsYXRlIHN0cmluZyBzaXplLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFN0cmluZyB2YWx1ZSB0byBjYWxjdWxhdGUgc2l6ZS5cbiAqIEByZXR1cm5zIE51bWJlciBvZiBieXRlcyB1c2VkIHRvIHN0b3JlIHdob2xlIHN0cmluZyB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlU3RyaW5nU2l6ZSh2YWx1ZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBzaXplID0gdmFsdWUuc3BsaXQoJycpLnJlZHVjZSgodG90YWwsIGNoYXJhY3RlcikgPT4ge1xuICAgICAgICBpZiAoaXNBU0NJSShjaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdG90YWwgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbCArIDI7XG4gICAgfSwgMCk7XG4gICAgLy8gQWxzbyBkZXRlY3QgY2hhcmFjdGVycyB0aGF0IG5lZWQgYmFja3NsYXNoIGVzY2FwZVxuICAgIHJldHVybiBzaXplICsgKChfYSA9IHZhbHVlLm1hdGNoKGV4cG9ydHMuRVNDQVBFX0NIQVJBQ1RFUlNfUkVHRVhQKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pLmxlbmd0aDtcbn1cbmV4cG9ydHMuY2FsY3VsYXRlU3RyaW5nU2l6ZSA9IGNhbGN1bGF0ZVN0cmluZ1NpemU7XG4vKipcbiAqIENhbGN1bGF0ZSBzaXplIG9mIGEgbnVtYmVyIG9mdGVyIEpTT04gc2VyaWFsaXphdGlvbi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBOdW1iZXIgdmFsdWUgdG8gY2FsY3VsYXRlIHNpemUuXG4gKiBAcmV0dXJucyBOdW1iZXIgb2YgYnl0ZXMgdXNlZCB0byBzdG9yZSB3aG9sZSBudW1iZXIgaW4gSlNPTi5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlTnVtYmVyU2l6ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpLmxlbmd0aDtcbn1cbmV4cG9ydHMuY2FsY3VsYXRlTnVtYmVyU2l6ZSA9IGNhbGN1bGF0ZU51bWJlclNpemU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1taXNjLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNhbGN1bGF0ZU51bWJlclNpemUiLCJjYWxjdWxhdGVTdHJpbmdTaXplIiwiaXNBU0NJSSIsImlzUGxhaW5PYmplY3QiLCJFU0NBUEVfQ0hBUkFDVEVSU19SRUdFWFAiLCJKc29uU2l6ZSIsImhhc1Byb3BlcnR5IiwiaXNPYmplY3QiLCJpc051bGxPclVuZGVmaW5lZCIsImlzTm9uRW1wdHlBcnJheSIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsInVuZGVmaW5lZCIsIkJvb2xlYW4iLCJvYmplY3RUb0NoZWNrIiwibmFtZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJfIiwiY2hhcmFjdGVyIiwiY2hhckNvZGVBdCIsIl9hIiwic2l6ZSIsInNwbGl0IiwicmVkdWNlIiwidG90YWwiLCJtYXRjaCIsInRvU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/misc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/number.js":
/*!************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/number.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.hexToBigInt = exports.hexToNumber = exports.bigIntToHex = exports.numberToHex = void 0;\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js\");\nconst hex_1 = __webpack_require__(/*! ./hex */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/hex.js\");\n/**\n * Convert a number to a hexadecimal string. This verifies that the number is a\n * non-negative safe integer.\n *\n * To convert a `bigint` to a hexadecimal string instead, use\n * {@link bigIntToHex}.\n *\n * @example\n * ```typescript\n * numberToHex(0); // '0x0'\n * numberToHex(1); // '0x1'\n * numberToHex(16); // '0x10'\n * ```\n * @param value - The number to convert to a hexadecimal string.\n * @returns The hexadecimal string, with the \"0x\"-prefix.\n * @throws If the number is not a non-negative safe integer.\n */ const numberToHex = (value)=>{\n    (0, assert_1.assert)(typeof value === \"number\", \"Value must be a number.\");\n    (0, assert_1.assert)(value >= 0, \"Value must be a non-negative number.\");\n    (0, assert_1.assert)(Number.isSafeInteger(value), \"Value is not a safe integer. Use `bigIntToHex` instead.\");\n    return (0, hex_1.add0x)(value.toString(16));\n};\nexports.numberToHex = numberToHex;\n/**\n * Convert a `bigint` to a hexadecimal string. This verifies that the `bigint`\n * is a non-negative integer.\n *\n * To convert a number to a hexadecimal string instead, use {@link numberToHex}.\n *\n * @example\n * ```typescript\n * bigIntToHex(0n); // '0x0'\n * bigIntToHex(1n); // '0x1'\n * bigIntToHex(16n); // '0x10'\n * ```\n * @param value - The `bigint` to convert to a hexadecimal string.\n * @returns The hexadecimal string, with the \"0x\"-prefix.\n * @throws If the `bigint` is not a non-negative integer.\n */ const bigIntToHex = (value)=>{\n    (0, assert_1.assert)(typeof value === \"bigint\", \"Value must be a bigint.\");\n    (0, assert_1.assert)(value >= 0, \"Value must be a non-negative bigint.\");\n    return (0, hex_1.add0x)(value.toString(16));\n};\nexports.bigIntToHex = bigIntToHex;\n/**\n * Convert a hexadecimal string to a number. This verifies that the string is a\n * valid hex string, and that the resulting number is a safe integer. Both\n * \"0x\"-prefixed and unprefixed strings are supported.\n *\n * To convert a hexadecimal string to a `bigint` instead, use\n * {@link hexToBigInt}.\n *\n * @example\n * ```typescript\n * hexToNumber('0x0'); // 0\n * hexToNumber('0x1'); // 1\n * hexToNumber('0x10'); // 16\n * ```\n * @param value - The hexadecimal string to convert to a number.\n * @returns The number.\n * @throws If the value is not a valid hexadecimal string, or if the resulting\n * number is not a safe integer.\n */ const hexToNumber = (value)=>{\n    (0, hex_1.assertIsHexString)(value);\n    // `parseInt` accepts values without the \"0x\"-prefix, whereas `Number` does\n    // not. Using this is slightly faster than `Number(add0x(value))`.\n    const numberValue = parseInt(value, 16);\n    (0, assert_1.assert)(Number.isSafeInteger(numberValue), \"Value is not a safe integer. Use `hexToBigInt` instead.\");\n    return numberValue;\n};\nexports.hexToNumber = hexToNumber;\n/**\n * Convert a hexadecimal string to a `bigint`. This verifies that the string is\n * a valid hex string. Both \"0x\"-prefixed and unprefixed strings are supported.\n *\n * To convert a hexadecimal string to a number instead, use {@link hexToNumber}.\n *\n * @example\n * ```typescript\n * hexToBigInt('0x0'); // 0n\n * hexToBigInt('0x1'); // 1n\n * hexToBigInt('0x10'); // 16n\n * ```\n * @param value - The hexadecimal string to convert to a `bigint`.\n * @returns The `bigint`.\n * @throws If the value is not a valid hexadecimal string.\n */ const hexToBigInt = (value)=>{\n    (0, hex_1.assertIsHexString)(value);\n    // The `BigInt` constructor requires the \"0x\"-prefix to parse a hex string.\n    return BigInt((0, hex_1.add0x)(value));\n};\nexports.hexToBigInt = hexToBigInt; //# sourceMappingURL=number.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L251bWJlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUdBLG1CQUFtQixHQUFHQSxtQkFBbUIsR0FBR0EsbUJBQW1CLEdBQUcsS0FBSztBQUM3RixNQUFNTSxXQUFXQyxtQkFBT0EsQ0FBQyxvR0FBVTtBQUNuQyxNQUFNQyxRQUFRRCxtQkFBT0EsQ0FBQyw4RkFBTztBQUM3Qjs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNELE1BQU1GLGNBQWMsQ0FBQ0o7SUFDaEIsSUFBR0ssU0FBU0csTUFBTSxFQUFFLE9BQU9SLFVBQVUsVUFBVTtJQUMvQyxJQUFHSyxTQUFTRyxNQUFNLEVBQUVSLFNBQVMsR0FBRztJQUNoQyxJQUFHSyxTQUFTRyxNQUFNLEVBQUVDLE9BQU9DLGFBQWEsQ0FBQ1YsUUFBUTtJQUNsRCxPQUFPLENBQUMsR0FBR08sTUFBTUksS0FBSyxFQUFFWCxNQUFNWSxRQUFRLENBQUM7QUFDM0M7QUFDQWIsbUJBQW1CLEdBQUdLO0FBQ3RCOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNELE1BQU1ELGNBQWMsQ0FBQ0g7SUFDaEIsSUFBR0ssU0FBU0csTUFBTSxFQUFFLE9BQU9SLFVBQVUsVUFBVTtJQUMvQyxJQUFHSyxTQUFTRyxNQUFNLEVBQUVSLFNBQVMsR0FBRztJQUNqQyxPQUFPLENBQUMsR0FBR08sTUFBTUksS0FBSyxFQUFFWCxNQUFNWSxRQUFRLENBQUM7QUFDM0M7QUFDQWIsbUJBQW1CLEdBQUdJO0FBQ3RCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FDRCxNQUFNRCxjQUFjLENBQUNGO0lBQ2hCLElBQUdPLE1BQU1NLGlCQUFpQixFQUFFYjtJQUM3QiwyRUFBMkU7SUFDM0Usa0VBQWtFO0lBQ2xFLE1BQU1jLGNBQWNDLFNBQVNmLE9BQU87SUFDbkMsSUFBR0ssU0FBU0csTUFBTSxFQUFFQyxPQUFPQyxhQUFhLENBQUNJLGNBQWM7SUFDeEQsT0FBT0E7QUFDWDtBQUNBZixtQkFBbUIsR0FBR0c7QUFDdEI7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsTUFBTUQsY0FBYyxDQUFDRDtJQUNoQixJQUFHTyxNQUFNTSxpQkFBaUIsRUFBRWI7SUFDN0IsMkVBQTJFO0lBQzNFLE9BQU9nQixPQUFPLENBQUMsR0FBR1QsTUFBTUksS0FBSyxFQUFFWDtBQUNuQztBQUNBRCxtQkFBbUIsR0FBR0UsYUFDdEIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2l0aC1uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbnVtYmVyLmpzPzM2M2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhleFRvQmlnSW50ID0gZXhwb3J0cy5oZXhUb051bWJlciA9IGV4cG9ydHMuYmlnSW50VG9IZXggPSBleHBvcnRzLm51bWJlclRvSGV4ID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG5jb25zdCBoZXhfMSA9IHJlcXVpcmUoXCIuL2hleFwiKTtcbi8qKlxuICogQ29udmVydCBhIG51bWJlciB0byBhIGhleGFkZWNpbWFsIHN0cmluZy4gVGhpcyB2ZXJpZmllcyB0aGF0IHRoZSBudW1iZXIgaXMgYVxuICogbm9uLW5lZ2F0aXZlIHNhZmUgaW50ZWdlci5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgYGJpZ2ludGAgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcgaW5zdGVhZCwgdXNlXG4gKiB7QGxpbmsgYmlnSW50VG9IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBudW1iZXJUb0hleCgwKTsgLy8gJzB4MCdcbiAqIG51bWJlclRvSGV4KDEpOyAvLyAnMHgxJ1xuICogbnVtYmVyVG9IZXgoMTYpOyAvLyAnMHgxMCdcbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIG51bWJlciB0byBjb252ZXJ0IHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIGhleGFkZWNpbWFsIHN0cmluZywgd2l0aCB0aGUgXCIweFwiLXByZWZpeC5cbiAqIEB0aHJvd3MgSWYgdGhlIG51bWJlciBpcyBub3QgYSBub24tbmVnYXRpdmUgc2FmZSBpbnRlZ2VyLlxuICovXG5jb25zdCBudW1iZXJUb0hleCA9ICh2YWx1ZSkgPT4ge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdWYWx1ZSBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHZhbHVlID49IDAsICdWYWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSksICdWYWx1ZSBpcyBub3QgYSBzYWZlIGludGVnZXIuIFVzZSBgYmlnSW50VG9IZXhgIGluc3RlYWQuJyk7XG4gICAgcmV0dXJuICgwLCBoZXhfMS5hZGQweCkodmFsdWUudG9TdHJpbmcoMTYpKTtcbn07XG5leHBvcnRzLm51bWJlclRvSGV4ID0gbnVtYmVyVG9IZXg7XG4vKipcbiAqIENvbnZlcnQgYSBgYmlnaW50YCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy4gVGhpcyB2ZXJpZmllcyB0aGF0IHRoZSBgYmlnaW50YFxuICogaXMgYSBub24tbmVnYXRpdmUgaW50ZWdlci5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgbnVtYmVyIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nIGluc3RlYWQsIHVzZSB7QGxpbmsgbnVtYmVyVG9IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBiaWdJbnRUb0hleCgwbik7IC8vICcweDAnXG4gKiBiaWdJbnRUb0hleCgxbik7IC8vICcweDEnXG4gKiBiaWdJbnRUb0hleCgxNm4pOyAvLyAnMHgxMCdcbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGBiaWdpbnRgIHRvIGNvbnZlcnQgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nLCB3aXRoIHRoZSBcIjB4XCItcHJlZml4LlxuICogQHRocm93cyBJZiB0aGUgYGJpZ2ludGAgaXMgbm90IGEgbm9uLW5lZ2F0aXZlIGludGVnZXIuXG4gKi9cbmNvbnN0IGJpZ0ludFRvSGV4ID0gKHZhbHVlKSA9PiB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JywgJ1ZhbHVlIG11c3QgYmUgYSBiaWdpbnQuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodmFsdWUgPj0gMCwgJ1ZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgYmlnaW50LicpO1xuICAgIHJldHVybiAoMCwgaGV4XzEuYWRkMHgpKHZhbHVlLnRvU3RyaW5nKDE2KSk7XG59O1xuZXhwb3J0cy5iaWdJbnRUb0hleCA9IGJpZ0ludFRvSGV4O1xuLyoqXG4gKiBDb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgbnVtYmVyLiBUaGlzIHZlcmlmaWVzIHRoYXQgdGhlIHN0cmluZyBpcyBhXG4gKiB2YWxpZCBoZXggc3RyaW5nLCBhbmQgdGhhdCB0aGUgcmVzdWx0aW5nIG51bWJlciBpcyBhIHNhZmUgaW50ZWdlci4gQm90aFxuICogXCIweFwiLXByZWZpeGVkIGFuZCB1bnByZWZpeGVkIHN0cmluZ3MgYXJlIHN1cHBvcnRlZC5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgYGJpZ2ludGAgaW5zdGVhZCwgdXNlXG4gKiB7QGxpbmsgaGV4VG9CaWdJbnR9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBoZXhUb051bWJlcignMHgwJyk7IC8vIDBcbiAqIGhleFRvTnVtYmVyKCcweDEnKTsgLy8gMVxuICogaGV4VG9OdW1iZXIoJzB4MTAnKTsgLy8gMTZcbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0IHRvIGEgbnVtYmVyLlxuICogQHJldHVybnMgVGhlIG51bWJlci5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGhleGFkZWNpbWFsIHN0cmluZywgb3IgaWYgdGhlIHJlc3VsdGluZ1xuICogbnVtYmVyIGlzIG5vdCBhIHNhZmUgaW50ZWdlci5cbiAqL1xuY29uc3QgaGV4VG9OdW1iZXIgPSAodmFsdWUpID0+IHtcbiAgICAoMCwgaGV4XzEuYXNzZXJ0SXNIZXhTdHJpbmcpKHZhbHVlKTtcbiAgICAvLyBgcGFyc2VJbnRgIGFjY2VwdHMgdmFsdWVzIHdpdGhvdXQgdGhlIFwiMHhcIi1wcmVmaXgsIHdoZXJlYXMgYE51bWJlcmAgZG9lc1xuICAgIC8vIG5vdC4gVXNpbmcgdGhpcyBpcyBzbGlnaHRseSBmYXN0ZXIgdGhhbiBgTnVtYmVyKGFkZDB4KHZhbHVlKSlgLlxuICAgIGNvbnN0IG51bWJlclZhbHVlID0gcGFyc2VJbnQodmFsdWUsIDE2KTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShOdW1iZXIuaXNTYWZlSW50ZWdlcihudW1iZXJWYWx1ZSksICdWYWx1ZSBpcyBub3QgYSBzYWZlIGludGVnZXIuIFVzZSBgaGV4VG9CaWdJbnRgIGluc3RlYWQuJyk7XG4gICAgcmV0dXJuIG51bWJlclZhbHVlO1xufTtcbmV4cG9ydHMuaGV4VG9OdW1iZXIgPSBoZXhUb051bWJlcjtcbi8qKlxuICogQ29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhIGBiaWdpbnRgLiBUaGlzIHZlcmlmaWVzIHRoYXQgdGhlIHN0cmluZyBpc1xuICogYSB2YWxpZCBoZXggc3RyaW5nLiBCb3RoIFwiMHhcIi1wcmVmaXhlZCBhbmQgdW5wcmVmaXhlZCBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQuXG4gKlxuICogVG8gY29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhIG51bWJlciBpbnN0ZWFkLCB1c2Uge0BsaW5rIGhleFRvTnVtYmVyfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaGV4VG9CaWdJbnQoJzB4MCcpOyAvLyAwblxuICogaGV4VG9CaWdJbnQoJzB4MScpOyAvLyAxblxuICogaGV4VG9CaWdJbnQoJzB4MTAnKTsgLy8gMTZuXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gY29udmVydCB0byBhIGBiaWdpbnRgLlxuICogQHJldHVybnMgVGhlIGBiaWdpbnRgLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5jb25zdCBoZXhUb0JpZ0ludCA9ICh2YWx1ZSkgPT4ge1xuICAgICgwLCBoZXhfMS5hc3NlcnRJc0hleFN0cmluZykodmFsdWUpO1xuICAgIC8vIFRoZSBgQmlnSW50YCBjb25zdHJ1Y3RvciByZXF1aXJlcyB0aGUgXCIweFwiLXByZWZpeCB0byBwYXJzZSBhIGhleCBzdHJpbmcuXG4gICAgcmV0dXJuIEJpZ0ludCgoMCwgaGV4XzEuYWRkMHgpKHZhbHVlKSk7XG59O1xuZXhwb3J0cy5oZXhUb0JpZ0ludCA9IGhleFRvQmlnSW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVtYmVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImhleFRvQmlnSW50IiwiaGV4VG9OdW1iZXIiLCJiaWdJbnRUb0hleCIsIm51bWJlclRvSGV4IiwiYXNzZXJ0XzEiLCJyZXF1aXJlIiwiaGV4XzEiLCJhc3NlcnQiLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiYWRkMHgiLCJ0b1N0cmluZyIsImFzc2VydElzSGV4U3RyaW5nIiwibnVtYmVyVmFsdWUiLCJwYXJzZUludCIsIkJpZ0ludCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/number.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/opaque.js":
/*!************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/opaque.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n})); //# sourceMappingURL=opaque.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L29wYXF1ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQyxFQUM3RCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aXRoLW5leHQtYXBwLy4vbm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9vcGFxdWUuanM/NGJiMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wYXF1ZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/opaque.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/time.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/time.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.timeSince = exports.inMilliseconds = exports.Duration = void 0;\n/**\n * Common duration constants, in milliseconds.\n */ var Duration;\n(function(Duration) {\n    /**\n     * A millisecond.\n     */ Duration[Duration[\"Millisecond\"] = 1] = \"Millisecond\";\n    /**\n     * A second, in milliseconds.\n     */ Duration[Duration[\"Second\"] = 1000] = \"Second\";\n    /**\n     * A minute, in milliseconds.\n     */ Duration[Duration[\"Minute\"] = 60000] = \"Minute\";\n    /**\n     * An hour, in milliseconds.\n     */ Duration[Duration[\"Hour\"] = 3600000] = \"Hour\";\n    /**\n     * A day, in milliseconds.\n     */ Duration[Duration[\"Day\"] = 86400000] = \"Day\";\n    /**\n     * A week, in milliseconds.\n     */ Duration[Duration[\"Week\"] = 604800000] = \"Week\";\n    /**\n     * A year, in milliseconds.\n     */ Duration[Duration[\"Year\"] = 31536000000] = \"Year\";\n})(Duration = exports.Duration || (exports.Duration = {}));\nconst isNonNegativeInteger = (number)=>Number.isInteger(number) && number >= 0;\nconst assertIsNonNegativeInteger = (number, name)=>{\n    if (!isNonNegativeInteger(number)) {\n        throw new Error(`\"${name}\" must be a non-negative integer. Received: \"${number}\".`);\n    }\n};\n/**\n * Calculates the millisecond value of the specified number of units of time.\n *\n * @param count - The number of units of time.\n * @param duration - The unit of time to count.\n * @returns The count multiplied by the specified duration.\n */ function inMilliseconds(count, duration) {\n    assertIsNonNegativeInteger(count, \"count\");\n    return count * duration;\n}\nexports.inMilliseconds = inMilliseconds;\n/**\n * Gets the milliseconds since a particular Unix epoch timestamp.\n *\n * @param timestamp - A Unix millisecond timestamp.\n * @returns The number of milliseconds elapsed since the specified timestamp.\n */ function timeSince(timestamp) {\n    assertIsNonNegativeInteger(timestamp, \"timestamp\");\n    return Date.now() - timestamp;\n}\nexports.timeSince = timeSince; //# sourceMappingURL=time.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3RpbWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGlCQUFpQixHQUFHQSxzQkFBc0IsR0FBR0EsZ0JBQWdCLEdBQUcsS0FBSztBQUNyRTs7Q0FFQyxHQUNELElBQUlJO0FBQ0gsVUFBVUEsUUFBUTtJQUNmOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLGNBQWMsR0FBRyxFQUFFLEdBQUc7SUFDeEM7O0tBRUMsR0FDREEsUUFBUSxDQUFDQSxRQUFRLENBQUMsU0FBUyxHQUFHLEtBQUssR0FBRztJQUN0Qzs7S0FFQyxHQUNEQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxTQUFTLEdBQUcsTUFBTSxHQUFHO0lBQ3ZDOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLE9BQU8sR0FBRyxRQUFRLEdBQUc7SUFDdkM7O0tBRUMsR0FDREEsUUFBUSxDQUFDQSxRQUFRLENBQUMsTUFBTSxHQUFHLFNBQVMsR0FBRztJQUN2Qzs7S0FFQyxHQUNEQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxPQUFPLEdBQUcsVUFBVSxHQUFHO0lBQ3pDOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLE9BQU8sR0FBRyxZQUFZLEdBQUc7QUFDL0MsR0FBR0EsV0FBV0osUUFBUUksUUFBUSxJQUFLSixDQUFBQSxnQkFBZ0IsR0FBRyxDQUFDO0FBQ3ZELE1BQU1LLHVCQUF1QixDQUFDQyxTQUFXQyxPQUFPQyxTQUFTLENBQUNGLFdBQVdBLFVBQVU7QUFDL0UsTUFBTUcsNkJBQTZCLENBQUNILFFBQVFJO0lBQ3hDLElBQUksQ0FBQ0wscUJBQXFCQyxTQUFTO1FBQy9CLE1BQU0sSUFBSUssTUFBTSxDQUFDLENBQUMsRUFBRUQsS0FBSyw2Q0FBNkMsRUFBRUosT0FBTyxFQUFFLENBQUM7SUFDdEY7QUFDSjtBQUNBOzs7Ozs7Q0FNQyxHQUNELFNBQVNILGVBQWVTLEtBQUssRUFBRUMsUUFBUTtJQUNuQ0osMkJBQTJCRyxPQUFPO0lBQ2xDLE9BQU9BLFFBQVFDO0FBQ25CO0FBQ0FiLHNCQUFzQixHQUFHRztBQUN6Qjs7Ozs7Q0FLQyxHQUNELFNBQVNELFVBQVVZLFNBQVM7SUFDeEJMLDJCQUEyQkssV0FBVztJQUN0QyxPQUFPQyxLQUFLQyxHQUFHLEtBQUtGO0FBQ3hCO0FBQ0FkLGlCQUFpQixHQUFHRSxXQUNwQixnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aXRoLW5leHQtYXBwLy4vbm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC90aW1lLmpzPzAxYWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRpbWVTaW5jZSA9IGV4cG9ydHMuaW5NaWxsaXNlY29uZHMgPSBleHBvcnRzLkR1cmF0aW9uID0gdm9pZCAwO1xuLyoqXG4gKiBDb21tb24gZHVyYXRpb24gY29uc3RhbnRzLCBpbiBtaWxsaXNlY29uZHMuXG4gKi9cbnZhciBEdXJhdGlvbjtcbihmdW5jdGlvbiAoRHVyYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBBIG1pbGxpc2Vjb25kLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiTWlsbGlzZWNvbmRcIl0gPSAxXSA9IFwiTWlsbGlzZWNvbmRcIjtcbiAgICAvKipcbiAgICAgKiBBIHNlY29uZCwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiU2Vjb25kXCJdID0gMTAwMF0gPSBcIlNlY29uZFwiO1xuICAgIC8qKlxuICAgICAqIEEgbWludXRlLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJNaW51dGVcIl0gPSA2MDAwMF0gPSBcIk1pbnV0ZVwiO1xuICAgIC8qKlxuICAgICAqIEFuIGhvdXIsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIkhvdXJcIl0gPSAzNjAwMDAwXSA9IFwiSG91clwiO1xuICAgIC8qKlxuICAgICAqIEEgZGF5LCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJEYXlcIl0gPSA4NjQwMDAwMF0gPSBcIkRheVwiO1xuICAgIC8qKlxuICAgICAqIEEgd2VlaywgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiV2Vla1wiXSA9IDYwNDgwMDAwMF0gPSBcIldlZWtcIjtcbiAgICAvKipcbiAgICAgKiBBIHllYXIsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIlllYXJcIl0gPSAzMTUzNjAwMDAwMF0gPSBcIlllYXJcIjtcbn0pKER1cmF0aW9uID0gZXhwb3J0cy5EdXJhdGlvbiB8fCAoZXhwb3J0cy5EdXJhdGlvbiA9IHt9KSk7XG5jb25zdCBpc05vbk5lZ2F0aXZlSW50ZWdlciA9IChudW1iZXIpID0+IE51bWJlci5pc0ludGVnZXIobnVtYmVyKSAmJiBudW1iZXIgPj0gMDtcbmNvbnN0IGFzc2VydElzTm9uTmVnYXRpdmVJbnRlZ2VyID0gKG51bWJlciwgbmFtZSkgPT4ge1xuICAgIGlmICghaXNOb25OZWdhdGl2ZUludGVnZXIobnVtYmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlci4gUmVjZWl2ZWQ6IFwiJHtudW1iZXJ9XCIuYCk7XG4gICAgfVxufTtcbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbWlsbGlzZWNvbmQgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgdW5pdHMgb2YgdGltZS5cbiAqXG4gKiBAcGFyYW0gY291bnQgLSBUaGUgbnVtYmVyIG9mIHVuaXRzIG9mIHRpbWUuXG4gKiBAcGFyYW0gZHVyYXRpb24gLSBUaGUgdW5pdCBvZiB0aW1lIHRvIGNvdW50LlxuICogQHJldHVybnMgVGhlIGNvdW50IG11bHRpcGxpZWQgYnkgdGhlIHNwZWNpZmllZCBkdXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gaW5NaWxsaXNlY29uZHMoY291bnQsIGR1cmF0aW9uKSB7XG4gICAgYXNzZXJ0SXNOb25OZWdhdGl2ZUludGVnZXIoY291bnQsICdjb3VudCcpO1xuICAgIHJldHVybiBjb3VudCAqIGR1cmF0aW9uO1xufVxuZXhwb3J0cy5pbk1pbGxpc2Vjb25kcyA9IGluTWlsbGlzZWNvbmRzO1xuLyoqXG4gKiBHZXRzIHRoZSBtaWxsaXNlY29uZHMgc2luY2UgYSBwYXJ0aWN1bGFyIFVuaXggZXBvY2ggdGltZXN0YW1wLlxuICpcbiAqIEBwYXJhbSB0aW1lc3RhbXAgLSBBIFVuaXggbWlsbGlzZWNvbmQgdGltZXN0YW1wLlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZWxhcHNlZCBzaW5jZSB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcC5cbiAqL1xuZnVuY3Rpb24gdGltZVNpbmNlKHRpbWVzdGFtcCkge1xuICAgIGFzc2VydElzTm9uTmVnYXRpdmVJbnRlZ2VyKHRpbWVzdGFtcCwgJ3RpbWVzdGFtcCcpO1xuICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGltZXN0YW1wO1xufVxuZXhwb3J0cy50aW1lU2luY2UgPSB0aW1lU2luY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInRpbWVTaW5jZSIsImluTWlsbGlzZWNvbmRzIiwiRHVyYXRpb24iLCJpc05vbk5lZ2F0aXZlSW50ZWdlciIsIm51bWJlciIsIk51bWJlciIsImlzSW50ZWdlciIsImFzc2VydElzTm9uTmVnYXRpdmVJbnRlZ2VyIiwibmFtZSIsIkVycm9yIiwiY291bnQiLCJkdXJhdGlvbiIsInRpbWVzdGFtcCIsIkRhdGUiLCJub3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/time.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/transaction-types.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/transaction-types.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n})); //# sourceMappingURL=transaction-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3RyYW5zYWN0aW9uLXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDLEVBQzdELDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL3dpdGgtbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3RyYW5zYWN0aW9uLXR5cGVzLmpzPzIyMzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2FjdGlvbi10eXBlcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/transaction-types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/versions.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/versions.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.satisfiesVersionRange = exports.gtRange = exports.gtVersion = exports.assertIsSemVerRange = exports.assertIsSemVerVersion = exports.isValidSemVerRange = exports.isValidSemVerVersion = exports.VersionRangeStruct = exports.VersionStruct = void 0;\nconst semver_1 = __webpack_require__(/*! semver */ \"(ssr)/./node_modules/semver/index.js\");\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\nconst assert_1 = __webpack_require__(/*! ./assert */ \"(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/assert.js\");\n/**\n * A struct for validating a version string.\n */ exports.VersionStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), \"Version\", (value)=>{\n    if ((0, semver_1.valid)(value) === null) {\n        return `Expected SemVer version, got \"${value}\"`;\n    }\n    return true;\n});\nexports.VersionRangeStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), \"Version range\", (value)=>{\n    if ((0, semver_1.validRange)(value) === null) {\n        return `Expected SemVer range, got \"${value}\"`;\n    }\n    return true;\n});\n/**\n * Checks whether a SemVer version is valid.\n *\n * @param version - A potential version.\n * @returns `true` if the version is valid, and `false` otherwise.\n */ function isValidSemVerVersion(version) {\n    return (0, superstruct_1.is)(version, exports.VersionStruct);\n}\nexports.isValidSemVerVersion = isValidSemVerVersion;\n/**\n * Checks whether a SemVer version range is valid.\n *\n * @param versionRange - A potential version range.\n * @returns `true` if the version range is valid, and `false` otherwise.\n */ function isValidSemVerRange(versionRange) {\n    return (0, superstruct_1.is)(versionRange, exports.VersionRangeStruct);\n}\nexports.isValidSemVerRange = isValidSemVerRange;\n/**\n * Asserts that a value is a valid concrete SemVer version.\n *\n * @param version - A potential SemVer concrete version.\n */ function assertIsSemVerVersion(version) {\n    (0, assert_1.assertStruct)(version, exports.VersionStruct);\n}\nexports.assertIsSemVerVersion = assertIsSemVerVersion;\n/**\n * Asserts that a value is a valid SemVer range.\n *\n * @param range - A potential SemVer range.\n */ function assertIsSemVerRange(range) {\n    (0, assert_1.assertStruct)(range, exports.VersionRangeStruct);\n}\nexports.assertIsSemVerRange = assertIsSemVerRange;\n/**\n * Checks whether a SemVer version is greater than another.\n *\n * @param version1 - The left-hand version.\n * @param version2 - The right-hand version.\n * @returns `version1 > version2`.\n */ function gtVersion(version1, version2) {\n    return (0, semver_1.gt)(version1, version2);\n}\nexports.gtVersion = gtVersion;\n/**\n * Checks whether a SemVer version is greater than all possibilities in a range.\n *\n * @param version - A SemvVer version.\n * @param range - The range to check against.\n * @returns `version > range`.\n */ function gtRange(version, range) {\n    return (0, semver_1.gtr)(version, range);\n}\nexports.gtRange = gtRange;\n/**\n * Returns whether a SemVer version satisfies a SemVer range.\n *\n * @param version - The SemVer version to check.\n * @param versionRange - The SemVer version range to check against.\n * @returns Whether the version satisfied the version range.\n */ function satisfiesVersionRange(version, versionRange) {\n    return (0, semver_1.satisfies)(version, versionRange, {\n        includePrerelease: true\n    });\n}\nexports.satisfiesVersionRange = satisfiesVersionRange; //# sourceMappingURL=versions.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3ZlcnNpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCw2QkFBNkIsR0FBR0EsZUFBZSxHQUFHQSxpQkFBaUIsR0FBR0EsMkJBQTJCLEdBQUdBLDZCQUE2QixHQUFHQSwwQkFBMEIsR0FBR0EsNEJBQTRCLEdBQUdBLDBCQUEwQixHQUFHQSxxQkFBcUIsR0FBRyxLQUFLO0FBQzFQLE1BQU1XLFdBQVdDLG1CQUFPQSxDQUFDLG9EQUFRO0FBQ2pDLE1BQU1DLGdCQUFnQkQsbUJBQU9BLENBQUMsb0VBQWE7QUFDM0MsTUFBTUUsV0FBV0YsbUJBQU9BLENBQUMsb0dBQVU7QUFDbkM7O0NBRUMsR0FDRFoscUJBQXFCLEdBQUcsQ0FBQyxHQUFHYSxjQUFjRSxNQUFNLEVBQUUsQ0FBQyxHQUFHRixjQUFjRyxNQUFNLEtBQUssV0FBVyxDQUFDZjtJQUN2RixJQUFJLENBQUMsR0FBR1UsU0FBU00sS0FBSyxFQUFFaEIsV0FBVyxNQUFNO1FBQ3JDLE9BQU8sQ0FBQyw4QkFBOEIsRUFBRUEsTUFBTSxDQUFDLENBQUM7SUFDcEQ7SUFDQSxPQUFPO0FBQ1g7QUFDQUQsMEJBQTBCLEdBQUcsQ0FBQyxHQUFHYSxjQUFjRSxNQUFNLEVBQUUsQ0FBQyxHQUFHRixjQUFjRyxNQUFNLEtBQUssaUJBQWlCLENBQUNmO0lBQ2xHLElBQUksQ0FBQyxHQUFHVSxTQUFTTyxVQUFVLEVBQUVqQixXQUFXLE1BQU07UUFDMUMsT0FBTyxDQUFDLDRCQUE0QixFQUFFQSxNQUFNLENBQUMsQ0FBQztJQUNsRDtJQUNBLE9BQU87QUFDWDtBQUNBOzs7OztDQUtDLEdBQ0QsU0FBU08scUJBQXFCVyxPQUFPO0lBQ2pDLE9BQU8sQ0FBQyxHQUFHTixjQUFjTyxFQUFFLEVBQUVELFNBQVNuQixRQUFRVSxhQUFhO0FBQy9EO0FBQ0FWLDRCQUE0QixHQUFHUTtBQUMvQjs7Ozs7Q0FLQyxHQUNELFNBQVNELG1CQUFtQmMsWUFBWTtJQUNwQyxPQUFPLENBQUMsR0FBR1IsY0FBY08sRUFBRSxFQUFFQyxjQUFjckIsUUFBUVMsa0JBQWtCO0FBQ3pFO0FBQ0FULDBCQUEwQixHQUFHTztBQUM3Qjs7OztDQUlDLEdBQ0QsU0FBU0Qsc0JBQXNCYSxPQUFPO0lBQ2pDLElBQUdMLFNBQVNRLFlBQVksRUFBRUgsU0FBU25CLFFBQVFVLGFBQWE7QUFDN0Q7QUFDQVYsNkJBQTZCLEdBQUdNO0FBQ2hDOzs7O0NBSUMsR0FDRCxTQUFTRCxvQkFBb0JrQixLQUFLO0lBQzdCLElBQUdULFNBQVNRLFlBQVksRUFBRUMsT0FBT3ZCLFFBQVFTLGtCQUFrQjtBQUNoRTtBQUNBVCwyQkFBMkIsR0FBR0s7QUFDOUI7Ozs7OztDQU1DLEdBQ0QsU0FBU0QsVUFBVW9CLFFBQVEsRUFBRUMsUUFBUTtJQUNqQyxPQUFPLENBQUMsR0FBR2QsU0FBU2UsRUFBRSxFQUFFRixVQUFVQztBQUN0QztBQUNBekIsaUJBQWlCLEdBQUdJO0FBQ3BCOzs7Ozs7Q0FNQyxHQUNELFNBQVNELFFBQVFnQixPQUFPLEVBQUVJLEtBQUs7SUFDM0IsT0FBTyxDQUFDLEdBQUdaLFNBQVNnQixHQUFHLEVBQUVSLFNBQVNJO0FBQ3RDO0FBQ0F2QixlQUFlLEdBQUdHO0FBQ2xCOzs7Ozs7Q0FNQyxHQUNELFNBQVNELHNCQUFzQmlCLE9BQU8sRUFBRUUsWUFBWTtJQUNoRCxPQUFPLENBQUMsR0FBR1YsU0FBU2lCLFNBQVMsRUFBRVQsU0FBU0UsY0FBYztRQUNsRFEsbUJBQW1CO0lBQ3ZCO0FBQ0o7QUFDQTdCLDZCQUE2QixHQUFHRSx1QkFDaEMsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2l0aC1uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvdmVyc2lvbnMuanM/MDgxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2F0aXNmaWVzVmVyc2lvblJhbmdlID0gZXhwb3J0cy5ndFJhbmdlID0gZXhwb3J0cy5ndFZlcnNpb24gPSBleHBvcnRzLmFzc2VydElzU2VtVmVyUmFuZ2UgPSBleHBvcnRzLmFzc2VydElzU2VtVmVyVmVyc2lvbiA9IGV4cG9ydHMuaXNWYWxpZFNlbVZlclJhbmdlID0gZXhwb3J0cy5pc1ZhbGlkU2VtVmVyVmVyc2lvbiA9IGV4cG9ydHMuVmVyc2lvblJhbmdlU3RydWN0ID0gZXhwb3J0cy5WZXJzaW9uU3RydWN0ID0gdm9pZCAwO1xuY29uc3Qgc2VtdmVyXzEgPSByZXF1aXJlKFwic2VtdmVyXCIpO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJzdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0XCIpO1xuLyoqXG4gKiBBIHN0cnVjdCBmb3IgdmFsaWRhdGluZyBhIHZlcnNpb24gc3RyaW5nLlxuICovXG5leHBvcnRzLlZlcnNpb25TdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5yZWZpbmUpKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgJ1ZlcnNpb24nLCAodmFsdWUpID0+IHtcbiAgICBpZiAoKDAsIHNlbXZlcl8xLnZhbGlkKSh2YWx1ZSkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCBTZW1WZXIgdmVyc2lvbiwgZ290IFwiJHt2YWx1ZX1cImA7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufSk7XG5leHBvcnRzLlZlcnNpb25SYW5nZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnJlZmluZSkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCAnVmVyc2lvbiByYW5nZScsICh2YWx1ZSkgPT4ge1xuICAgIGlmICgoMCwgc2VtdmVyXzEudmFsaWRSYW5nZSkodmFsdWUpID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBgRXhwZWN0ZWQgU2VtVmVyIHJhbmdlLCBnb3QgXCIke3ZhbHVlfVwiYDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBTZW1WZXIgdmVyc2lvbiBpcyB2YWxpZC5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvbiAtIEEgcG90ZW50aWFsIHZlcnNpb24uXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZlcnNpb24gaXMgdmFsaWQsIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFNlbVZlclZlcnNpb24odmVyc2lvbikge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmVyc2lvbiwgZXhwb3J0cy5WZXJzaW9uU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNWYWxpZFNlbVZlclZlcnNpb24gPSBpc1ZhbGlkU2VtVmVyVmVyc2lvbjtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBTZW1WZXIgdmVyc2lvbiByYW5nZSBpcyB2YWxpZC5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvblJhbmdlIC0gQSBwb3RlbnRpYWwgdmVyc2lvbiByYW5nZS5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmVyc2lvbiByYW5nZSBpcyB2YWxpZCwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkU2VtVmVyUmFuZ2UodmVyc2lvblJhbmdlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2ZXJzaW9uUmFuZ2UsIGV4cG9ydHMuVmVyc2lvblJhbmdlU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNWYWxpZFNlbVZlclJhbmdlID0gaXNWYWxpZFNlbVZlclJhbmdlO1xuLyoqXG4gKiBBc3NlcnRzIHRoYXQgYSB2YWx1ZSBpcyBhIHZhbGlkIGNvbmNyZXRlIFNlbVZlciB2ZXJzaW9uLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gQSBwb3RlbnRpYWwgU2VtVmVyIGNvbmNyZXRlIHZlcnNpb24uXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzU2VtVmVyVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmVyc2lvbiwgZXhwb3J0cy5WZXJzaW9uU3RydWN0KTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNTZW1WZXJWZXJzaW9uID0gYXNzZXJ0SXNTZW1WZXJWZXJzaW9uO1xuLyoqXG4gKiBBc3NlcnRzIHRoYXQgYSB2YWx1ZSBpcyBhIHZhbGlkIFNlbVZlciByYW5nZS5cbiAqXG4gKiBAcGFyYW0gcmFuZ2UgLSBBIHBvdGVudGlhbCBTZW1WZXIgcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzU2VtVmVyUmFuZ2UocmFuZ2UpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KShyYW5nZSwgZXhwb3J0cy5WZXJzaW9uUmFuZ2VTdHJ1Y3QpO1xufVxuZXhwb3J0cy5hc3NlcnRJc1NlbVZlclJhbmdlID0gYXNzZXJ0SXNTZW1WZXJSYW5nZTtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBTZW1WZXIgdmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gYW5vdGhlci5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvbjEgLSBUaGUgbGVmdC1oYW5kIHZlcnNpb24uXG4gKiBAcGFyYW0gdmVyc2lvbjIgLSBUaGUgcmlnaHQtaGFuZCB2ZXJzaW9uLlxuICogQHJldHVybnMgYHZlcnNpb24xID4gdmVyc2lvbjJgLlxuICovXG5mdW5jdGlvbiBndFZlcnNpb24odmVyc2lvbjEsIHZlcnNpb24yKSB7XG4gICAgcmV0dXJuICgwLCBzZW12ZXJfMS5ndCkodmVyc2lvbjEsIHZlcnNpb24yKTtcbn1cbmV4cG9ydHMuZ3RWZXJzaW9uID0gZ3RWZXJzaW9uO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIGlzIGdyZWF0ZXIgdGhhbiBhbGwgcG9zc2liaWxpdGllcyBpbiBhIHJhbmdlLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gQSBTZW12VmVyIHZlcnNpb24uXG4gKiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIGB2ZXJzaW9uID4gcmFuZ2VgLlxuICovXG5mdW5jdGlvbiBndFJhbmdlKHZlcnNpb24sIHJhbmdlKSB7XG4gICAgcmV0dXJuICgwLCBzZW12ZXJfMS5ndHIpKHZlcnNpb24sIHJhbmdlKTtcbn1cbmV4cG9ydHMuZ3RSYW5nZSA9IGd0UmFuZ2U7XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIHNhdGlzZmllcyBhIFNlbVZlciByYW5nZS5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvbiAtIFRoZSBTZW1WZXIgdmVyc2lvbiB0byBjaGVjay5cbiAqIEBwYXJhbSB2ZXJzaW9uUmFuZ2UgLSBUaGUgU2VtVmVyIHZlcnNpb24gcmFuZ2UgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZlcnNpb24gc2F0aXNmaWVkIHRoZSB2ZXJzaW9uIHJhbmdlLlxuICovXG5mdW5jdGlvbiBzYXRpc2ZpZXNWZXJzaW9uUmFuZ2UodmVyc2lvbiwgdmVyc2lvblJhbmdlKSB7XG4gICAgcmV0dXJuICgwLCBzZW12ZXJfMS5zYXRpc2ZpZXMpKHZlcnNpb24sIHZlcnNpb25SYW5nZSwge1xuICAgICAgICBpbmNsdWRlUHJlcmVsZWFzZTogdHJ1ZSxcbiAgICB9KTtcbn1cbmV4cG9ydHMuc2F0aXNmaWVzVmVyc2lvblJhbmdlID0gc2F0aXNmaWVzVmVyc2lvblJhbmdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbnMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic2F0aXNmaWVzVmVyc2lvblJhbmdlIiwiZ3RSYW5nZSIsImd0VmVyc2lvbiIsImFzc2VydElzU2VtVmVyUmFuZ2UiLCJhc3NlcnRJc1NlbVZlclZlcnNpb24iLCJpc1ZhbGlkU2VtVmVyUmFuZ2UiLCJpc1ZhbGlkU2VtVmVyVmVyc2lvbiIsIlZlcnNpb25SYW5nZVN0cnVjdCIsIlZlcnNpb25TdHJ1Y3QiLCJzZW12ZXJfMSIsInJlcXVpcmUiLCJzdXBlcnN0cnVjdF8xIiwiYXNzZXJ0XzEiLCJyZWZpbmUiLCJzdHJpbmciLCJ2YWxpZCIsInZhbGlkUmFuZ2UiLCJ2ZXJzaW9uIiwiaXMiLCJ2ZXJzaW9uUmFuZ2UiLCJhc3NlcnRTdHJ1Y3QiLCJyYW5nZSIsInZlcnNpb24xIiwidmVyc2lvbjIiLCJndCIsImd0ciIsInNhdGlzZmllcyIsImluY2x1ZGVQcmVyZWxlYXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/@metamask/utils/dist/versions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/eth-block-tracker/node_modules/pify/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/eth-block-tracker/node_modules/pify/index.js ***!
  \*******************************************************************/
/***/ ((module) => {

eval("\nconst processFn = (fn, opts)=>function() {\n        const P = opts.promiseModule;\n        const args = new Array(arguments.length);\n        for(let i = 0; i < arguments.length; i++){\n            args[i] = arguments[i];\n        }\n        return new P((resolve, reject)=>{\n            if (opts.errorFirst) {\n                args.push(function(err, result) {\n                    if (opts.multiArgs) {\n                        const results = new Array(arguments.length - 1);\n                        for(let i = 1; i < arguments.length; i++){\n                            results[i - 1] = arguments[i];\n                        }\n                        if (err) {\n                            results.unshift(err);\n                            reject(results);\n                        } else {\n                            resolve(results);\n                        }\n                    } else if (err) {\n                        reject(err);\n                    } else {\n                        resolve(result);\n                    }\n                });\n            } else {\n                args.push(function(result) {\n                    if (opts.multiArgs) {\n                        const results = new Array(arguments.length - 1);\n                        for(let i = 0; i < arguments.length; i++){\n                            results[i] = arguments[i];\n                        }\n                        resolve(results);\n                    } else {\n                        resolve(result);\n                    }\n                });\n            }\n            fn.apply(this, args);\n        });\n    };\nmodule.exports = (obj, opts)=>{\n    opts = Object.assign({\n        exclude: [\n            /.+(Sync|Stream)$/\n        ],\n        errorFirst: true,\n        promiseModule: Promise\n    }, opts);\n    const filter = (key)=>{\n        const match = (pattern)=>typeof pattern === \"string\" ? key === pattern : pattern.test(key);\n        return opts.include ? opts.include.some(match) : !opts.exclude.some(match);\n    };\n    let ret;\n    if (typeof obj === \"function\") {\n        ret = function() {\n            if (opts.excludeMain) {\n                return obj.apply(this, arguments);\n            }\n            return processFn(obj, opts).apply(this, arguments);\n        };\n    } else {\n        ret = Object.create(Object.getPrototypeOf(obj));\n    }\n    for(const key in obj){\n        const x = obj[key];\n        ret[key] = typeof x === \"function\" && filter(key) ? processFn(x, opts) : x;\n    }\n    return ret;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3BpZnkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxZQUFZLENBQUNDLElBQUlDLE9BQVM7UUFDL0IsTUFBTUMsSUFBSUQsS0FBS0UsYUFBYTtRQUM1QixNQUFNQyxPQUFPLElBQUlDLE1BQU1DLFVBQVVDLE1BQU07UUFFdkMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLFVBQVVDLE1BQU0sRUFBRUMsSUFBSztZQUMxQ0osSUFBSSxDQUFDSSxFQUFFLEdBQUdGLFNBQVMsQ0FBQ0UsRUFBRTtRQUN2QjtRQUVBLE9BQU8sSUFBSU4sRUFBRSxDQUFDTyxTQUFTQztZQUN0QixJQUFJVCxLQUFLVSxVQUFVLEVBQUU7Z0JBQ3BCUCxLQUFLUSxJQUFJLENBQUMsU0FBVUMsR0FBRyxFQUFFQyxNQUFNO29CQUM5QixJQUFJYixLQUFLYyxTQUFTLEVBQUU7d0JBQ25CLE1BQU1DLFVBQVUsSUFBSVgsTUFBTUMsVUFBVUMsTUFBTSxHQUFHO3dCQUU3QyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsVUFBVUMsTUFBTSxFQUFFQyxJQUFLOzRCQUMxQ1EsT0FBTyxDQUFDUixJQUFJLEVBQUUsR0FBR0YsU0FBUyxDQUFDRSxFQUFFO3dCQUM5Qjt3QkFFQSxJQUFJSyxLQUFLOzRCQUNSRyxRQUFRQyxPQUFPLENBQUNKOzRCQUNoQkgsT0FBT007d0JBQ1IsT0FBTzs0QkFDTlAsUUFBUU87d0JBQ1Q7b0JBQ0QsT0FBTyxJQUFJSCxLQUFLO3dCQUNmSCxPQUFPRztvQkFDUixPQUFPO3dCQUNOSixRQUFRSztvQkFDVDtnQkFDRDtZQUNELE9BQU87Z0JBQ05WLEtBQUtRLElBQUksQ0FBQyxTQUFVRSxNQUFNO29CQUN6QixJQUFJYixLQUFLYyxTQUFTLEVBQUU7d0JBQ25CLE1BQU1DLFVBQVUsSUFBSVgsTUFBTUMsVUFBVUMsTUFBTSxHQUFHO3dCQUU3QyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsVUFBVUMsTUFBTSxFQUFFQyxJQUFLOzRCQUMxQ1EsT0FBTyxDQUFDUixFQUFFLEdBQUdGLFNBQVMsQ0FBQ0UsRUFBRTt3QkFDMUI7d0JBRUFDLFFBQVFPO29CQUNULE9BQU87d0JBQ05QLFFBQVFLO29CQUNUO2dCQUNEO1lBQ0Q7WUFFQWQsR0FBR2tCLEtBQUssQ0FBQyxJQUFJLEVBQUVkO1FBQ2hCO0lBQ0Q7QUFFQWUsT0FBT0MsT0FBTyxHQUFHLENBQUNDLEtBQUtwQjtJQUN0QkEsT0FBT3FCLE9BQU9DLE1BQU0sQ0FBQztRQUNwQkMsU0FBUztZQUFDO1NBQW1CO1FBQzdCYixZQUFZO1FBQ1pSLGVBQWVzQjtJQUNoQixHQUFHeEI7SUFFSCxNQUFNeUIsU0FBU0MsQ0FBQUE7UUFDZCxNQUFNQyxRQUFRQyxDQUFBQSxVQUFXLE9BQU9BLFlBQVksV0FBV0YsUUFBUUUsVUFBVUEsUUFBUUMsSUFBSSxDQUFDSDtRQUN0RixPQUFPMUIsS0FBSzhCLE9BQU8sR0FBRzlCLEtBQUs4QixPQUFPLENBQUNDLElBQUksQ0FBQ0osU0FBUyxDQUFDM0IsS0FBS3VCLE9BQU8sQ0FBQ1EsSUFBSSxDQUFDSjtJQUNyRTtJQUVBLElBQUlLO0lBQ0osSUFBSSxPQUFPWixRQUFRLFlBQVk7UUFDOUJZLE1BQU07WUFDTCxJQUFJaEMsS0FBS2lDLFdBQVcsRUFBRTtnQkFDckIsT0FBT2IsSUFBSUgsS0FBSyxDQUFDLElBQUksRUFBRVo7WUFDeEI7WUFFQSxPQUFPUCxVQUFVc0IsS0FBS3BCLE1BQU1pQixLQUFLLENBQUMsSUFBSSxFQUFFWjtRQUN6QztJQUNELE9BQU87UUFDTjJCLE1BQU1YLE9BQU9hLE1BQU0sQ0FBQ2IsT0FBT2MsY0FBYyxDQUFDZjtJQUMzQztJQUVBLElBQUssTUFBTU0sT0FBT04sSUFBSztRQUN0QixNQUFNZ0IsSUFBSWhCLEdBQUcsQ0FBQ00sSUFBSTtRQUNsQk0sR0FBRyxDQUFDTixJQUFJLEdBQUcsT0FBT1UsTUFBTSxjQUFjWCxPQUFPQyxPQUFPNUIsVUFBVXNDLEdBQUdwQyxRQUFRb0M7SUFDMUU7SUFFQSxPQUFPSjtBQUNSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2l0aC1uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9ub2RlX21vZHVsZXMvcGlmeS9pbmRleC5qcz9jMTVkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgcHJvY2Vzc0ZuID0gKGZuLCBvcHRzKSA9PiBmdW5jdGlvbiAoKSB7XG5cdGNvbnN0IFAgPSBvcHRzLnByb21pc2VNb2R1bGU7XG5cdGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuXHR9XG5cblx0cmV0dXJuIG5ldyBQKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRpZiAob3B0cy5lcnJvckZpcnN0KSB7XG5cdFx0XHRhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG5cdFx0XHRcdGlmIChvcHRzLm11bHRpQXJncykge1xuXHRcdFx0XHRcdGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHJlc3VsdHNbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRcdHJlc3VsdHMudW5zaGlmdChlcnIpO1xuXHRcdFx0XHRcdFx0cmVqZWN0KHJlc3VsdHMpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChlcnIpIHtcblx0XHRcdFx0XHRyZWplY3QoZXJyKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhcmdzLnB1c2goZnVuY3Rpb24gKHJlc3VsdCkge1xuXHRcdFx0XHRpZiAob3B0cy5tdWx0aUFyZ3MpIHtcblx0XHRcdFx0XHRjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzW2ldID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0cyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRmbi5hcHBseSh0aGlzLCBhcmdzKTtcblx0fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChvYmosIG9wdHMpID0+IHtcblx0b3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdGV4Y2x1ZGU6IFsvLisoU3luY3xTdHJlYW0pJC9dLFxuXHRcdGVycm9yRmlyc3Q6IHRydWUsXG5cdFx0cHJvbWlzZU1vZHVsZTogUHJvbWlzZVxuXHR9LCBvcHRzKTtcblxuXHRjb25zdCBmaWx0ZXIgPSBrZXkgPT4ge1xuXHRcdGNvbnN0IG1hdGNoID0gcGF0dGVybiA9PiB0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycgPyBrZXkgPT09IHBhdHRlcm4gOiBwYXR0ZXJuLnRlc3Qoa2V5KTtcblx0XHRyZXR1cm4gb3B0cy5pbmNsdWRlID8gb3B0cy5pbmNsdWRlLnNvbWUobWF0Y2gpIDogIW9wdHMuZXhjbHVkZS5zb21lKG1hdGNoKTtcblx0fTtcblxuXHRsZXQgcmV0O1xuXHRpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChvcHRzLmV4Y2x1ZGVNYWluKSB7XG5cdFx0XHRcdHJldHVybiBvYmouYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHByb2Nlc3NGbihvYmosIG9wdHMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRyZXQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopKTtcblx0fVxuXG5cdGZvciAoY29uc3Qga2V5IGluIG9iaikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGd1YXJkLWZvci1pblxuXHRcdGNvbnN0IHggPSBvYmpba2V5XTtcblx0XHRyZXRba2V5XSA9IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nICYmIGZpbHRlcihrZXkpID8gcHJvY2Vzc0ZuKHgsIG9wdHMpIDogeDtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuIl0sIm5hbWVzIjpbInByb2Nlc3NGbiIsImZuIiwib3B0cyIsIlAiLCJwcm9taXNlTW9kdWxlIiwiYXJncyIsIkFycmF5IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiaSIsInJlc29sdmUiLCJyZWplY3QiLCJlcnJvckZpcnN0IiwicHVzaCIsImVyciIsInJlc3VsdCIsIm11bHRpQXJncyIsInJlc3VsdHMiLCJ1bnNoaWZ0IiwiYXBwbHkiLCJtb2R1bGUiLCJleHBvcnRzIiwib2JqIiwiT2JqZWN0IiwiYXNzaWduIiwiZXhjbHVkZSIsIlByb21pc2UiLCJmaWx0ZXIiLCJrZXkiLCJtYXRjaCIsInBhdHRlcm4iLCJ0ZXN0IiwiaW5jbHVkZSIsInNvbWUiLCJyZXQiLCJleGNsdWRlTWFpbiIsImNyZWF0ZSIsImdldFByb3RvdHlwZU9mIiwieCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eth-block-tracker/node_modules/pify/index.js\n");

/***/ })

};
;